schema {
  query: QueryRoot
  mutation: Mutation
}


directive @oneOf on INPUT_OBJECT


directive @specifiedBy(

  url: String!
) on SCALAR


directive @accessRestricted(

  reason: String 
) on FIELD_DEFINITION | OBJECT


type AbandonedCheckout implements Navigable & Node {

  abandonedCheckoutUrl: URL!


  defaultCursor: String!


  id: ID!


  lineItems(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): AbandonedCheckoutLineItemConnection!


  lineItemsQuantity: Int!


  totalPriceSet: MoneyBag!
}


type AbandonedCheckoutLineItem implements Node {

  customAttributes: [Attribute!]!


  discountedTotalPriceSet: MoneyBag!


  discountedTotalPriceWithCodeDiscount: MoneyBag!


  discountedUnitPriceSet: MoneyBag!


  discountedUnitPriceWithCodeDiscount: MoneyBag!


  id: ID!


  image: Image


  originalTotalPriceSet: MoneyBag!


  originalUnitPriceSet: MoneyBag!


  product: Product


  quantity: Int!


  sku: String


  title: String


  variant: ProductVariant


  variantTitle: String
}


type AbandonedCheckoutLineItemConnection {

  edges: [AbandonedCheckoutLineItemEdge!]!


  nodes: [AbandonedCheckoutLineItem!]!


  pageInfo: PageInfo!
}


type AbandonedCheckoutLineItemEdge {

  cursor: String!


  node: AbandonedCheckoutLineItem!
}


type Abandonment implements Node {

  abandonedCheckoutPayload: AbandonedCheckout


  abandonmentType: AbandonmentAbandonmentType!


  app: App!


  cartUrl: URL


  createdAt: DateTime!


  customer: Customer!


  customerHasNoDraftOrderSinceAbandonment: Boolean!


  customerHasNoOrderSinceAbandonment: Boolean!


  daysSinceLastAbandonmentEmail: Int!


  emailSentAt: DateTime


  emailState: AbandonmentEmailState


  hoursSinceLastAbandonedCheckout: Float


  id: ID!


  inventoryAvailable: Boolean!


  isFromOnlineStore: Boolean!


  isFromShopApp: Boolean!


  isFromShopPay: Boolean!


  isMostSignificantAbandonment: Boolean!


  lastBrowseAbandonmentDate: DateTime!


  lastCartAbandonmentDate: DateTime!


  lastCheckoutAbandonmentDate: DateTime!


  mostRecentStep: AbandonmentAbandonmentType!


  productsAddedToCart(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): CustomerVisitProductInfoConnection!


  productsViewed(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): CustomerVisitProductInfoConnection!


  visitStartedAt: DateTime
}


enum AbandonmentAbandonmentType {

  BROWSE


  CART


  CHECKOUT
}


enum AbandonmentDeliveryState {

  NOT_SENT


  SENT


  SCHEDULED
}


enum AbandonmentEmailState {

  NOT_SENT


  SENT


  SCHEDULED
}


type AbandonmentEmailStateUpdatePayload {

  abandonment: Abandonment


  userErrors: [AbandonmentEmailStateUpdateUserError!]!
}


type AbandonmentEmailStateUpdateUserError implements DisplayableError {

  code: AbandonmentEmailStateUpdateUserErrorCode


  field: [String!]


  message: String!
}


enum AbandonmentEmailStateUpdateUserErrorCode {

  ABANDONMENT_NOT_FOUND
}


type AbandonmentUpdateActivitiesDeliveryStatusesPayload {

  abandonment: Abandonment


  userErrors: [AbandonmentUpdateActivitiesDeliveryStatusesUserError!]!
}


type AbandonmentUpdateActivitiesDeliveryStatusesUserError implements DisplayableError {

  code: AbandonmentUpdateActivitiesDeliveryStatusesUserErrorCode


  field: [String!]


  message: String!
}


enum AbandonmentUpdateActivitiesDeliveryStatusesUserErrorCode {

  ABANDONMENT_NOT_FOUND


  MARKETING_ACTIVITY_NOT_FOUND


  DELIVERY_STATUS_INFO_NOT_FOUND
}


type AccessScope {

  description: String!


  handle: String!
}


type AddAllProductsOperation implements Node & ResourceOperation {

  id: ID!


  processedRowCount: Int


  rowCount: RowCount


  status: ResourceOperationStatus!
}


type AdditionalFee implements Node {

  id: ID!


  name: String!


  price: MoneyBag!


  taxLines: [TaxLine!]!
}


type AdditionalFeeSale implements Sale {

  actionType: SaleActionType!


  additionalFee: SaleAdditionalFee!


  id: ID!


  lineType: SaleLineType!


  quantity: Int


  taxes: [SaleTax!]!


  totalAmount: MoneyBag!


  totalDiscountAmountAfterTaxes: MoneyBag!


  totalDiscountAmountBeforeTaxes: MoneyBag!


  totalTaxAmount: MoneyBag!
}


type AdjustmentSale implements Sale {

  actionType: SaleActionType!


  id: ID!


  lineType: SaleLineType!


  quantity: Int


  taxes: [SaleTax!]!


  totalAmount: MoneyBag!


  totalDiscountAmountAfterTaxes: MoneyBag!


  totalDiscountAmountBeforeTaxes: MoneyBag!


  totalTaxAmount: MoneyBag!
}


type AllDiscountItems {

  allItems: Boolean!
}


type ApiVersion {

  displayName: String!


  handle: String!


  supported: Boolean!
}


type App implements Node {

  apiKey: String!


  appStoreAppUrl: URL


  appStoreDeveloperUrl: URL


  availableAccessScopes: [AccessScope!]!


  banner: Image!


  description: String


  developerName: String


  developerType: AppDeveloperType!


  developerUrl: URL! @deprecated(reason: "Use `appStoreDeveloperUrl` instead.")


  embedded: Boolean!


  failedRequirements: [FailedRequirement!]!


  features: [String!]!


  feedback: AppFeedback


  handle: String


  icon: Image!


  id: ID!


  installUrl: URL


  installation: AppInstallation


  isPostPurchaseAppInUse: Boolean!


  launchUrl: URL! @deprecated(reason: "Use AppInstallation.launchUrl instead")


  navigationItems: [NavigationItem!]! @deprecated(reason: "Use AppInstallation.navigationItems instead")


  previouslyInstalled: Boolean!


  pricingDetails: String


  pricingDetailsSummary: String!


  privacyPolicyUrl: URL


  publicCategory: AppPublicCategory!


  published: Boolean!


  requestedAccessScopes: [AccessScope!]!


  screenshots: [Image!]!


  shopifyDeveloped: Boolean!


  title: String!


  uninstallMessage: String!


  uninstallUrl: URL @deprecated(reason: "Use AppInstallation.uninstallUrl instead")


  webhookApiVersion: String!
}


type AppCatalog implements Catalog & Node {

  apps(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): AppConnection!


  id: ID!


  operations: [ResourceOperation!]!


  priceList: PriceList


  publication: Publication


  status: CatalogStatus!


  title: String!
}


type AppConnection {

  edges: [AppEdge!]!


  nodes: [App!]!


  pageInfo: PageInfo!
}


type AppCredit implements Node {

  amount: MoneyV2!


  createdAt: DateTime!


  description: String!


  id: ID!


  test: Boolean!
}


type AppCreditConnection {

  edges: [AppCreditEdge!]!


  nodes: [AppCredit!]!


  pageInfo: PageInfo!
}


type AppCreditEdge {

  cursor: String!


  node: AppCredit!
}


enum AppDeveloperType {

  SHOPIFY


  PARTNER


  MERCHANT


  UNKNOWN
}


type AppDiscountType {

  app: App!


  appBridge: FunctionsAppBridge!


  appKey: String!


  description: String


  discountClass: DiscountClass!


  functionId: String!


  targetType: DiscountApplicationTargetType!


  title: String!
}


type AppEdge {

  cursor: String!


  node: App!
}


type AppFeedback {

  app: App!


  link: Link


  messages: [UserError!]!
}


type AppInstallation implements HasMetafields & Node {

  accessScopes: [AccessScope!]!


  activeSubscriptions: [AppSubscription!]!


  allSubscriptions(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: AppSubscriptionSortKeys = CREATED_AT
  ): AppSubscriptionConnection!


  app: App!


  channel: Channel @deprecated(reason: "Use `publication` instead.")


  credits(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: AppTransactionSortKeys = CREATED_AT
  ): AppCreditConnection!


  id: ID!


  launchUrl: URL!


  metafield(

    namespace: String


    key: String!
  ): Metafield


  metafields(

    namespace: String


    keys: [String!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  oneTimePurchases(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: AppTransactionSortKeys = CREATED_AT
  ): AppPurchaseOneTimeConnection!


  privateMetafield(

    namespace: String!


    key: String!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  publication: Publication


  revenueAttributionRecords(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: AppRevenueAttributionRecordSortKeys = CREATED_AT
  ): AppRevenueAttributionRecordConnection!


  subscriptions: [AppSubscription!]! @deprecated(reason: "Use `activeSubscriptions` instead.")


  uninstallUrl: URL
}


enum AppInstallationCategory {

  CHANNEL


  POS_EMBEDDED
}


type AppInstallationConnection {

  edges: [AppInstallationEdge!]!


  nodes: [AppInstallation!]!


  pageInfo: PageInfo!
}


type AppInstallationEdge {

  cursor: String!


  node: AppInstallation!
}


enum AppInstallationPrivacy {
  PUBLIC
  PRIVATE
}


enum AppInstallationSortKeys {

  INSTALLED_AT


  APP_TITLE


  ID


  RELEVANCE
}


input AppPlanInput {

  appUsagePricingDetails: AppUsagePricingInput


  appRecurringPricingDetails: AppRecurringPricingInput
}


type AppPlanV2 {

  pricingDetails: AppPricingDetails!
}


union AppPricingDetails = AppRecurringPricing | AppUsagePricing


enum AppPricingInterval {

  ANNUAL


  EVERY_30_DAYS
}


enum AppPublicCategory {

  PRIVATE


  PUBLIC


  CUSTOM


  OTHER
}


interface AppPurchase {

  createdAt: DateTime!


  name: String!


  price: MoneyV2!


  status: AppPurchaseStatus!


  test: Boolean!
}


type AppPurchaseOneTime implements AppPurchase & Node {

  createdAt: DateTime!


  id: ID!


  name: String!


  price: MoneyV2!


  status: AppPurchaseStatus!


  test: Boolean!
}


type AppPurchaseOneTimeConnection {

  edges: [AppPurchaseOneTimeEdge!]!


  nodes: [AppPurchaseOneTime!]!


  pageInfo: PageInfo!
}


type AppPurchaseOneTimeCreatePayload {

  appPurchaseOneTime: AppPurchaseOneTime


  confirmationUrl: URL


  userErrors: [UserError!]!
}


type AppPurchaseOneTimeEdge {

  cursor: String!


  node: AppPurchaseOneTime!
}


enum AppPurchaseStatus {

  ACCEPTED @deprecated(reason: "As of API version 2021-01, when a merchant accepts an app purchase, the status immediately changes from `pending` to `active`.")


  ACTIVE


  DECLINED


  EXPIRED


  PENDING
}


type AppRecurringPricing {

  discount: AppSubscriptionDiscount


  interval: AppPricingInterval!


  price: MoneyV2!
}


input AppRecurringPricingInput {

  interval: AppPricingInterval = EVERY_30_DAYS


  price: MoneyInput!


  discount: AppSubscriptionDiscountInput
}


type AppRevenueAttributionRecord implements Node {

  amount: MoneyV2!


  capturedAt: DateTime!


  createdAt: DateTime!


  id: ID!


  idempotencyKey: String!


  test: Boolean!


  type: AppRevenueAttributionType!
}


type AppRevenueAttributionRecordConnection {

  edges: [AppRevenueAttributionRecordEdge!]!


  nodes: [AppRevenueAttributionRecord!]!


  pageInfo: PageInfo!
}


type AppRevenueAttributionRecordEdge {

  cursor: String!


  node: AppRevenueAttributionRecord!
}


enum AppRevenueAttributionRecordSortKeys {

  CREATED_AT


  ID


  RELEVANCE
}


enum AppRevenueAttributionType {

  APPLICATION_PURCHASE


  APPLICATION_SUBSCRIPTION


  APPLICATION_USAGE


  OTHER
}


type AppSubscription implements Node {

  createdAt: DateTime!


  currentPeriodEnd: DateTime


  id: ID!


  lineItems: [AppSubscriptionLineItem!]!


  name: String!


  returnUrl: URL!


  status: AppSubscriptionStatus!


  test: Boolean!


  trialDays: Int!
}


type AppSubscriptionCancelPayload {

  appSubscription: AppSubscription


  userErrors: [UserError!]!
}


type AppSubscriptionConnection {

  edges: [AppSubscriptionEdge!]!


  nodes: [AppSubscription!]!


  pageInfo: PageInfo!
}


type AppSubscriptionCreatePayload {

  appSubscription: AppSubscription


  confirmationUrl: URL


  userErrors: [UserError!]!
}


type AppSubscriptionDiscount {

  durationLimitInIntervals: Int


  priceAfterDiscount: MoneyV2!


  remainingDurationInIntervals: Int


  value: AppSubscriptionDiscountValue!
}


type AppSubscriptionDiscountAmount {

  amount: MoneyV2!
}


input AppSubscriptionDiscountInput {

  value: AppSubscriptionDiscountValueInput


  durationLimitInIntervals: Int
}


type AppSubscriptionDiscountPercentage {

  percentage: Float!
}


union AppSubscriptionDiscountValue = AppSubscriptionDiscountAmount | AppSubscriptionDiscountPercentage


input AppSubscriptionDiscountValueInput {

  percentage: Float


  amount: Decimal
}


type AppSubscriptionEdge {

  cursor: String!


  node: AppSubscription!
}


type AppSubscriptionLineItem {

  id: ID!


  plan: AppPlanV2!


  usageRecords(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: AppUsageRecordSortKeys = CREATED_AT
  ): AppUsageRecordConnection!
}


input AppSubscriptionLineItemInput {

  plan: AppPlanInput!
}


type AppSubscriptionLineItemUpdatePayload {

  appSubscription: AppSubscription


  confirmationUrl: URL


  userErrors: [UserError!]!
}


enum AppSubscriptionReplacementBehavior {

  APPLY_IMMEDIATELY


  APPLY_ON_NEXT_BILLING_CYCLE


  STANDARD
}


enum AppSubscriptionSortKeys {

  CREATED_AT


  ID


  RELEVANCE
}


enum AppSubscriptionStatus {

  PENDING


  ACCEPTED @deprecated(reason: "As of API version 2021-01, when a merchant approves an app subscription, the status immediately transitions from `pending` to `active`.")


  ACTIVE


  DECLINED


  EXPIRED


  FROZEN


  CANCELLED
}


type AppSubscriptionTrialExtendPayload {

  appSubscription: AppSubscription


  userErrors: [AppSubscriptionTrialExtendUserError!]!
}


type AppSubscriptionTrialExtendUserError implements DisplayableError {

  code: AppSubscriptionTrialExtendUserErrorCode


  field: [String!]


  message: String!
}


enum AppSubscriptionTrialExtendUserErrorCode {

  SUBSCRIPTION_NOT_FOUND


  TRIAL_NOT_ACTIVE


  SUBSCRIPTION_NOT_ACTIVE
}


enum AppTransactionSortKeys {

  CREATED_AT


  ID


  RELEVANCE
}


type AppUsagePricing {

  balanceUsed: MoneyV2!


  cappedAmount: MoneyV2!


  interval: AppPricingInterval!


  terms: String!
}


input AppUsagePricingInput {

  cappedAmount: MoneyInput!


  terms: String!
}


type AppUsageRecord implements Node {

  createdAt: DateTime!


  description: String!


  id: ID!


  idempotencyKey: String


  price: MoneyV2!


  subscriptionLineItem: AppSubscriptionLineItem!
}


type AppUsageRecordConnection {

  edges: [AppUsageRecordEdge!]!


  nodes: [AppUsageRecord!]!


  pageInfo: PageInfo!
}


type AppUsageRecordCreatePayload {

  appUsageRecord: AppUsageRecord


  userErrors: [UserError!]!
}


type AppUsageRecordEdge {

  cursor: String!


  node: AppUsageRecord!
}


enum AppUsageRecordSortKeys {

  CREATED_AT


  ID


  RELEVANCE
}


scalar ARN


type Attribute {

  key: String!


  value: String
}


input AttributeInput {

  key: String!


  value: String!
}


type AutomaticDiscountApplication implements DiscountApplication {

  allocationMethod: DiscountApplicationAllocationMethod!


  index: Int!


  targetSelection: DiscountApplicationTargetSelection!


  targetType: DiscountApplicationTargetType!


  title: String!


  value: PricingValue!
}


enum AutomaticDiscountSortKeys {

  CREATED_AT


  ID


  RELEVANCE
}


type AvailableChannelDefinitionsByChannel {

  channelDefinitions: [ChannelDefinition!]!


  channelName: String!
}


enum BadgeType {

  DEFAULT


  SUCCESS


  ATTENTION


  WARNING


  INFO
}


enum BalanceTransactionSortKeys {

  PAYOUT_DATE


  PAYOUT_STATUS


  PROCESSED_AT


  AMOUNT


  FEE


  NET


  TRANSACTION_TYPE


  ORDER_NAME


  PAYMENT_METHOD_NAME


  ID


  RELEVANCE
}


interface BasePaymentDetails {

  paymentMethodName: String
}


type BasicEvent implements Event & Node {

  appTitle: String


  attributeToApp: Boolean!


  attributeToUser: Boolean!


  createdAt: DateTime!


  criticalAlert: Boolean!


  id: ID!


  message: FormattedString!
}


type BillingAttemptUserError implements DisplayableError {

  code: BillingAttemptUserErrorCode


  field: [String!]


  message: String!
}


enum BillingAttemptUserErrorCode {

  INVALID


  BLANK


  CONTRACT_NOT_FOUND


  ORIGIN_TIME_BEFORE_CONTRACT_CREATION


  UPCOMING_CYCLE_LIMIT_EXCEEDED


  CYCLE_INDEX_OUT_OF_RANGE


  CYCLE_START_DATE_OUT_OF_RANGE


  ORIGIN_TIME_OUT_OF_RANGE


  CONTRACT_UNDER_REVIEW


  CONTRACT_TERMINATED
}


enum BulkMutationErrorCode {

  OPERATION_IN_PROGRESS


  INVALID_MUTATION


  INVALID_STAGED_UPLOAD_FILE


  NO_SUCH_FILE


  INTERNAL_FILE_SERVER_ERROR
}


type BulkMutationUserError implements DisplayableError {

  code: BulkMutationErrorCode


  field: [String!]


  message: String!
}


type BulkOperation implements Node {

  completedAt: DateTime


  createdAt: DateTime!


  errorCode: BulkOperationErrorCode


  fileSize: UnsignedInt64


  id: ID!


  objectCount: UnsignedInt64!


  partialDataUrl: URL


  query: String!


  rootObjectCount: UnsignedInt64!


  status: BulkOperationStatus!


  type: BulkOperationType!


  url: URL
}


type BulkOperationCancelPayload {

  bulkOperation: BulkOperation


  userErrors: [UserError!]!
}


enum BulkOperationErrorCode {

  ACCESS_DENIED


  INTERNAL_SERVER_ERROR


  TIMEOUT
}


type BulkOperationRunMutationPayload {

  bulkOperation: BulkOperation


  userErrors: [BulkMutationUserError!]!
}


type BulkOperationRunQueryPayload {

  bulkOperation: BulkOperation


  userErrors: [UserError!]!
}


enum BulkOperationStatus {

  CANCELED


  CANCELING


  COMPLETED


  CREATED


  EXPIRED


  FAILED


  RUNNING
}


enum BulkOperationType {

  QUERY


  MUTATION
}


type BulkProductResourceFeedbackCreatePayload {

  feedback: [ProductResourceFeedback!]


  userErrors: [BulkProductResourceFeedbackCreateUserError!]!
}


type BulkProductResourceFeedbackCreateUserError implements DisplayableError {

  code: BulkProductResourceFeedbackCreateUserErrorCode


  field: [String!]


  message: String!
}


enum BulkProductResourceFeedbackCreateUserErrorCode {

  MAXIMUM_FEEDBACK_LIMIT_EXCEEDED


  OUTDATED_FEEDBACK


  PRODUCT_NOT_FOUND


  INVALID


  BLANK


  PRESENT


  LESS_THAN_OR_EQUAL_TO
}


type BundlesFeature {

  eligibleForBundles: Boolean!


  ineligibilityReason: String


  sellsBundles: Boolean!
}


enum BusinessCustomerErrorCode {

  INTERNAL_ERROR


  RESOURCE_NOT_FOUND


  FAILED_TO_DELETE


  REQUIRED


  NO_INPUT


  INVALID_INPUT


  UNEXPECTED_TYPE


  TOO_LONG


  LIMIT_REACHED


  INVALID


  BLANK


  TAKEN
}


type BusinessCustomerUserError implements DisplayableError {

  code: BusinessCustomerErrorCode


  field: [String!]


  message: String!
}


type BuyerExperienceConfiguration {

  checkoutToDraft: Boolean!


  editableShippingAddress: Boolean!


  payNowOnly: Boolean!


  paymentTermsTemplate: PaymentTermsTemplate
}


input BuyerExperienceConfigurationInput {

  checkoutToDraft: Boolean


  paymentTermsTemplateId: ID


  editableShippingAddress: Boolean
}


type CalculatedAutomaticDiscountApplication implements CalculatedDiscountApplication {

  allocationMethod: DiscountApplicationAllocationMethod!


  appliedTo: DiscountApplicationLevel!


  description: String


  id: ID!


  targetSelection: DiscountApplicationTargetSelection!


  targetType: DiscountApplicationTargetType!


  value: PricingValue!
}


type CalculatedDiscountAllocation {

  allocatedAmountSet: MoneyBag!


  discountApplication: CalculatedDiscountApplication!
}


interface CalculatedDiscountApplication {

  allocationMethod: DiscountApplicationAllocationMethod!


  appliedTo: DiscountApplicationLevel!


  description: String


  id: ID!


  targetSelection: DiscountApplicationTargetSelection!


  targetType: DiscountApplicationTargetType!


  value: PricingValue!
}


type CalculatedDiscountApplicationConnection {

  edges: [CalculatedDiscountApplicationEdge!]!


  nodes: [CalculatedDiscountApplication!]!


  pageInfo: PageInfo!
}


type CalculatedDiscountApplicationEdge {

  cursor: String!


  node: CalculatedDiscountApplication!
}


type CalculatedDiscountCodeApplication implements CalculatedDiscountApplication {

  allocationMethod: DiscountApplicationAllocationMethod!


  appliedTo: DiscountApplicationLevel!


  code: String!


  description: String


  id: ID!


  targetSelection: DiscountApplicationTargetSelection!


  targetType: DiscountApplicationTargetType!


  value: PricingValue!
}


type CalculatedDraftOrder {

  appliedDiscount: DraftOrderAppliedDiscount


  availableShippingRates: [ShippingRate!]!


  billingAddressMatchesShippingAddress: Boolean!


  currencyCode: CurrencyCode!


  customer: Customer


  lineItems: [CalculatedDraftOrderLineItem!]!


  lineItemsSubtotalPrice: MoneyBag!


  marketName: String!


  marketRegionCountryCode: CountryCode!


  phone: String


  presentmentCurrencyCode: CurrencyCode!


  purchasingEntity: PurchasingEntity


  shippingLine: ShippingLine


  subtotalPrice: Money!


  subtotalPriceSet: MoneyBag!


  taxLines: [TaxLine!]!


  totalDiscountsSet: MoneyBag!


  totalLineItemsPriceSet: MoneyBag!


  totalPrice: Money!


  totalPriceSet: MoneyBag!


  totalShippingPrice: Money!


  totalShippingPriceSet: MoneyBag!


  totalTax: Money!


  totalTaxSet: MoneyBag!
}


type CalculatedDraftOrderLineItem {

  appliedDiscount: DraftOrderAppliedDiscount


  custom: Boolean!


  customAttributes: [Attribute!]!


  customAttributesV2: [TypedAttribute!]!


  discountedTotal: MoneyV2!


  discountedTotalSet: MoneyBag!


  discountedUnitPrice: MoneyV2!


  discountedUnitPriceSet: MoneyBag!


  fulfillmentService: FulfillmentService


  image: Image


  isGiftCard: Boolean!


  name: String!


  originalTotal: MoneyV2!


  originalTotalSet: MoneyBag!


  originalUnitPrice: MoneyV2!


  originalUnitPriceSet: MoneyBag!


  product: Product


  quantity: Int!


  requiresShipping: Boolean!


  sku: String


  taxable: Boolean!


  title: String!


  totalDiscount: MoneyV2!


  totalDiscountSet: MoneyBag!


  variant: ProductVariant


  variantTitle: String


  vendor: String


  weight: Weight
}


type CalculatedLineItem {

  calculatedDiscountAllocations: [CalculatedDiscountAllocation!]!


  customAttributes: [Attribute!]!


  discountAllocations: [DiscountAllocation!]! @deprecated(reason: "Use `calculatedDiscountAllocations` instead.")


  discountedUnitPriceSet: MoneyBag!


  editableQuantity: Int!


  editableQuantityBeforeChanges: Int!


  editableSubtotalSet: MoneyBag!


  hasStagedLineItemDiscount: Boolean!


  id: ID!


  image: Image


  originalUnitPriceSet: MoneyBag!


  quantity: Int!


  restockable: Boolean!


  restocking: Boolean!


  sku: String


  stagedChanges: [OrderStagedChange!]!


  title: String!


  uneditableSubtotalSet: MoneyBag!


  variant: ProductVariant


  variantTitle: String
}


type CalculatedLineItemConnection {

  edges: [CalculatedLineItemEdge!]!


  nodes: [CalculatedLineItem!]!


  pageInfo: PageInfo!
}


type CalculatedLineItemEdge {

  cursor: String!


  node: CalculatedLineItem!
}


type CalculatedManualDiscountApplication implements CalculatedDiscountApplication {

  allocationMethod: DiscountApplicationAllocationMethod!


  appliedTo: DiscountApplicationLevel!


  description: String


  id: ID!


  targetSelection: DiscountApplicationTargetSelection!


  targetType: DiscountApplicationTargetType!


  value: PricingValue!
}


type CalculatedOrder implements Node {

  addedDiscountApplications(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): CalculatedDiscountApplicationConnection!


  addedLineItems(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): CalculatedLineItemConnection!


  cartDiscountAmountSet: MoneyBag


  committed: Boolean!


  id: ID!


  lineItems(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    query: String
  ): CalculatedLineItemConnection!


  notificationPreviewHtml: HTML


  notificationPreviewTitle: String!


  order: Order! @deprecated(reason: "Use `originalOrder` instead.")


  originalOrder: Order!


  stagedChanges(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): OrderStagedChangeConnection!


  subtotalLineItemsQuantity: Int!


  subtotalPriceSet: MoneyBag


  taxLines: [TaxLine!]!


  totalOutstandingSet: MoneyBag!


  totalPriceSet: MoneyBag!
}


type CalculatedScriptDiscountApplication implements CalculatedDiscountApplication {

  allocationMethod: DiscountApplicationAllocationMethod!


  appliedTo: DiscountApplicationLevel!


  description: String


  id: ID!


  targetSelection: DiscountApplicationTargetSelection!


  targetType: DiscountApplicationTargetType!


  value: PricingValue!
}


type CardPaymentDetails implements BasePaymentDetails {

  avsResultCode: String


  bin: String


  company: String


  cvvResultCode: String


  expirationMonth: Int


  expirationYear: Int


  name: String


  number: String


  paymentMethodName: String


  wallet: DigitalWallet
}


type CartTransform implements HasMetafields & Node {

  blockOnFailure: Boolean!


  functionId: String!


  id: ID!


  metafield(

    namespace: String


    key: String!
  ): Metafield


  metafields(

    namespace: String


    keys: [String!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  privateMetafield(

    namespace: String!


    key: String!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")
}


type CartTransformConnection {

  edges: [CartTransformEdge!]!


  nodes: [CartTransform!]!


  pageInfo: PageInfo!
}


type CartTransformCreatePayload {

  cartTransform: CartTransform


  userErrors: [CartTransformCreateUserError!]!
}


type CartTransformCreateUserError implements DisplayableError {

  code: CartTransformCreateUserErrorCode


  field: [String!]


  message: String!
}


enum CartTransformCreateUserErrorCode {

  INPUT_INVALID


  FUNCTION_NOT_FOUND


  FUNCTION_ALREADY_REGISTERED


  FUNCTION_DOES_NOT_IMPLEMENT
}


type CartTransformDeletePayload {

  deletedId: ID


  userErrors: [CartTransformDeleteUserError!]!
}


type CartTransformDeleteUserError implements DisplayableError {

  code: CartTransformDeleteUserErrorCode


  field: [String!]


  message: String!
}


enum CartTransformDeleteUserErrorCode {

  NOT_FOUND


  UNAUTHORIZED_APP_SCOPE
}


type CartTransformEdge {

  cursor: String!


  node: CartTransform!
}


type CartTransformEligibleOperations {

  expandOperation: Boolean!


  mergeOperation: Boolean!


  updateOperation: Boolean!
}


type CartTransformFeature {

  eligibleOperations: CartTransformEligibleOperations!
}


interface Catalog {

  id: ID!


  operations: [ResourceOperation!]!


  priceList: PriceList


  publication: Publication


  status: CatalogStatus!


  title: String!
}


type CatalogConnection {

  edges: [CatalogEdge!]!


  nodes: [Catalog!]!


  pageInfo: PageInfo!


  totalCount: UnsignedInt64!
}


input CatalogContextInput {

  companyLocationIds: [ID!]
}


type CatalogContextUpdatePayload {

  catalog: Catalog


  userErrors: [CatalogUserError!]!
}


input CatalogCreateInput {

  title: String!


  status: CatalogStatus!


  context: CatalogContextInput!


  priceListId: ID


  publicationId: ID
}


type CatalogCreatePayload {

  catalog: Catalog


  userErrors: [CatalogUserError!]!
}


type CatalogCsvOperation implements Node & ResourceOperation {

  id: ID!


  processedRowCount: Int


  rowCount: RowCount


  status: ResourceOperationStatus!
}


type CatalogDeletePayload {

  deletedId: ID


  userErrors: [CatalogUserError!]!
}


type CatalogEdge {

  cursor: String!


  node: Catalog!
}


enum CatalogSortKeys {

  TITLE


  ID


  RELEVANCE
}


enum CatalogStatus {

  ACTIVE


  ARCHIVED


  DRAFT
}


enum CatalogType {

  NONE


  APP


  COMPANY_LOCATION


  MARKET
}


input CatalogUpdateInput {

  title: String


  status: CatalogStatus


  context: CatalogContextInput


  priceListId: ID


  publicationId: ID
}


type CatalogUpdatePayload {

  catalog: Catalog


  userErrors: [CatalogUserError!]!
}


type CatalogUserError implements DisplayableError {

  code: CatalogUserErrorCode


  field: [String!]


  message: String!
}


enum CatalogUserErrorCode {

  APP_CATALOG_PRICE_LIST_ASSIGNMENT


  CATALOG_FAILED_TO_SAVE


  CATALOG_NOT_FOUND


  PRICE_LIST_NOT_ALLOWED_FOR_PRIMARY_MARKET


  CATALOG_CONTEXT_DOES_NOT_SUPPORT_QUANTITY_RULES


  CATALOG_CONTEXT_DOES_NOT_SUPPORT_QUANTITY_PRICE_BREAKS


  CANNOT_ADD_MORE_THAN_ONE_MARKET


  COMPANY_LOCATION_CATALOG_STATUS_PLAN


  CONTEXT_ALREADY_ASSIGNED_TO_CATALOG


  CONTEXT_CATALOG_LIMIT_REACHED


  COMPANY_LOCATION_NOT_FOUND


  CONTEXT_DRIVER_MISMATCH


  COUNTRY_PRICE_LIST_ASSIGNMENT


  INVALID_CATALOG_CONTEXT_TYPE


  MARKET_CATALOG_STATUS


  MARKET_NOT_FOUND


  MARKET_AND_PRICE_LIST_CURRENCY_MISMATCH


  MARKET_TAKEN


  MUST_PROVIDE_EXACTLY_ONE_CONTEXT_TYPE


  PRICE_LIST_FAILED_TO_SAVE


  PRICE_LIST_NOT_FOUND


  PRICE_LIST_LOCKED


  PUBLICATION_NOT_FOUND


  REQUIRES_CONTEXTS_TO_ADD_OR_REMOVE


  UNSUPPORTED_CATALOG_ACTION


  CANNOT_CREATE_APP_CATALOG


  CANNOT_MODIFY_APP_CATALOG


  CANNOT_DELETE_APP_CATALOG


  CANNOT_CREATE_MARKET_CATALOG


  CANNOT_MODIFY_MARKET_CATALOG


  CANNOT_DELETE_MARKET_CATALOG


  INVALID


  TAKEN


  TOO_LONG


  TOO_SHORT


  BLANK
}


type Channel implements Node {

  app: App!


  collectionPublicationsV3(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ResourcePublicationConnection!


  collections(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): CollectionConnection!


  handle: String! @deprecated(reason: "Use `id` instead.")


  hasCollection(

    id: ID!
  ): Boolean!


  id: ID!


  name: String!


  navigationItems: [NavigationItem!]! @deprecated(reason: "Use [AppInstallation.navigationItems](\n          https://shopify.dev/api/admin-graphql/current/objects/AppInstallation#field-appinstallation-navigationitems) instead.")


  overviewPath: URL @deprecated(reason: "Use [AppInstallation.launchUrl](\n          https://shopify.dev/api/admin-graphql/current/objects/AppInstallation#field-appinstallation-launchurl) instead.")


  productPublications(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ProductPublicationConnection! @deprecated(reason: "Use `productPublicationsV3` instead.")


  productPublicationsV3(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ResourcePublicationConnection!


  products(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ProductConnection!


  supportsFuturePublishing: Boolean!
}


type ChannelConnection {

  edges: [ChannelEdge!]!


  nodes: [Channel!]!


  pageInfo: PageInfo!
}


type ChannelDefinition implements Node {

  channelName: String!


  handle: String!


  id: ID!


  isMarketplace: Boolean!


  subChannelName: String!


  svgIcon: String
}


type ChannelEdge {

  cursor: String!


  node: Channel!
}


type ChannelInformation implements Node {

  app: App!


  channelDefinition: ChannelDefinition


  channelId: ID!


  id: ID!
}


type CheckoutBranding {

  customizations: CheckoutBrandingCustomizations


  designSystem: CheckoutBrandingDesignSystem
}


enum CheckoutBrandingBackgroundStyle {

  SOLID


  NONE
}


enum CheckoutBrandingBorder {

  NONE


  BLOCK_END


  FULL
}


type CheckoutBrandingButton {

  background: CheckoutBrandingBackgroundStyle


  blockPadding: CheckoutBrandingSpacing


  border: CheckoutBrandingSimpleBorder


  cornerRadius: CheckoutBrandingCornerRadius


  inlinePadding: CheckoutBrandingSpacing


  typography: CheckoutBrandingTypographyStyle
}


type CheckoutBrandingButtonColorRoles {

  accent: String


  background: String


  border: String


  decorative: String


  hover: CheckoutBrandingColorRoles


  icon: String


  text: String
}


input CheckoutBrandingButtonColorRolesInput {

  background: String


  text: String


  border: String


  icon: String


  accent: String


  decorative: String


  hover: CheckoutBrandingColorRolesInput
}


input CheckoutBrandingButtonInput {

  background: CheckoutBrandingBackgroundStyle


  border: CheckoutBrandingSimpleBorder


  cornerRadius: CheckoutBrandingCornerRadius


  blockPadding: CheckoutBrandingSpacing


  inlinePadding: CheckoutBrandingSpacing


  typography: CheckoutBrandingTypographyStyleInput
}


type CheckoutBrandingCheckbox {

  cornerRadius: CheckoutBrandingCornerRadius
}


input CheckoutBrandingCheckboxInput {

  cornerRadius: CheckoutBrandingCornerRadius
}


type CheckoutBrandingChoiceList {

  group: CheckoutBrandingChoiceListGroup
}


type CheckoutBrandingChoiceListGroup {

  spacing: CheckoutBrandingSpacingKeyword
}


input CheckoutBrandingChoiceListGroupInput {

  spacing: CheckoutBrandingSpacingKeyword
}


input CheckoutBrandingChoiceListInput {

  group: CheckoutBrandingChoiceListGroupInput
}


type CheckoutBrandingColorGlobal {

  accent: String


  brand: String


  critical: String


  decorative: String


  info: String


  success: String


  warning: String
}


input CheckoutBrandingColorGlobalInput {

  info: String


  success: String


  warning: String


  critical: String


  brand: String


  accent: String


  decorative: String
}


type CheckoutBrandingColorRoles {

  accent: String


  background: String


  border: String


  decorative: String


  icon: String


  text: String
}


input CheckoutBrandingColorRolesInput {

  background: String


  text: String


  border: String


  icon: String


  accent: String


  decorative: String
}


type CheckoutBrandingColors {

  global: CheckoutBrandingColorGlobal


  schemes: CheckoutBrandingColorSchemes
}


type CheckoutBrandingColorScheme {

  base: CheckoutBrandingColorRoles


  control: CheckoutBrandingControlColorRoles


  primaryButton: CheckoutBrandingButtonColorRoles


  secondaryButton: CheckoutBrandingButtonColorRoles
}


input CheckoutBrandingColorSchemeInput {

  base: CheckoutBrandingColorRolesInput


  control: CheckoutBrandingControlColorRolesInput


  primaryButton: CheckoutBrandingButtonColorRolesInput


  secondaryButton: CheckoutBrandingButtonColorRolesInput
}


type CheckoutBrandingColorSchemes {

  scheme1: CheckoutBrandingColorScheme


  scheme2: CheckoutBrandingColorScheme
}


enum CheckoutBrandingColorSchemeSelection {

  TRANSPARENT


  COLOR_SCHEME1


  COLOR_SCHEME2
}


input CheckoutBrandingColorSchemesInput {

  scheme1: CheckoutBrandingColorSchemeInput


  scheme2: CheckoutBrandingColorSchemeInput
}


enum CheckoutBrandingColorSelection {

  TRANSPARENT
}


input CheckoutBrandingColorsInput {

  global: CheckoutBrandingColorGlobalInput


  schemes: CheckoutBrandingColorSchemesInput
}


type CheckoutBrandingControl {

  border: CheckoutBrandingSimpleBorder


  color: CheckoutBrandingColorSelection


  cornerRadius: CheckoutBrandingCornerRadius


  labelPosition: CheckoutBrandingLabelPosition
}


type CheckoutBrandingControlColorRoles {

  accent: String


  background: String


  border: String


  decorative: String


  icon: String


  selected: CheckoutBrandingColorRoles


  text: String
}


input CheckoutBrandingControlColorRolesInput {

  background: String


  text: String


  border: String


  icon: String


  accent: String


  decorative: String


  selected: CheckoutBrandingColorRolesInput
}


input CheckoutBrandingControlInput {

  color: CheckoutBrandingColorSelection


  cornerRadius: CheckoutBrandingCornerRadius


  border: CheckoutBrandingSimpleBorder


  labelPosition: CheckoutBrandingLabelPosition
}


enum CheckoutBrandingCornerRadius {

  NONE


  SMALL


  BASE


  LARGE
}


type CheckoutBrandingCornerRadiusVariables {

  base: Int


  large: Int


  small: Int
}


input CheckoutBrandingCornerRadiusVariablesInput {

  small: Int


  base: Int


  large: Int
}


type CheckoutBrandingCustomFont implements CheckoutBrandingFont {

  genericFileId: ID


  sources: String


  weight: Int
}


input CheckoutBrandingCustomFontGroupInput {

  base: CheckoutBrandingCustomFontInput!


  bold: CheckoutBrandingCustomFontInput!


  loadingStrategy: CheckoutBrandingFontLoadingStrategy
}


input CheckoutBrandingCustomFontInput {

  weight: Int!


  genericFileId: ID!
}


type CheckoutBrandingCustomizations {

  checkbox: CheckoutBrandingCheckbox


  choiceList: CheckoutBrandingChoiceList


  control: CheckoutBrandingControl


  favicon: CheckoutBrandingImage


  global: CheckoutBrandingGlobal


  header: CheckoutBrandingHeader


  headingLevel1: CheckoutBrandingHeadingLevel


  headingLevel2: CheckoutBrandingHeadingLevel


  headingLevel3: CheckoutBrandingHeadingLevel


  main: CheckoutBrandingMain


  merchandiseThumbnail: CheckoutBrandingMerchandiseThumbnail


  orderSummary: CheckoutBrandingOrderSummary


  primaryButton: CheckoutBrandingButton


  secondaryButton: CheckoutBrandingButton


  select: CheckoutBrandingSelect


  textField: CheckoutBrandingTextField
}


input CheckoutBrandingCustomizationsInput {

  global: CheckoutBrandingGlobalInput


  header: CheckoutBrandingHeaderInput


  headingLevel1: CheckoutBrandingHeadingLevelInput


  headingLevel2: CheckoutBrandingHeadingLevelInput


  headingLevel3: CheckoutBrandingHeadingLevelInput


  main: CheckoutBrandingMainInput


  orderSummary: CheckoutBrandingOrderSummaryInput


  control: CheckoutBrandingControlInput


  textField: CheckoutBrandingTextFieldInput


  checkbox: CheckoutBrandingCheckboxInput


  select: CheckoutBrandingSelectInput


  primaryButton: CheckoutBrandingButtonInput


  secondaryButton: CheckoutBrandingButtonInput


  favicon: CheckoutBrandingImageInput


  choiceList: CheckoutBrandingChoiceListInput


  merchandiseThumbnail: CheckoutBrandingMerchandiseThumbnailInput
}


type CheckoutBrandingDesignSystem {

  colors: CheckoutBrandingColors


  cornerRadius: CheckoutBrandingCornerRadiusVariables


  typography: CheckoutBrandingTypography
}


input CheckoutBrandingDesignSystemInput {

  colors: CheckoutBrandingColorsInput


  typography: CheckoutBrandingTypographyInput


  cornerRadius: CheckoutBrandingCornerRadiusVariablesInput
}


interface CheckoutBrandingFont {

  sources: String


  weight: Int
}


type CheckoutBrandingFontGroup {

  base: CheckoutBrandingFont


  bold: CheckoutBrandingFont


  loadingStrategy: CheckoutBrandingFontLoadingStrategy


  name: String
}


input CheckoutBrandingFontGroupInput {

  shopifyFontGroup: CheckoutBrandingShopifyFontGroupInput


  customFontGroup: CheckoutBrandingCustomFontGroupInput
}


enum CheckoutBrandingFontLoadingStrategy {

  AUTO


  BLOCK


  SWAP


  FALLBACK


  OPTIONAL
}


type CheckoutBrandingFontSize {

  base: Float


  ratio: Float
}


input CheckoutBrandingFontSizeInput {

  base: Float


  ratio: Float
}


type CheckoutBrandingGlobal {

  cornerRadius: CheckoutBrandingGlobalCornerRadius


  typography: CheckoutBrandingTypographyStyleGlobal
}


enum CheckoutBrandingGlobalCornerRadius {

  NONE
}


input CheckoutBrandingGlobalInput {

  cornerRadius: CheckoutBrandingGlobalCornerRadius


  typography: CheckoutBrandingTypographyStyleGlobalInput
}


type CheckoutBrandingHeader {

  alignment: CheckoutBrandingHeaderAlignment


  banner: CheckoutBrandingImage


  logo: CheckoutBrandingLogo


  position: CheckoutBrandingHeaderPosition
}


enum CheckoutBrandingHeaderAlignment {

  START


  CENTER


  END
}


input CheckoutBrandingHeaderInput {

  alignment: CheckoutBrandingHeaderAlignment


  position: CheckoutBrandingHeaderPosition


  logo: CheckoutBrandingLogoInput


  banner: CheckoutBrandingImageInput
}


enum CheckoutBrandingHeaderPosition {

  INLINE


  INLINE_SECONDARY


  START
}


type CheckoutBrandingHeadingLevel {

  typography: CheckoutBrandingTypographyStyle
}


input CheckoutBrandingHeadingLevelInput {

  typography: CheckoutBrandingTypographyStyleInput
}


type CheckoutBrandingImage {

  image: Image
}


input CheckoutBrandingImageInput {

  mediaImageId: ID
}


input CheckoutBrandingInput {

  designSystem: CheckoutBrandingDesignSystemInput


  customizations: CheckoutBrandingCustomizationsInput
}


enum CheckoutBrandingLabelPosition {

  INSIDE


  OUTSIDE
}


type CheckoutBrandingLogo {

  image: Image


  maxWidth: Int
}


input CheckoutBrandingLogoInput {

  image: CheckoutBrandingImageInput


  maxWidth: Int
}


type CheckoutBrandingMain {

  backgroundImage: CheckoutBrandingImage


  colorScheme: CheckoutBrandingColorSchemeSelection
}


input CheckoutBrandingMainInput {

  colorScheme: CheckoutBrandingColorSchemeSelection


  backgroundImage: CheckoutBrandingImageInput
}


type CheckoutBrandingMerchandiseThumbnail {

  border: CheckoutBrandingSimpleBorder


  cornerRadius: CheckoutBrandingCornerRadius
}


input CheckoutBrandingMerchandiseThumbnailInput {

  border: CheckoutBrandingSimpleBorder


  cornerRadius: CheckoutBrandingCornerRadius
}


type CheckoutBrandingOrderSummary {

  backgroundImage: CheckoutBrandingImage


  colorScheme: CheckoutBrandingColorSchemeSelection
}


input CheckoutBrandingOrderSummaryInput {

  colorScheme: CheckoutBrandingColorSchemeSelection


  backgroundImage: CheckoutBrandingImageInput
}


type CheckoutBrandingSelect {

  border: CheckoutBrandingBorder


  typography: CheckoutBrandingTypographyStyle
}


input CheckoutBrandingSelectInput {

  border: CheckoutBrandingBorder


  typography: CheckoutBrandingTypographyStyleInput
}


type CheckoutBrandingShopifyFont implements CheckoutBrandingFont {

  sources: String


  weight: Int
}


input CheckoutBrandingShopifyFontGroupInput {

  name: String!


  baseWeight: Int


  boldWeight: Int


  loadingStrategy: CheckoutBrandingFontLoadingStrategy
}


enum CheckoutBrandingSimpleBorder {

  NONE


  FULL
}


enum CheckoutBrandingSpacing {

  NONE


  EXTRA_TIGHT


  TIGHT


  BASE


  LOOSE


  EXTRA_LOOSE
}


enum CheckoutBrandingSpacingKeyword {

  NONE


  BASE


  SMALL


  SMALL_100


  SMALL_200


  SMALL_300


  SMALL_400


  SMALL_500


  LARGE


  LARGE_100


  LARGE_200


  LARGE_300


  LARGE_400


  LARGE_500
}


type CheckoutBrandingTextField {

  border: CheckoutBrandingBorder


  typography: CheckoutBrandingTypographyStyle
}


input CheckoutBrandingTextFieldInput {

  border: CheckoutBrandingBorder


  typography: CheckoutBrandingTypographyStyleInput
}


type CheckoutBrandingTypography {

  primary: CheckoutBrandingFontGroup


  secondary: CheckoutBrandingFontGroup


  size: CheckoutBrandingFontSize
}


enum CheckoutBrandingTypographyFont {

  PRIMARY


  SECONDARY
}


input CheckoutBrandingTypographyInput {

  size: CheckoutBrandingFontSizeInput


  primary: CheckoutBrandingFontGroupInput


  secondary: CheckoutBrandingFontGroupInput
}


enum CheckoutBrandingTypographyKerning {

  BASE


  LOOSE


  EXTRA_LOOSE
}


enum CheckoutBrandingTypographyLetterCase {

  LOWER


  NONE


  TITLE


  UPPER
}


enum CheckoutBrandingTypographySize {

  EXTRA_SMALL


  SMALL


  BASE


  MEDIUM


  LARGE


  EXTRA_LARGE


  EXTRA_EXTRA_LARGE
}


type CheckoutBrandingTypographyStyle {

  font: CheckoutBrandingTypographyFont


  kerning: CheckoutBrandingTypographyKerning


  letterCase: CheckoutBrandingTypographyLetterCase


  size: CheckoutBrandingTypographySize


  weight: CheckoutBrandingTypographyWeight
}


type CheckoutBrandingTypographyStyleGlobal {

  kerning: CheckoutBrandingTypographyKerning


  letterCase: CheckoutBrandingTypographyLetterCase
}


input CheckoutBrandingTypographyStyleGlobalInput {

  letterCase: CheckoutBrandingTypographyLetterCase


  kerning: CheckoutBrandingTypographyKerning
}


input CheckoutBrandingTypographyStyleInput {

  font: CheckoutBrandingTypographyFont


  size: CheckoutBrandingTypographySize


  weight: CheckoutBrandingTypographyWeight


  letterCase: CheckoutBrandingTypographyLetterCase


  kerning: CheckoutBrandingTypographyKerning
}


enum CheckoutBrandingTypographyWeight {

  BASE


  BOLD
}


type CheckoutBrandingUpsertPayload {

  checkoutBranding: CheckoutBranding


  userErrors: [CheckoutBrandingUpsertUserError!]!
}


type CheckoutBrandingUpsertUserError implements DisplayableError {

  code: CheckoutBrandingUpsertUserErrorCode


  field: [String!]


  message: String!
}


enum CheckoutBrandingUpsertUserErrorCode {

  INTERNAL_ERROR
}


type CheckoutProfile implements Node {

  createdAt: DateTime!


  editedAt: DateTime!


  id: ID!


  isPublished: Boolean!


  name: String!


  updatedAt: DateTime!
}


type CheckoutProfileConnection {

  edges: [CheckoutProfileEdge!]!


  nodes: [CheckoutProfile!]!


  pageInfo: PageInfo!
}


type CheckoutProfileEdge {

  cursor: String!


  node: CheckoutProfile!
}


enum CheckoutProfileSortKeys {

  CREATED_AT


  UPDATED_AT


  EDITED_AT


  IS_PUBLISHED


  ID


  RELEVANCE
}


enum CodeDiscountSortKeys {

  STARTS_AT


  ENDS_AT


  TITLE


  CREATED_AT


  UPDATED_AT


  ID


  RELEVANCE
}


type Collection implements HasMetafieldDefinitions & HasMetafields & HasPublishedTranslations & Node & Publishable {

  availablePublicationCount: Int!


  description(

    truncateAt: Int
  ): String!


  descriptionHtml: HTML!


  feedback: ResourceFeedback


  handle: String!


  hasProduct(

    id: ID!
  ): Boolean!


  id: ID!


  image: Image


  legacyResourceId: UnsignedInt64!


  metafield(

    namespace: String


    key: String!
  ): Metafield


  metafieldDefinitions(

    namespace: String


    pinnedStatus: MetafieldDefinitionPinnedStatus = ANY


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: MetafieldDefinitionSortKeys = ID


    query: String
  ): MetafieldDefinitionConnection!


  metafields(

    namespace: String


    keys: [String!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  privateMetafield(

    namespace: String!


    key: String!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  products(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: ProductCollectionSortKeys = COLLECTION_DEFAULT
  ): ProductConnection!


  productsCount: Int!


  publicationCount(

    onlyPublished: Boolean = true
  ): Int!


  publications(

    onlyPublished: Boolean = true


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): CollectionPublicationConnection! @deprecated(reason: "Use `resourcePublications` instead.")


  publishedOnChannel(

    channelId: ID!
  ): Boolean! @deprecated(reason: "Use `publishedOnPublication` instead.")


  publishedOnCurrentChannel: Boolean! @deprecated(reason: "Use `publishedOnCurrentPublication` instead.")


  publishedOnCurrentPublication: Boolean!


  publishedOnPublication(

    publicationId: ID!
  ): Boolean!


  resourcePublications(

    onlyPublished: Boolean = true


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ResourcePublicationConnection!


  resourcePublicationsV2(

    onlyPublished: Boolean = true


    catalogType: CatalogType


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ResourcePublicationV2Connection!


  ruleSet: CollectionRuleSet


  seo: SEO!


  sortOrder: CollectionSortOrder!


  storefrontId: StorefrontID! @deprecated(reason: "Use `id` instead.")


  templateSuffix: String


  title: String!


  translations(

    locale: String!


    marketId: ID
  ): [Translation!]!


  unpublishedChannels(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ChannelConnection! @deprecated(reason: "Use `unpublishedPublications` instead.")


  unpublishedPublications(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PublicationConnection!


  updatedAt: DateTime!
}


type CollectionAddProductsPayload {

  collection: Collection


  userErrors: [UserError!]!
}


type CollectionAddProductsV2Payload {

  job: Job


  userErrors: [CollectionAddProductsV2UserError!]!
}


type CollectionAddProductsV2UserError implements DisplayableError {

  code: CollectionAddProductsV2UserErrorCode


  field: [String!]


  message: String!
}


enum CollectionAddProductsV2UserErrorCode {

  CANT_ADD_TO_SMART_COLLECTION


  COLLECTION_DOES_NOT_EXIST
}


type CollectionConnection {

  edges: [CollectionEdge!]!


  nodes: [Collection!]!


  pageInfo: PageInfo!
}


type CollectionCreatePayload {

  collection: Collection


  userErrors: [UserError!]!
}


input CollectionDeleteInput {

  id: ID!
}


type CollectionDeletePayload {

  deletedCollectionId: ID


  shop: Shop!


  userErrors: [UserError!]!
}


type CollectionEdge {

  cursor: String!


  node: Collection!
}


input CollectionInput {

  descriptionHtml: String


  handle: String


  id: ID


  image: ImageInput


  products: [ID!]


  ruleSet: CollectionRuleSetInput


  templateSuffix: String


  sortOrder: CollectionSortOrder


  title: String


  metafields: [MetafieldInput!]


  seo: SEOInput


  redirectNewHandle: Boolean = false
}


type CollectionPublication {

  channel: Channel! @deprecated(reason: "Use `publication` instead.")


  collection: Collection!


  isPublished: Boolean!


  publication: Publication!


  publishDate: DateTime!
}


type CollectionPublicationConnection {

  edges: [CollectionPublicationEdge!]!


  nodes: [CollectionPublication!]!


  pageInfo: PageInfo!
}


type CollectionPublicationEdge {

  cursor: String!


  node: CollectionPublication!
}


input CollectionPublicationInput {

  publicationId: ID
}


input CollectionPublishInput {

  id: ID!


  collectionPublications: [CollectionPublicationInput!]!
}


type CollectionPublishPayload {

  collection: Collection


  collectionPublications: [CollectionPublication!]


  shop: Shop!


  userErrors: [UserError!]!
}


type CollectionRemoveProductsPayload {

  job: Job


  userErrors: [UserError!]!
}


type CollectionReorderProductsPayload {

  job: Job


  userErrors: [UserError!]!
}


type CollectionRule {

  column: CollectionRuleColumn!


  condition: String!


  conditionObject: CollectionRuleConditionObject


  relation: CollectionRuleRelation!
}


enum CollectionRuleColumn {

  TAG


  TITLE


  TYPE


  PRODUCT_TAXONOMY_NODE_ID


  VENDOR


  VARIANT_PRICE


  IS_PRICE_REDUCED


  VARIANT_COMPARE_AT_PRICE


  VARIANT_WEIGHT


  VARIANT_INVENTORY


  VARIANT_TITLE


  PRODUCT_METAFIELD_DEFINITION


  VARIANT_METAFIELD_DEFINITION
}


union CollectionRuleConditionObject = CollectionRuleMetafieldCondition | CollectionRuleProductCategoryCondition | CollectionRuleTextCondition


type CollectionRuleConditions {

  allowedRelations: [CollectionRuleRelation!]!


  defaultRelation: CollectionRuleRelation!


  ruleObject: CollectionRuleConditionsRuleObject


  ruleType: CollectionRuleColumn!
}


union CollectionRuleConditionsRuleObject = CollectionRuleMetafieldCondition


input CollectionRuleInput {

  column: CollectionRuleColumn!


  relation: CollectionRuleRelation!


  condition: String!


  conditionObjectId: ID
}


type CollectionRuleMetafieldCondition {

  metafieldDefinition: MetafieldDefinition!
}


type CollectionRuleProductCategoryCondition {

  value: ProductTaxonomyNode!
}


enum CollectionRuleRelation {

  CONTAINS


  ENDS_WITH


  EQUALS


  GREATER_THAN


  IS_NOT_SET


  IS_SET


  LESS_THAN


  NOT_CONTAINS


  NOT_EQUALS


  STARTS_WITH
}


type CollectionRuleSet {

  appliedDisjunctively: Boolean!


  rules: [CollectionRule!]!
}


input CollectionRuleSetInput {

  appliedDisjunctively: Boolean!


  rules: [CollectionRuleInput!]
}


type CollectionRuleTextCondition {

  value: String!
}


enum CollectionSortKeys {

  TITLE


  UPDATED_AT


  ID


  RELEVANCE
}


enum CollectionSortOrder {

  ALPHA_ASC


  ALPHA_DESC


  BEST_SELLING


  CREATED


  CREATED_DESC


  MANUAL


  PRICE_ASC


  PRICE_DESC
}


input CollectionUnpublishInput {

  id: ID!


  collectionPublications: [CollectionPublicationInput!]!
}


type CollectionUnpublishPayload {

  collection: Collection


  shop: Shop!


  userErrors: [UserError!]!
}


type CollectionUpdatePayload {

  collection: Collection


  job: Job


  userErrors: [UserError!]!
}


type CommentEvent implements Event & Node {

  appTitle: String


  attachments: [CommentEventAttachment!]!


  attributeToApp: Boolean!


  attributeToUser: Boolean!


  author: StaffMember!


  canDelete: Boolean!


  canEdit: Boolean!


  createdAt: DateTime!


  criticalAlert: Boolean!


  edited: Boolean!


  embed: CommentEventEmbed


  id: ID!


  message: FormattedString!


  rawMessage: String!


  subject: CommentEventSubject!
}


type CommentEventAttachment {

  fileExtension: String


  id: ID!


  image: Image


  name: String!


  size: Int!


  url: URL!
}


union CommentEventEmbed = Customer | DraftOrder | Order | Product | ProductVariant


interface CommentEventSubject {

  hasTimelineComment: Boolean!


  id: ID!
}


type CompaniesDeletePayload {

  deletedCompanyIds: [ID!]


  userErrors: [BusinessCustomerUserError!]!
}


type Company implements CommentEventSubject & HasEvents & HasMetafieldDefinitions & HasMetafields & Navigable & Node {

  contactCount: Int!


  contactRoles(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: CompanyContactRoleSortKeys = ID
  ): CompanyContactRoleConnection!


  contacts(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: CompanyContactSortKeys = ID


    query: String
  ): CompanyContactConnection!


  createdAt: DateTime!


  customerSince: DateTime!


  defaultCursor: String!


  defaultRole: CompanyContactRole


  draftOrders(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: DraftOrderSortKeys = ID


    query: String
  ): DraftOrderConnection!


  events(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: EventSortKeys = ID


    query: String
  ): EventConnection!


  externalId: String


  hasTimelineComment: Boolean!


  id: ID!


  lifetimeDuration: String!


  locationCount: Int!


  locations(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: CompanyLocationSortKeys = ID


    query: String
  ): CompanyLocationConnection!


  mainContact: CompanyContact


  metafield(

    namespace: String


    key: String!
  ): Metafield


  metafieldDefinitions(

    namespace: String


    pinnedStatus: MetafieldDefinitionPinnedStatus = ANY


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: MetafieldDefinitionSortKeys = ID


    query: String
  ): MetafieldDefinitionConnection!


  metafields(

    namespace: String


    keys: [String!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  name: String!


  note: String


  orderCount: Int!


  orders(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: OrderSortKeys = ID
  ): OrderConnection!


  privateMetafield(

    namespace: String!


    key: String!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  totalSpent: MoneyV2!


  updatedAt: DateTime!
}


type CompanyAddress implements Node {

  address1: String!


  address2: String


  city: String


  companyName: String!


  country: String


  countryCode: CountryCode!


  createdAt: DateTime!


  firstName: String


  formattedAddress(

    withName: Boolean = false


    withCompanyName: Boolean = true
  ): [String!]!


  formattedArea: String


  id: ID!


  lastName: String


  phone: String


  province: String


  recipient: String


  updatedAt: DateTime!


  zip: String


  zoneCode: String
}


type CompanyAddressDeletePayload {

  deletedAddressId: ID


  userErrors: [BusinessCustomerUserError!]!
}


input CompanyAddressInput {

  address1: String


  address2: String


  city: String


  zip: String


  recipient: String


  firstName: String


  lastName: String


  phone: String


  zoneCode: String


  countryCode: CountryCode
}


enum CompanyAddressType {

  BILLING


  SHIPPING
}


type CompanyAssignCustomerAsContactPayload {

  companyContact: CompanyContact


  userErrors: [BusinessCustomerUserError!]!
}


type CompanyAssignMainContactPayload {

  company: Company


  userErrors: [BusinessCustomerUserError!]!
}


type CompanyConnection {

  edges: [CompanyEdge!]!


  nodes: [Company!]!


  pageInfo: PageInfo!
}


type CompanyContact implements Node {

  company: Company!


  createdAt: DateTime!


  customer: Customer!


  draftOrders(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: DraftOrderSortKeys = ID


    query: String
  ): DraftOrderConnection!


  id: ID!


  isMainContact: Boolean!


  lifetimeDuration: String!


  locale: String


  orders(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: OrderSortKeys = ID
  ): OrderConnection!


  roleAssignments(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: CompanyContactRoleAssignmentSortKeys = ID


    query: String
  ): CompanyContactRoleAssignmentConnection!


  title: String


  updatedAt: DateTime!
}


type CompanyContactAssignRolePayload {

  companyContactRoleAssignment: CompanyContactRoleAssignment


  userErrors: [BusinessCustomerUserError!]!
}


type CompanyContactAssignRolesPayload {

  roleAssignments: [CompanyContactRoleAssignment!]


  userErrors: [BusinessCustomerUserError!]!
}


type CompanyContactConnection {

  edges: [CompanyContactEdge!]!


  nodes: [CompanyContact!]!


  pageInfo: PageInfo!
}


type CompanyContactCreatePayload {

  companyContact: CompanyContact


  userErrors: [BusinessCustomerUserError!]!
}


type CompanyContactDeletePayload {

  deletedCompanyContactId: ID


  userErrors: [BusinessCustomerUserError!]!
}


type CompanyContactEdge {

  cursor: String!


  node: CompanyContact!
}


input CompanyContactInput {

  firstName: String


  lastName: String


  email: String


  title: String


  locale: String


  phone: String
}


type CompanyContactRemoveFromCompanyPayload {

  removedCompanyContactId: ID


  userErrors: [BusinessCustomerUserError!]!
}


type CompanyContactRevokeRolePayload {

  revokedCompanyContactRoleAssignmentId: ID


  userErrors: [BusinessCustomerUserError!]!
}


type CompanyContactRevokeRolesPayload {

  revokedRoleAssignmentIds: [ID!]


  userErrors: [BusinessCustomerUserError!]!
}


type CompanyContactRole implements Node {

  id: ID!


  name: String!


  note: String
}


input CompanyContactRoleAssign {

  companyContactRoleId: ID!


  companyLocationId: ID!
}


type CompanyContactRoleAssignment implements Node {

  company: Company!


  companyContact: CompanyContact!


  companyLocation: CompanyLocation!


  createdAt: DateTime!


  id: ID!


  role: CompanyContactRole!


  updatedAt: DateTime!
}


type CompanyContactRoleAssignmentConnection {

  edges: [CompanyContactRoleAssignmentEdge!]!


  nodes: [CompanyContactRoleAssignment!]!


  pageInfo: PageInfo!
}


type CompanyContactRoleAssignmentEdge {

  cursor: String!


  node: CompanyContactRoleAssignment!
}


enum CompanyContactRoleAssignmentSortKeys {

  CREATED_AT


  UPDATED_AT


  LOCATION_NAME


  ID


  RELEVANCE
}


type CompanyContactRoleConnection {

  edges: [CompanyContactRoleEdge!]!


  nodes: [CompanyContactRole!]!


  pageInfo: PageInfo!
}


type CompanyContactRoleEdge {

  cursor: String!


  node: CompanyContactRole!
}


enum CompanyContactRoleSortKeys {

  CREATED_AT


  UPDATED_AT


  ID


  RELEVANCE
}


type CompanyContactsDeletePayload {

  deletedCompanyContactIds: [ID!]


  userErrors: [BusinessCustomerUserError!]!
}


type CompanyContactSendWelcomeEmailPayload {

  companyContact: CompanyContact


  userErrors: [BusinessCustomerUserError!]!
}


enum CompanyContactSortKeys {

  CREATED_AT


  UPDATED_AT


  TITLE


  COMPANY_ID


  NAME


  EMAIL


  NAME_EMAIL


  ID


  RELEVANCE
}


type CompanyContactUpdatePayload {

  companyContact: CompanyContact


  userErrors: [BusinessCustomerUserError!]!
}


input CompanyCreateInput {

  company: CompanyInput!


  companyContact: CompanyContactInput


  companyLocation: CompanyLocationInput
}


type CompanyCreatePayload {

  company: Company


  userErrors: [BusinessCustomerUserError!]!
}


type CompanyDeletePayload {

  deletedCompanyId: ID


  userErrors: [BusinessCustomerUserError!]!
}


type CompanyEdge {

  cursor: String!


  node: Company!
}


input CompanyInput {

  name: String


  note: String


  externalId: String


  customerSince: DateTime
}


type CompanyLocation implements CommentEventSubject & HasEvents & HasMetafieldDefinitions & HasMetafields & Navigable & Node {

  billingAddress: CompanyAddress


  buyerExperienceConfiguration: BuyerExperienceConfiguration


  catalogs(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): CatalogConnection!


  company: Company!


  createdAt: DateTime!


  currency: CurrencyCode!


  defaultCursor: String!


  draftOrders(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: DraftOrderSortKeys = ID


    query: String
  ): DraftOrderConnection!


  events(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: EventSortKeys = ID


    query: String
  ): EventConnection!


  externalId: String


  hasTimelineComment: Boolean!


  id: ID!


  inCatalog(

    catalogId: ID!
  ): Boolean!


  locale: String


  market: Market!


  metafield(

    namespace: String


    key: String!
  ): Metafield


  metafieldDefinitions(

    namespace: String


    pinnedStatus: MetafieldDefinitionPinnedStatus = ANY


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: MetafieldDefinitionSortKeys = ID


    query: String
  ): MetafieldDefinitionConnection!


  metafields(

    namespace: String


    keys: [String!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  name: String!


  note: String


  orderCount: Int!


  orders(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: OrderSortKeys = ID
  ): OrderConnection!


  phone: String


  privateMetafield(

    namespace: String!


    key: String!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  roleAssignments(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: CompanyContactRoleAssignmentSortKeys = ID


    query: String
  ): CompanyContactRoleAssignmentConnection!


  shippingAddress: CompanyAddress


  taxExemptions: [TaxExemption!]!


  taxRegistrationId: String


  totalSpent: MoneyV2!


  updatedAt: DateTime!
}


type CompanyLocationAssignAddressPayload {

  addresses: [CompanyAddress!]


  userErrors: [BusinessCustomerUserError!]!
}


type CompanyLocationAssignRolesPayload {

  roleAssignments: [CompanyContactRoleAssignment!]


  userErrors: [BusinessCustomerUserError!]!
}


type CompanyLocationAssignTaxExemptionsPayload {

  companyLocation: CompanyLocation


  userErrors: [BusinessCustomerUserError!]!
}


type CompanyLocationCatalog implements Catalog & Node {

  companyLocations(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: CompanyLocationSortKeys = ID


    query: String
  ): CompanyLocationConnection!


  companyLocationsCount: Int!


  id: ID!


  operations: [ResourceOperation!]!


  priceList: PriceList


  publication: Publication


  status: CatalogStatus!


  title: String!
}


type CompanyLocationConnection {

  edges: [CompanyLocationEdge!]!


  nodes: [CompanyLocation!]!


  pageInfo: PageInfo!
}


type CompanyLocationCreatePayload {

  companyLocation: CompanyLocation


  userErrors: [BusinessCustomerUserError!]!
}


type CompanyLocationCreateTaxRegistrationPayload {

  companyLocation: CompanyLocation


  userErrors: [BusinessCustomerUserError!]!
}


type CompanyLocationDeletePayload {

  deletedCompanyLocationId: ID


  userErrors: [BusinessCustomerUserError!]!
}


type CompanyLocationEdge {

  cursor: String!


  node: CompanyLocation!
}


input CompanyLocationInput {

  name: String


  phone: String


  locale: String


  externalId: String


  note: String


  buyerExperienceConfiguration: BuyerExperienceConfigurationInput


  billingAddress: CompanyAddressInput


  shippingAddress: CompanyAddressInput


  billingSameAsShipping: Boolean


  taxRegistrationId: String


  taxExemptions: [TaxExemption!]
}


type CompanyLocationRevokeRolesPayload {

  revokedRoleAssignmentIds: [ID!]


  userErrors: [BusinessCustomerUserError!]!
}


type CompanyLocationRevokeTaxExemptionsPayload {

  companyLocation: CompanyLocation


  userErrors: [BusinessCustomerUserError!]!
}


type CompanyLocationRevokeTaxRegistrationPayload {

  companyLocation: CompanyLocation


  userErrors: [BusinessCustomerUserError!]!
}


input CompanyLocationRoleAssign {

  companyContactRoleId: ID!


  companyContactId: ID!
}


type CompanyLocationsDeletePayload {

  deletedCompanyLocationIds: [ID!]


  userErrors: [BusinessCustomerUserError!]!
}


enum CompanyLocationSortKeys {

  CREATED_AT


  UPDATED_AT


  NAME


  COMPANY_ID


  COMPANY_AND_LOCATION_NAME


  ID


  RELEVANCE
}


input CompanyLocationUpdateInput {

  name: String


  phone: String


  locale: String


  externalId: String


  note: String


  buyerExperienceConfiguration: BuyerExperienceConfigurationInput
}


type CompanyLocationUpdatePayload {

  companyLocation: CompanyLocation


  userErrors: [BusinessCustomerUserError!]!
}


type CompanyRevokeMainContactPayload {

  company: Company


  userErrors: [BusinessCustomerUserError!]!
}


enum CompanySortKeys {

  CREATED_AT


  UPDATED_AT


  SINCE_DATE


  NAME


  ORDER_COUNT


  TOTAL_SPENT


  ID


  RELEVANCE
}


type CompanyUpdatePayload {

  company: Company


  userErrors: [BusinessCustomerUserError!]!
}


input ContextualPricingContext {

  country: CountryCode


  companyLocationId: ID
}


input ContextualPublicationContext {

  country: CountryCode


  companyLocationId: ID
}


type CountriesInShippingZones {

  countryCodes: [CountryCode!]!


  includeRestOfWorld: Boolean!
}


enum CountryCode {

  AF


  AX


  AL


  DZ


  AD


  AO


  AI


  AG


  AR


  AM


  AW


  AC


  AU


  AT


  AZ


  BS


  BH


  BD


  BB


  BY


  BE


  BZ


  BJ


  BM


  BT


  BO


  BA


  BW


  BV


  BR


  IO


  BN


  BG


  BF


  BI


  KH


  CA


  CV


  BQ


  KY


  CF


  TD


  CL


  CN


  CX


  CC


  CO


  KM


  CG


  CD


  CK


  CR


  HR


  CU


  CW


  CY


  CZ


  CI


  DK


  DJ


  DM


  DO


  EC


  EG


  SV


  GQ


  ER


  EE


  SZ


  ET


  FK


  FO


  FJ


  FI


  FR


  GF


  PF


  TF


  GA


  GM


  GE


  DE


  GH


  GI


  GR


  GL


  GD


  GP


  GT


  GG


  GN


  GW


  GY


  HT


  HM


  VA


  HN


  HK


  HU


  IS


  IN


  ID


  IR


  IQ


  IE


  IM


  IL


  IT


  JM


  JP


  JE


  JO


  KZ


  KE


  KI


  KP


  XK


  KW


  KG


  LA


  LV


  LB


  LS


  LR


  LY


  LI


  LT


  LU


  MO


  MG


  MW


  MY


  MV


  ML


  MT


  MQ


  MR


  MU


  YT


  MX


  MD


  MC


  MN


  ME


  MS


  MA


  MZ


  MM


  NA


  NR


  NP


  NL


  AN


  NC


  NZ


  NI


  NE


  NG


  NU


  NF


  MK


  NO


  OM


  PK


  PS


  PA


  PG


  PY


  PE


  PH


  PN


  PL


  PT


  QA


  CM


  RE


  RO


  RU


  RW


  BL


  SH


  KN


  LC


  MF


  PM


  WS


  SM


  ST


  SA


  SN


  RS


  SC


  SL


  SG


  SX


  SK


  SI


  SB


  SO


  ZA


  GS


  KR


  SS


  ES


  LK


  VC


  SD


  SR


  SJ


  SE


  CH


  SY


  TW


  TJ


  TZ


  TH


  TL


  TG


  TK


  TO


  TT


  TA


  TN


  TR


  TM


  TC


  TV


  UG


  UA


  AE


  GB


  US


  UM


  UY


  UZ


  VU


  VE


  VN


  VG


  WF


  EH


  YE


  ZM


  ZW


  ZZ
}


type CountryHarmonizedSystemCode {

  countryCode: CountryCode!


  harmonizedSystemCode: String!
}


type CountryHarmonizedSystemCodeConnection {

  edges: [CountryHarmonizedSystemCodeEdge!]!


  nodes: [CountryHarmonizedSystemCode!]!


  pageInfo: PageInfo!
}


type CountryHarmonizedSystemCodeEdge {

  cursor: String!


  node: CountryHarmonizedSystemCode!
}


input CountryHarmonizedSystemCodeInput {

  harmonizedSystemCode: String!


  countryCode: CountryCode!
}


input CreateMediaInput {

  originalSource: String!


  alt: String


  mediaContentType: MediaContentType!
}


enum CropRegion {

  CENTER


  TOP


  BOTTOM


  LEFT


  RIGHT
}


enum CurrencyCode {

  USD


  EUR


  GBP


  CAD


  AFN


  ALL


  DZD


  AOA


  ARS


  AMD


  AWG


  AUD


  BBD


  AZN


  BDT


  BSD


  BHD


  BIF


  BYN


  BZD


  BMD


  BTN


  BAM


  BRL


  BOB


  BWP


  BND


  BGN


  MMK


  KHR


  CVE


  KYD


  XAF


  CLP


  CNY


  COP


  KMF


  CDF


  CRC


  HRK


  CZK


  DKK


  DJF


  DOP


  XCD


  EGP


  ERN


  ETB


  FKP


  XPF


  FJD


  GIP


  GMD


  GHS


  GTQ


  GYD


  GEL


  GNF


  HTG


  HNL


  HKD


  HUF


  ISK


  INR


  IDR


  ILS


  IRR


  IQD


  JMD


  JPY


  JEP


  JOD


  KZT


  KES


  KID


  KWD


  KGS


  LAK


  LVL


  LBP


  LSL


  LRD


  LYD


  LTL


  MGA


  MKD


  MOP


  MWK


  MVR


  MRU


  MXN


  MYR


  MUR


  MDL


  MAD


  MNT


  MZN


  NAD


  NPR


  ANG


  NZD


  NIO


  NGN


  NOK


  OMR


  PAB


  PKR


  PGK


  PYG


  PEN


  PHP


  PLN


  QAR


  RON


  RUB


  RWF


  WST


  SHP


  SAR


  RSD


  SCR


  SLL


  SGD


  SDG


  SOS


  SYP


  ZAR


  KRW


  SSP


  SBD


  LKR


  SRD


  SZL


  SEK


  CHF


  TWD


  THB


  TJS


  TZS


  TOP


  TTD


  TND


  TRY


  TMT


  UGX


  UAH


  AED


  UYU


  UZS


  VUV


  VES


  VND


  XOF


  YER


  ZMW


  BYR @deprecated(reason: "`BYR` is deprecated. Use `BYN` available from version `2021-01` onwards instead.")


  STD @deprecated(reason: "`STD` is deprecated. Use `STN` available from version `2022-07` onwards instead.")


  STN


  VED


  VEF @deprecated(reason: "`VEF` is deprecated. Use `VES` available from version `2020-10` onwards instead.")


  XXX
}


type CurrencyFormats {

  moneyFormat: FormattedString!


  moneyInEmailsFormat: String!


  moneyWithCurrencyFormat: FormattedString!


  moneyWithCurrencyInEmailsFormat: String!
}


type CurrencySetting {

  currencyCode: CurrencyCode!


  currencyName: String!


  enabled: Boolean!


  rateUpdatedAt: DateTime
}


type CurrencySettingConnection {

  edges: [CurrencySettingEdge!]!


  nodes: [CurrencySetting!]!


  pageInfo: PageInfo!
}


type CurrencySettingEdge {

  cursor: String!


  node: CurrencySetting!
}


type Customer implements CommentEventSubject & HasEvents & HasMetafieldDefinitions & HasMetafields & LegacyInteroperability & Node {

  addresses(

    first: Int
  ): [MailingAddress!]!


  amountSpent: MoneyV2!


  canDelete: Boolean!


  companyContactProfiles: [CompanyContact!]!


  createdAt: DateTime!


  defaultAddress: MailingAddress


  displayName: String!


  email: String


  emailMarketingConsent: CustomerEmailMarketingConsentState


  events(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: EventSortKeys = ID


    query: String
  ): EventConnection!


  firstName: String


  hasTimelineComment: Boolean! @deprecated(reason: "To query for comments on the timeline, use the events connection and a `query` argument containing `verb:comment`, or look for a `CommentEvent` in the `__typename` of events.")


  id: ID!


  image: Image!


  lastName: String


  lastOrder: Order


  legacyResourceId: UnsignedInt64!


  lifetimeDuration: String!


  locale: String!


  market: Market


  mergeable: CustomerMergeable!


  metafield(

    namespace: String


    key: String!
  ): Metafield


  metafieldDefinitions(

    namespace: String


    pinnedStatus: MetafieldDefinitionPinnedStatus = ANY


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: MetafieldDefinitionSortKeys = ID


    query: String
  ): MetafieldDefinitionConnection!


  metafields(

    namespace: String


    keys: [String!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  multipassIdentifier: String


  note: String


  numberOfOrders: UnsignedInt64!


  orders(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: OrderSortKeys = ID


    query: String
  ): OrderConnection!


  paymentMethods(

    showRevoked: Boolean = false


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): CustomerPaymentMethodConnection!


  phone: String


  privateMetafield(

    namespace: String!


    key: String!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  productSubscriberStatus: CustomerProductSubscriberStatus!


  smsMarketingConsent: CustomerSmsMarketingConsentState


  state: CustomerState!


  statistics: CustomerStatistics!


  subscriptionContracts(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SubscriptionContractConnection!


  tags: [String!]!


  taxExempt: Boolean!


  taxExemptions: [TaxExemption!]!


  unsubscribeUrl: URL!


  updatedAt: DateTime!


  validEmailAddress: Boolean!


  verifiedEmail: Boolean!
}


type CustomerAccountsV2 {

  customerAccountsVersion: CustomerAccountsVersion!


  loginLinksVisibleOnStorefrontAndCheckout: Boolean!


  loginRequiredAtCheckout: Boolean!


  url: URL
}


enum CustomerAccountsVersion {

  CLASSIC


  NEW_CUSTOMER_ACCOUNTS
}


type CustomerAddTaxExemptionsPayload {

  customer: Customer


  userErrors: [UserError!]!
}


enum CustomerCancelDataErasureErrorCode {

  DOES_NOT_EXIST


  FAILED_TO_CANCEL


  NOT_BEING_ERASED
}


type CustomerCancelDataErasurePayload {

  customerId: ID


  userErrors: [CustomerCancelDataErasureUserError!]!
}


type CustomerCancelDataErasureUserError implements DisplayableError {

  code: CustomerCancelDataErasureErrorCode


  field: [String!]


  message: String!
}


type CustomerConnection {

  edges: [CustomerEdge!]!


  nodes: [Customer!]!


  pageInfo: PageInfo!
}


enum CustomerConsentCollectedFrom {

  SHOPIFY


  OTHER
}


type CustomerCreatePayload {

  customer: Customer


  userErrors: [UserError!]!
}


type CustomerCreditCard {

  billingAddress: CustomerCreditCardBillingAddress


  brand: String!


  expiresSoon: Boolean!


  expiryMonth: Int!


  expiryYear: Int!


  firstDigits: String


  isRevocable: Boolean!


  lastDigits: String!


  maskedNumber: String!


  name: String!


  source: String


  virtualLastDigits: String
}


type CustomerCreditCardBillingAddress {

  address1: String


  city: String


  country: String


  countryCode: CountryCode


  firstName: String


  lastName: String


  province: String


  provinceCode: String


  zip: String
}


input CustomerDeleteInput {

  id: ID!
}


type CustomerDeletePayload {

  deletedCustomerId: ID


  shop: Shop!


  userErrors: [UserError!]!
}


type CustomerEdge {

  cursor: String!


  node: Customer!
}


type CustomerEmailAddress {

  emailAddress: String!


  marketingState: CustomerEmailAddressMarketingState!


  marketingUnsubscribeUrl: URL!


  openTrackingLevel: CustomerEmailAddressOpenTrackingLevel!


  openTrackingUrl: URL!
}


enum CustomerEmailAddressMarketingState {

  INVALID


  NOT_SUBSCRIBED


  PENDING


  SUBSCRIBED


  UNSUBSCRIBED
}


enum CustomerEmailAddressOpenTrackingLevel {

  UNKNOWN


  OPTED_IN


  OPTED_OUT
}


input CustomerEmailMarketingConsentInput {

  marketingOptInLevel: CustomerMarketingOptInLevel


  marketingState: CustomerEmailMarketingState!


  consentUpdatedAt: DateTime
}


type CustomerEmailMarketingConsentState {

  consentUpdatedAt: DateTime


  marketingOptInLevel: CustomerMarketingOptInLevel


  marketingState: CustomerEmailMarketingState!
}


input CustomerEmailMarketingConsentUpdateInput {

  customerId: ID!


  emailMarketingConsent: CustomerEmailMarketingConsentInput!
}


type CustomerEmailMarketingConsentUpdatePayload {

  customer: Customer


  userErrors: [CustomerEmailMarketingConsentUpdateUserError!]!
}


type CustomerEmailMarketingConsentUpdateUserError implements DisplayableError {

  code: CustomerEmailMarketingConsentUpdateUserErrorCode


  field: [String!]


  message: String!
}


enum CustomerEmailMarketingConsentUpdateUserErrorCode {

  INVALID


  INCLUSION


  INTERNAL_ERROR


  MISSING_ARGUMENT
}


enum CustomerEmailMarketingState {

  NOT_SUBSCRIBED


  PENDING


  SUBSCRIBED


  UNSUBSCRIBED


  REDACTED


  INVALID
}


type CustomerGenerateAccountActivationUrlPayload {

  accountActivationUrl: URL


  userErrors: [UserError!]!
}


input CustomerInput {

  addresses: [MailingAddressInput!]


  email: String


  firstName: String


  id: ID


  lastName: String


  locale: String


  metafields: [MetafieldInput!]


  note: String


  phone: String


  tags: [String!]


  emailMarketingConsent: CustomerEmailMarketingConsentInput


  smsMarketingConsent: CustomerSmsMarketingConsentInput


  taxExempt: Boolean


  taxExemptions: [TaxExemption!]
}


type CustomerJourney {

  customerOrderIndex: Int!


  daysToConversion: Int!


  firstVisit: CustomerVisit!


  lastVisit: CustomerVisit


  moments: [CustomerMoment!]!
}


type CustomerJourneySummary {

  customerOrderIndex: Int


  daysToConversion: Int


  firstVisit: CustomerVisit


  lastVisit: CustomerVisit


  moments(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): CustomerMomentConnection


  momentsCount: Int


  ready: Boolean!
}


enum CustomerMarketingOptInLevel {

  SINGLE_OPT_IN


  CONFIRMED_OPT_IN


  UNKNOWN
}


type CustomerMergeable {

  errorFields: [CustomerMergeErrorFieldType!]!


  isMergeable: Boolean!


  mergeInProgress: CustomerMergeRequest


  reason: String
}


type CustomerMergeError {

  errorFields: [CustomerMergeErrorFieldType!]!


  message: String!
}


enum CustomerMergeErrorCode {

  INTERNAL_ERROR


  INVALID_CUSTOMER


  INVALID_CUSTOMER_ID


  CUSTOMER_HAS_GIFT_CARDS


  MISSING_OVERRIDE_ATTRIBUTE


  OVERRIDE_ATTRIBUTE_INVALID
}


enum CustomerMergeErrorFieldType {

  DELETED_AT


  REDACTED_AT


  SUBSCRIPTIONS


  MERGE_IN_PROGRESS


  GIFT_CARDS


  COMPANY_CONTACT


  CUSTOMER_PAYMENT_METHODS


  PENDING_DATA_REQUEST


  MULTIPASS_IDENTIFIER
}


input CustomerMergeOverrideFields {

  customerIdOfFirstNameToKeep: ID


  customerIdOfLastNameToKeep: ID


  customerIdOfEmailToKeep: ID


  customerIdOfPhoneNumberToKeep: ID


  customerIdOfDefaultAddressToKeep: ID


  note: String


  tags: [String!]
}


type CustomerMergePayload {

  job: Job


  resultingCustomerId: ID


  userErrors: [CustomerMergeUserError!]!
}


type CustomerMergePreview {

  alternateFields: CustomerMergePreviewAlternateFields


  blockingFields: CustomerMergePreviewBlockingFields


  customerMergeErrors: [CustomerMergeError!]


  defaultFields: CustomerMergePreviewDefaultFields


  resultingCustomerId: ID
}


type CustomerMergePreviewAlternateFields {

  defaultAddress: MailingAddress


  email: CustomerEmailAddress


  firstName: String


  lastName: String


  phoneNumber: CustomerPhoneNumber
}


type CustomerMergePreviewBlockingFields {

  note: String


  tags: [String!]!
}


type CustomerMergePreviewDefaultFields {

  addresses(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MailingAddressConnection!


  defaultAddress: MailingAddress


  discountNodeCount: UnsignedInt64!


  discountNodes(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: DiscountSortKeys = CREATED_AT
  ): DiscountNodeConnection!


  displayName: String!


  draftOrderCount: UnsignedInt64!


  draftOrders(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: DraftOrderSortKeys = UPDATED_AT
  ): DraftOrderConnection!


  email: CustomerEmailAddress


  firstName: String


  giftCardCount: UnsignedInt64!


  giftCards(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: GiftCardSortKeys = CREATED_AT
  ): GiftCardConnection!


  lastName: String


  metafieldCount: UnsignedInt64!


  note: String


  orderCount: UnsignedInt64!


  orders(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: OrderSortKeys = PROCESSED_AT
  ): OrderConnection!


  phoneNumber: CustomerPhoneNumber


  tags: [String!]!
}


type CustomerMergeRequest {

  customerMergeErrors: [CustomerMergeError!]!


  jobId: ID


  resultingCustomerId: ID!


  status: CustomerMergeRequestStatus!
}


enum CustomerMergeRequestStatus {

  REQUESTED


  IN_PROGRESS


  COMPLETED


  FAILED
}


type CustomerMergeUserError implements DisplayableError {

  code: CustomerMergeErrorCode


  field: [String!]


  message: String!
}


interface CustomerMoment {

  occurredAt: DateTime!
}


type CustomerMomentConnection {

  edges: [CustomerMomentEdge!]!


  nodes: [CustomerMoment!]!


  pageInfo: PageInfo!
}


type CustomerMomentEdge {

  cursor: String!


  node: CustomerMoment!
}


union CustomerPaymentInstrument = CustomerCreditCard | CustomerPaypalBillingAgreement | CustomerShopPayAgreement


type CustomerPaymentInstrumentBillingAddress {

  address1: String


  city: String


  country: String


  countryCode: CountryCode


  name: String


  province: String


  provinceCode: String


  zip: String
}


type CustomerPaymentMethod implements Node {

  customer: Customer


  id: ID!


  instrument: CustomerPaymentInstrument


  revokedAt: DateTime


  revokedReason: CustomerPaymentMethodRevocationReason


  subscriptionContracts(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SubscriptionContractConnection!
}


type CustomerPaymentMethodConnection {

  edges: [CustomerPaymentMethodEdge!]!


  nodes: [CustomerPaymentMethod!]!


  pageInfo: PageInfo!
}


type CustomerPaymentMethodCreateFromDuplicationDataPayload {

  customerPaymentMethod: CustomerPaymentMethod


  userErrors: [CustomerPaymentMethodCreateFromDuplicationDataUserError!]!
}


type CustomerPaymentMethodCreateFromDuplicationDataUserError implements DisplayableError {

  code: CustomerPaymentMethodCreateFromDuplicationDataUserErrorCode


  field: [String!]


  message: String!
}


enum CustomerPaymentMethodCreateFromDuplicationDataUserErrorCode {

  TOO_MANY_REQUESTS


  CUSTOMER_DOES_NOT_EXIST


  INVALID_ENCRYPTED_DUPLICATION_DATA
}


type CustomerPaymentMethodCreditCardCreatePayload {

  customerPaymentMethod: CustomerPaymentMethod


  processing: Boolean


  userErrors: [UserError!]!
}


type CustomerPaymentMethodCreditCardUpdatePayload {

  customerPaymentMethod: CustomerPaymentMethod


  processing: Boolean


  userErrors: [UserError!]!
}


type CustomerPaymentMethodEdge {

  cursor: String!


  node: CustomerPaymentMethod!
}


type CustomerPaymentMethodGetDuplicationDataPayload {

  encryptedDuplicationData: String


  userErrors: [CustomerPaymentMethodGetDuplicationDataUserError!]!
}


type CustomerPaymentMethodGetDuplicationDataUserError implements DisplayableError {

  code: CustomerPaymentMethodGetDuplicationDataUserErrorCode


  field: [String!]


  message: String!
}


enum CustomerPaymentMethodGetDuplicationDataUserErrorCode {

  PAYMENT_METHOD_DOES_NOT_EXIST


  INVALID_INSTRUMENT


  TOO_MANY_REQUESTS


  CUSTOMER_DOES_NOT_EXIST


  SAME_SHOP


  INVALID_ORGANIZATION_SHOP
}


type CustomerPaymentMethodGetUpdateUrlPayload {

  updatePaymentMethodUrl: URL


  userErrors: [CustomerPaymentMethodGetUpdateUrlUserError!]!
}


type CustomerPaymentMethodGetUpdateUrlUserError implements DisplayableError {

  code: CustomerPaymentMethodGetUpdateUrlUserErrorCode


  field: [String!]


  message: String!
}


enum CustomerPaymentMethodGetUpdateUrlUserErrorCode {

  PAYMENT_METHOD_DOES_NOT_EXIST


  INVALID_INSTRUMENT


  TOO_MANY_REQUESTS


  CUSTOMER_DOES_NOT_EXIST
}


type CustomerPaymentMethodPaypalBillingAgreementCreatePayload {

  customerPaymentMethod: CustomerPaymentMethod


  userErrors: [CustomerPaymentMethodUserError!]!
}


type CustomerPaymentMethodPaypalBillingAgreementUpdatePayload {

  customerPaymentMethod: CustomerPaymentMethod


  userErrors: [CustomerPaymentMethodUserError!]!
}


type CustomerPaymentMethodRemoteCreatePayload {

  customerPaymentMethod: CustomerPaymentMethod


  userErrors: [CustomerPaymentMethodRemoteUserError!]!
}


type CustomerPaymentMethodRemoteCreditCardCreatePayload {

  customerPaymentMethod: CustomerPaymentMethod


  userErrors: [CustomerPaymentMethodUserError!]!
}


input CustomerPaymentMethodRemoteInput {

  stripePaymentMethod: RemoteStripePaymentMethodInput


  authorizeNetCustomerPaymentProfile: RemoteAuthorizeNetCustomerPaymentProfileInput


  braintreePaymentMethod: RemoteBraintreePaymentMethodInput
}


type CustomerPaymentMethodRemoteUserError implements DisplayableError {

  code: CustomerPaymentMethodRemoteUserErrorCode


  field: [String!]


  message: String!
}


enum CustomerPaymentMethodRemoteUserErrorCode {

  INVALID


  PRESENT


  TAKEN


  EXACTLY_ONE_REMOTE_REFERENCE_REQUIRED


  AUTHORIZE_NET_NOT_ENABLED_FOR_SUBSCRIPTIONS


  BRAINTREE_NOT_ENABLED_FOR_SUBSCRIPTIONS
}


enum CustomerPaymentMethodRevocationReason {

  AUTHORIZE_NET_GATEWAY_NOT_ENABLED


  AUTHORIZE_NET_RETURNED_NO_PAYMENT_METHOD


  FAILED_TO_UPDATE_CREDIT_CARD


  STRIPE_API_AUTHENTICATION_ERROR


  STRIPE_API_INVALID_REQUEST_ERROR


  STRIPE_GATEWAY_NOT_ENABLED


  STRIPE_RETURNED_NO_PAYMENT_METHOD


  STRIPE_PAYMENT_METHOD_NOT_CARD


  BRAINTREE_API_AUTHENTICATION_ERROR


  BRAINTREE_GATEWAY_NOT_ENABLED


  BRAINTREE_RETURNED_NO_PAYMENT_METHOD


  BRAINTREE_PAYMENT_METHOD_NOT_CARD


  MANUALLY_REVOKED


  MERGED
}


type CustomerPaymentMethodRevokePayload {

  revokedCustomerPaymentMethodId: ID


  userErrors: [UserError!]!
}


type CustomerPaymentMethodSendUpdateEmailPayload {

  customer: Customer


  userErrors: [UserError!]!
}


type CustomerPaymentMethodUserError implements DisplayableError {

  code: CustomerPaymentMethodUserErrorCode


  field: [String!]


  message: String!
}


enum CustomerPaymentMethodUserErrorCode {

  INVALID


  PRESENT


  TAKEN
}


type CustomerPaypalBillingAgreement {

  billingAddress: CustomerPaymentInstrumentBillingAddress


  inactive: Boolean!


  isRevocable: Boolean!


  paypalAccountEmail: String
}


type CustomerPhoneNumber {

  marketingState: CustomerSmsMarketingState!


  phoneNumber: String!
}


enum CustomerPredictedSpendTier {

  HIGH


  MEDIUM


  LOW
}


enum CustomerProductSubscriberStatus {

  ACTIVE


  CANCELLED


  EXPIRED


  FAILED


  NEVER_SUBSCRIBED


  PAUSED
}


type CustomerRemoveTaxExemptionsPayload {

  customer: Customer


  userErrors: [UserError!]!
}


type CustomerReplaceTaxExemptionsPayload {

  customer: Customer


  userErrors: [UserError!]!
}


enum CustomerRequestDataErasureErrorCode {

  DOES_NOT_EXIST


  FAILED_TO_REQUEST
}


type CustomerRequestDataErasurePayload {

  customerId: ID


  userErrors: [CustomerRequestDataErasureUserError!]!
}


type CustomerRequestDataErasureUserError implements DisplayableError {

  code: CustomerRequestDataErasureErrorCode


  field: [String!]


  message: String!
}


enum CustomerSavedSearchSortKeys {

  NAME


  ID


  RELEVANCE
}


type CustomerSegmentMember implements HasMetafields {

  amountSpent: MoneyV2


  defaultAddress: MailingAddress


  defaultEmailAddress: CustomerEmailAddress


  defaultPhoneNumber: CustomerPhoneNumber


  displayName: String!


  firstName: String


  id: ID!


  lastName: String


  lastOrderId: ID


  mergeable: CustomerMergeable!


  metafield(

    namespace: String


    key: String!
  ): Metafield


  metafields(

    namespace: String


    keys: [String!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  note: String


  numberOfOrders: UnsignedInt64


  privateMetafield(

    namespace: String!


    key: String!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")
}


type CustomerSegmentMemberConnection {

  edges: [CustomerSegmentMemberEdge!]!


  pageInfo: PageInfo!


  statistics: SegmentStatistics!


  totalCount: Int!
}


type CustomerSegmentMemberEdge {

  cursor: String!


  node: CustomerSegmentMember!
}


type CustomerSegmentMembersQuery implements JobResult & Node {

  currentCount: Int!


  done: Boolean!


  id: ID!
}


type CustomerSegmentMembersQueryCreatePayload {

  customerSegmentMembersQuery: CustomerSegmentMembersQuery


  userErrors: [CustomerSegmentMembersQueryUserError!]!
}


input CustomerSegmentMembersQueryInput {

  segmentId: ID


  query: String


  reverse: Boolean = false


  sortKey: String
}


type CustomerSegmentMembersQueryUserError implements DisplayableError {

  code: CustomerSegmentMembersQueryUserErrorCode


  field: [String!]


  message: String!
}


enum CustomerSegmentMembersQueryUserErrorCode {

  INVALID
}


type CustomerShopPayAgreement {

  billingAddress: CustomerCreditCardBillingAddress


  expiresSoon: Boolean!


  expiryMonth: Int!


  expiryYear: Int!


  inactive: Boolean!


  isRevocable: Boolean!


  lastDigits: String!


  maskedNumber: String!


  name: String!
}


type CustomerSmsMarketingConsentError implements DisplayableError {

  code: CustomerSmsMarketingConsentErrorCode


  field: [String!]


  message: String!
}


enum CustomerSmsMarketingConsentErrorCode {

  INVALID


  INCLUSION


  INTERNAL_ERROR


  MISSING_ARGUMENT
}


input CustomerSmsMarketingConsentInput {

  marketingOptInLevel: CustomerMarketingOptInLevel


  marketingState: CustomerSmsMarketingState!


  consentUpdatedAt: DateTime
}


type CustomerSmsMarketingConsentState {

  consentCollectedFrom: CustomerConsentCollectedFrom


  consentUpdatedAt: DateTime


  marketingOptInLevel: CustomerMarketingOptInLevel!


  marketingState: CustomerSmsMarketingState!
}


input CustomerSmsMarketingConsentUpdateInput {

  customerId: ID!


  smsMarketingConsent: CustomerSmsMarketingConsentInput!
}


type CustomerSmsMarketingConsentUpdatePayload {

  customer: Customer


  userErrors: [CustomerSmsMarketingConsentError!]!
}


enum CustomerSmsMarketingState {

  NOT_SUBSCRIBED


  PENDING


  SUBSCRIBED


  UNSUBSCRIBED


  REDACTED
}


enum CustomerSortKeys {

  CREATED_AT


  NAME


  LOCATION


  ORDERS_COUNT


  LAST_ORDER_DATE


  TOTAL_SPENT


  UPDATED_AT


  ID


  RELEVANCE
}


enum CustomerState {

  DECLINED


  DISABLED


  ENABLED


  INVITED
}


type CustomerStatistics {

  predictedSpendTier: CustomerPredictedSpendTier
}


type CustomerUpdateDefaultAddressPayload {

  customer: Customer


  userErrors: [UserError!]!
}


type CustomerUpdatePayload {

  customer: Customer


  userErrors: [UserError!]!
}


type CustomerVisit implements CustomerMoment & Node {

  id: ID!


  landingPage: URL


  landingPageHtml: HTML


  marketingEvent: MarketingEvent


  occurredAt: DateTime!


  referralCode: String


  referralInfoHtml: FormattedString!


  referrerUrl: URL


  source: String!


  sourceDescription: String


  sourceType: MarketingTactic


  utmParameters: UTMParameters
}


type CustomerVisitProductInfo {

  product: Product


  quantity: Int!


  variant: ProductVariant
}


type CustomerVisitProductInfoConnection {

  edges: [CustomerVisitProductInfoEdge!]!


  nodes: [CustomerVisitProductInfo!]!


  pageInfo: PageInfo!
}


type CustomerVisitProductInfoEdge {

  cursor: String!


  node: CustomerVisitProductInfo!
}


input CustomShippingPackageInput {

  weight: WeightInput


  dimensions: ObjectDimensionsInput


  default: Boolean = false


  name: String


  type: ShippingPackageType
}


scalar Date


scalar DateTime


enum DayOfTheWeek {

  MONDAY


  TUESDAY


  WEDNESDAY


  THURSDAY


  FRIDAY


  SATURDAY


  SUNDAY
}


scalar Decimal


type DelegateAccessToken {

  accessScopes: [String!]!


  accessToken: String!


  createdAt: DateTime!
}


type DelegateAccessTokenCreatePayload {

  delegateAccessToken: DelegateAccessToken


  shop: Shop!


  userErrors: [DelegateAccessTokenCreateUserError!]!
}


type DelegateAccessTokenCreateUserError implements DisplayableError {

  code: DelegateAccessTokenCreateUserErrorCode


  field: [String!]


  message: String!
}


enum DelegateAccessTokenCreateUserErrorCode {

  EMPTY_ACCESS_SCOPE


  DELEGATE_ACCESS_TOKEN


  NEGATIVE_EXPIRES_IN


  EXPIRES_AFTER_PARENT


  REFRESH_TOKEN


  PERSISTENCE_FAILED


  UNKNOWN_SCOPES
}


type DelegateAccessTokenDestroyPayload {

  shop: Shop!


  status: Boolean


  userErrors: [DelegateAccessTokenDestroyUserError!]!
}


type DelegateAccessTokenDestroyUserError implements DisplayableError {

  code: DelegateAccessTokenDestroyUserErrorCode


  field: [String!]


  message: String!
}


enum DelegateAccessTokenDestroyUserErrorCode {

  PERSISTENCE_FAILED


  ACCESS_TOKEN_NOT_FOUND


  CAN_ONLY_DELETE_DELEGATE_TOKENS


  ACCESS_DENIED
}


input DelegateAccessTokenInput {

  delegateAccessScope: [String!]!


  expiresIn: Int
}


type DeletionEvent {

  occurredAt: DateTime!


  subjectId: ID!


  subjectType: DeletionEventSubjectType!
}


type DeletionEventConnection {

  edges: [DeletionEventEdge!]!


  nodes: [DeletionEvent!]!


  pageInfo: PageInfo!
}


type DeletionEventEdge {

  cursor: String!


  node: DeletionEvent!
}


enum DeletionEventSortKeys {

  CREATED_AT


  ID


  RELEVANCE
}


enum DeletionEventSubjectType {
  COLLECTION
  PRODUCT
}


type DeliveryAvailableService {

  countries: DeliveryCountryCodesOrRestOfWorld!


  name: String!
}


type DeliveryBrandedPromise {

  handle: String!


  name: String!
}


type DeliveryCarrierService implements Node {

  availableServicesForCountries(

    origins: [ID!]


    countryCodes: [CountryCode!]


    restOfWorld: Boolean!
  ): [DeliveryAvailableService!]!


  formattedName: String


  icon: Image!


  id: ID!


  name: String
}


type DeliveryCarrierServiceAndLocations {

  carrierService: DeliveryCarrierService!


  locations: [Location!]!
}


type DeliveryCondition implements Node {

  conditionCriteria: DeliveryConditionCriteria!


  field: DeliveryConditionField!


  id: ID!


  operator: DeliveryConditionOperator!
}


union DeliveryConditionCriteria = MoneyV2 | Weight


enum DeliveryConditionField {

  TOTAL_WEIGHT


  TOTAL_PRICE
}


enum DeliveryConditionOperator {

  GREATER_THAN_OR_EQUAL_TO


  LESS_THAN_OR_EQUAL_TO
}


type DeliveryCountry implements Node {

  code: DeliveryCountryCodeOrRestOfWorld!


  id: ID!


  name: String!


  provinces: [DeliveryProvince!]!


  translatedName: String!
}


type DeliveryCountryAndZone {

  country: DeliveryCountry!


  zone: String!
}


type DeliveryCountryCodeOrRestOfWorld {

  countryCode: CountryCode


  restOfWorld: Boolean!
}


type DeliveryCountryCodesOrRestOfWorld {

  countryCodes: [CountryCode!]!


  restOfWorld: Boolean!
}


input DeliveryCountryInput {

  code: CountryCode


  restOfWorld: Boolean


  provinces: [DeliveryProvinceInput!]


  includeAllProvinces: Boolean
}


type DeliveryCustomization implements HasMetafieldDefinitions & HasMetafields & Node {

  enabled: Boolean!


  errorHistory: FunctionsErrorHistory


  functionId: String!


  id: ID!


  metafield(

    namespace: String


    key: String!
  ): Metafield


  metafieldDefinitions(

    namespace: String


    pinnedStatus: MetafieldDefinitionPinnedStatus = ANY


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: MetafieldDefinitionSortKeys = ID


    query: String
  ): MetafieldDefinitionConnection!


  metafields(

    namespace: String


    keys: [String!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  privateMetafield(

    namespace: String!


    key: String!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  shopifyFunction: ShopifyFunction!


  title: String!
}


type DeliveryCustomizationActivationPayload {

  ids: [String!]


  userErrors: [DeliveryCustomizationError!]!
}


type DeliveryCustomizationConnection {

  edges: [DeliveryCustomizationEdge!]!


  nodes: [DeliveryCustomization!]!


  pageInfo: PageInfo!
}


type DeliveryCustomizationCreatePayload {

  deliveryCustomization: DeliveryCustomization


  userErrors: [DeliveryCustomizationError!]!
}


type DeliveryCustomizationDeletePayload {

  deletedId: ID


  userErrors: [DeliveryCustomizationError!]!
}


type DeliveryCustomizationEdge {

  cursor: String!


  node: DeliveryCustomization!
}


type DeliveryCustomizationError implements DisplayableError {

  code: DeliveryCustomizationErrorCode


  field: [String!]


  message: String!
}


enum DeliveryCustomizationErrorCode {

  INVALID


  FUNCTION_NOT_FOUND


  DELIVERY_CUSTOMIZATION_NOT_FOUND


  DELIVERY_CUSTOMIZATION_FUNCTION_NOT_ELIGIBLE


  UNAUTHORIZED_APP_SCOPE


  MAXIMUM_ACTIVE_DELIVERY_CUSTOMIZATIONS


  CUSTOM_APP_FUNCTION_NOT_ELIGIBLE


  FUNCTION_DOES_NOT_IMPLEMENT


  FUNCTION_PENDING_DELETION


  FUNCTION_ID_CANNOT_BE_CHANGED


  REQUIRED_INPUT_FIELD


  INVALID_METAFIELDS
}


input DeliveryCustomizationInput {

  functionId: String


  title: String


  enabled: Boolean


  metafields: [MetafieldInput!] = []
}


type DeliveryCustomizationUpdatePayload {

  deliveryCustomization: DeliveryCustomization


  userErrors: [DeliveryCustomizationError!]!
}


type DeliveryLegacyModeBlocked {

  blocked: Boolean!


  reasons: [DeliveryLegacyModeBlockedReason!]
}


enum DeliveryLegacyModeBlockedReason {

  MULTI_LOCATION_DISABLED @deprecated(reason: "All shops are now using multi-location mode.")


  NO_LOCATIONS_FULFILLING_ONLINE_ORDERS
}


type DeliveryLocalPickupSettings {

  instructions: String!


  pickupTime: DeliveryLocalPickupTime!
}


enum DeliveryLocalPickupTime {

  ONE_HOUR


  TWO_HOURS


  FOUR_HOURS


  TWENTY_FOUR_HOURS


  TWO_TO_FOUR_DAYS


  FIVE_OR_MORE_DAYS
}


type DeliveryLocationGroup implements Node {

  id: ID!


  locations(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: LocationSortKeys = NAME


    query: String


    includeLegacy: Boolean = false


    includeInactive: Boolean = false
  ): LocationConnection!


  locationsCount: Int!
}


type DeliveryLocationGroupZone {

  methodDefinitionCounts: DeliveryMethodDefinitionCounts!


  methodDefinitions(

    eligible: Boolean


    type: DeliveryMethodDefinitionType


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: MethodDefinitionSortKeys = ID
  ): DeliveryMethodDefinitionConnection!


  zone: DeliveryZone!
}


type DeliveryLocationGroupZoneConnection {

  edges: [DeliveryLocationGroupZoneEdge!]!


  nodes: [DeliveryLocationGroupZone!]!


  pageInfo: PageInfo!
}


type DeliveryLocationGroupZoneEdge {

  cursor: String!


  node: DeliveryLocationGroupZone!
}


input DeliveryLocationGroupZoneInput {

  id: ID


  name: String


  countries: [DeliveryCountryInput!]


  methodDefinitionsToCreate: [DeliveryMethodDefinitionInput!]


  methodDefinitionsToUpdate: [DeliveryMethodDefinitionInput!]
}


input DeliveryLocationLocalPickupEnableInput {

  locationId: ID!


  pickupTime: DeliveryLocalPickupTime!


  instructions: String
}


type DeliveryLocationLocalPickupSettingsError implements DisplayableError {

  code: DeliveryLocationLocalPickupSettingsErrorCode


  field: [String!]


  message: String!
}


enum DeliveryLocationLocalPickupSettingsErrorCode {

  ACTIVE_LOCATION_NOT_FOUND


  GENERIC_ERROR
}


type DeliveryMethod implements Node {

  brandedPromise: DeliveryBrandedPromise


  id: ID!


  maxDeliveryDateTime: DateTime


  methodType: DeliveryMethodType!


  minDeliveryDateTime: DateTime


  serviceCode: String
}


type DeliveryMethodDefinition implements Node {

  active: Boolean!


  description: String


  id: ID!


  methodConditions: [DeliveryCondition!]!


  name: String!


  rateProvider: DeliveryRateProvider!
}


type DeliveryMethodDefinitionConnection {

  edges: [DeliveryMethodDefinitionEdge!]!


  nodes: [DeliveryMethodDefinition!]!


  pageInfo: PageInfo!
}


type DeliveryMethodDefinitionCounts {

  participantDefinitionsCount: Int!


  rateDefinitionsCount: Int!
}


type DeliveryMethodDefinitionEdge {

  cursor: String!


  node: DeliveryMethodDefinition!
}


input DeliveryMethodDefinitionInput {

  id: ID


  name: String


  description: String


  active: Boolean


  rateDefinition: DeliveryRateDefinitionInput


  participant: DeliveryParticipantInput


  weightConditionsToCreate: [DeliveryWeightConditionInput!]


  priceConditionsToCreate: [DeliveryPriceConditionInput!]


  conditionsToUpdate: [DeliveryUpdateConditionInput!]
}


enum DeliveryMethodDefinitionType {

  MERCHANT


  PARTICIPANT
}


enum DeliveryMethodType {

  SHIPPING


  PICK_UP


  NONE


  RETAIL


  LOCAL
}


type DeliveryParticipant implements Node {

  adaptToNewServicesFlag: Boolean!


  carrierService: DeliveryCarrierService!


  fixedFee: MoneyV2


  id: ID!


  participantServices: [DeliveryParticipantService!]!


  percentageOfRateFee: Float!
}


input DeliveryParticipantInput {

  id: ID


  carrierServiceId: ID


  fixedFee: MoneyInput


  percentageOfRateFee: Float


  participantServices: [DeliveryParticipantServiceInput!]


  adaptToNewServices: Boolean
}


type DeliveryParticipantService {

  active: Boolean!


  name: String!
}


input DeliveryParticipantServiceInput {

  name: String!


  active: Boolean!
}


input DeliveryPriceConditionInput {

  criteria: MoneyInput


  operator: DeliveryConditionOperator
}


type DeliveryProductVariantsCount {

  capped: Boolean!


  count: Int!
}


type DeliveryProfile implements Node {

  activeMethodDefinitionsCount: Int!


  default: Boolean!


  id: ID!


  legacyMode: Boolean!


  locationsWithoutRatesCount: Int!


  name: String!


  originLocationCount: Int!


  productVariantsCount: Int! @deprecated(reason: "Use `productVariantsCountV2` instead.")


  productVariantsCountV2: DeliveryProductVariantsCount!


  profileItems(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): DeliveryProfileItemConnection!


  profileLocationGroups(

    locationGroupId: ID
  ): [DeliveryProfileLocationGroup!]!


  sellingPlanGroups(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SellingPlanGroupConnection!


  unassignedLocations: [Location!]!


  unassignedLocationsPaginated(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): LocationConnection!


  zoneCountryCount: Int!
}


type DeliveryProfileConnection {

  edges: [DeliveryProfileEdge!]!


  nodes: [DeliveryProfile!]!


  pageInfo: PageInfo!
}


type deliveryProfileCreatePayload {

  profile: DeliveryProfile


  userErrors: [UserError!]!
}


type DeliveryProfileEdge {

  cursor: String!


  node: DeliveryProfile!
}


input DeliveryProfileInput {

  name: String


  profileLocationGroups: [DeliveryProfileLocationGroupInput!]


  locationGroupsToCreate: [DeliveryProfileLocationGroupInput!]


  locationGroupsToUpdate: [DeliveryProfileLocationGroupInput!]


  locationGroupsToDelete: [ID!]


  variantsToAssociate: [ID!]


  variantsToDissociate: [ID!]


  zonesToDelete: [ID!]


  methodDefinitionsToDelete: [ID!]


  conditionsToDelete: [ID!]


  sellingPlanGroupsToAssociate: [ID!]


  sellingPlanGroupsToDissociate: [ID!]
}


type DeliveryProfileItem implements Node {

  id: ID!


  product: Product!


  variants(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ProductVariantConnection!
}


type DeliveryProfileItemConnection {

  edges: [DeliveryProfileItemEdge!]!


  nodes: [DeliveryProfileItem!]!


  pageInfo: PageInfo!
}


type DeliveryProfileItemEdge {

  cursor: String!


  node: DeliveryProfileItem!
}


type DeliveryProfileLocationGroup {

  countriesInAnyZone: [DeliveryCountryAndZone!]!


  locationGroup: DeliveryLocationGroup!


  locationGroupZones(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): DeliveryLocationGroupZoneConnection!
}


input DeliveryProfileLocationGroupInput {

  id: ID


  locations: [ID!]


  locationsToAdd: [ID!]


  locationsToRemove: [ID!]


  zonesToCreate: [DeliveryLocationGroupZoneInput!]


  zonesToUpdate: [DeliveryLocationGroupZoneInput!]
}


type deliveryProfileRemovePayload {

  job: Job


  userErrors: [UserError!]!
}


type deliveryProfileUpdatePayload {

  profile: DeliveryProfile


  userErrors: [UserError!]!
}


type DeliveryProvince implements Node {

  code: String!


  id: ID!


  name: String!


  translatedName: String!
}


input DeliveryProvinceInput {

  code: String!
}


type DeliveryRateDefinition implements Node {

  id: ID!


  price: MoneyV2!
}


input DeliveryRateDefinitionInput {

  id: ID


  price: MoneyInput!
}


union DeliveryRateProvider = DeliveryParticipant | DeliveryRateDefinition


type DeliverySetting {

  legacyModeBlocked: DeliveryLegacyModeBlocked!


  legacyModeProfiles: Boolean!
}


input DeliverySettingInput {

  legacyModeProfiles: Boolean
}


type DeliverySettingUpdatePayload {

  setting: DeliverySetting


  userErrors: [UserError!]!
}


type DeliveryShippingOriginAssignPayload {

  userErrors: [UserError!]!
}


input DeliveryUpdateConditionInput {

  id: ID!


  criteria: Float


  criteriaUnit: String


  field: DeliveryConditionField


  operator: DeliveryConditionOperator
}


input DeliveryWeightConditionInput {

  criteria: WeightInput


  operator: DeliveryConditionOperator
}


type DeliveryZone implements Node {

  countries: [DeliveryCountry!]!


  id: ID!


  name: String!
}


enum DigitalWallet {

  APPLE_PAY


  ANDROID_PAY


  GOOGLE_PAY


  SHOPIFY_PAY
}


union Discount = DiscountAutomaticApp | DiscountAutomaticBasic | DiscountAutomaticBxgy | DiscountAutomaticFreeShipping | DiscountCodeApp | DiscountCodeBasic | DiscountCodeBxgy | DiscountCodeFreeShipping


type DiscountAllocation {

  allocatedAmount: MoneyV2! @deprecated(reason: "Use `allocatedAmountSet` instead.")


  allocatedAmountSet: MoneyBag!


  discountApplication: DiscountApplication!
}


type DiscountAmount {

  amount: MoneyV2!


  appliesOnEachItem: Boolean!
}


input DiscountAmountInput {

  amount: Decimal


  appliesOnEachItem: Boolean
}


interface DiscountApplication {

  allocationMethod: DiscountApplicationAllocationMethod!


  index: Int!


  targetSelection: DiscountApplicationTargetSelection!


  targetType: DiscountApplicationTargetType!


  value: PricingValue!
}


enum DiscountApplicationAllocationMethod {

  ACROSS


  EACH


  ONE @deprecated(reason: "Use ACROSS instead.")
}


type DiscountApplicationConnection {

  edges: [DiscountApplicationEdge!]!


  nodes: [DiscountApplication!]!


  pageInfo: PageInfo!
}


type DiscountApplicationEdge {

  cursor: String!


  node: DiscountApplication!
}


enum DiscountApplicationLevel {

  ORDER


  LINE
}


enum DiscountApplicationTargetSelection {

  ALL


  ENTITLED


  EXPLICIT
}


enum DiscountApplicationTargetType {

  LINE_ITEM


  SHIPPING_LINE
}


union DiscountAutomatic = DiscountAutomaticApp | DiscountAutomaticBasic | DiscountAutomaticBxgy | DiscountAutomaticFreeShipping


type DiscountAutomaticActivatePayload {

  automaticDiscountNode: DiscountAutomaticNode


  userErrors: [DiscountUserError!]!
}


type DiscountAutomaticApp {

  appDiscountType: AppDiscountType!


  asyncUsageCount: Int!


  combinesWith: DiscountCombinesWith!


  createdAt: DateTime!


  discountClass: DiscountClass!


  discountId: ID!


  endsAt: DateTime


  errorHistory: FunctionsErrorHistory


  startsAt: DateTime!


  status: DiscountStatus!


  title: String!


  updatedAt: DateTime!
}


type DiscountAutomaticAppCreatePayload {

  automaticAppDiscount: DiscountAutomaticApp


  userErrors: [DiscountUserError!]!
}


input DiscountAutomaticAppInput {

  combinesWith: DiscountCombinesWithInput


  functionId: String


  title: String


  startsAt: DateTime


  endsAt: DateTime


  metafields: [MetafieldInput!] = []
}


type DiscountAutomaticAppUpdatePayload {

  automaticAppDiscount: DiscountAutomaticApp


  userErrors: [DiscountUserError!]!
}


type DiscountAutomaticBasic {

  asyncUsageCount: Int!


  combinesWith: DiscountCombinesWith!


  createdAt: DateTime!


  customerGets: DiscountCustomerGets!


  discountClass: MerchandiseDiscountClass!


  endsAt: DateTime


  minimumRequirement: DiscountMinimumRequirement!


  recurringCycleLimit: Int!


  shortSummary: String!


  startsAt: DateTime!


  status: DiscountStatus!


  summary: String!


  title: String!


  updatedAt: DateTime!


  usageCount: Int! @deprecated(reason: "Use `asyncUsageCount` instead.")
}


type DiscountAutomaticBasicCreatePayload {

  automaticDiscountNode: DiscountAutomaticNode


  userErrors: [DiscountUserError!]!
}


input DiscountAutomaticBasicInput {

  combinesWith: DiscountCombinesWithInput


  title: String


  startsAt: DateTime


  endsAt: DateTime


  minimumRequirement: DiscountMinimumRequirementInput


  customerGets: DiscountCustomerGetsInput


  recurringCycleLimit: Int
}


type DiscountAutomaticBasicUpdatePayload {

  automaticDiscountNode: DiscountAutomaticNode


  userErrors: [DiscountUserError!]!
}


type DiscountAutomaticBulkDeletePayload {

  job: Job


  userErrors: [DiscountUserError!]!
}


type DiscountAutomaticBxgy implements HasEvents & Node {

  asyncUsageCount: Int!


  combinesWith: DiscountCombinesWith!


  createdAt: DateTime!


  customerBuys: DiscountCustomerBuys!


  customerGets: DiscountCustomerGets!


  discountClass: MerchandiseDiscountClass!


  endsAt: DateTime


  events(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: EventSortKeys = ID


    query: String
  ): EventConnection!


  id: ID! @deprecated(reason: "Use DiscountAutomaticNode.id instead.")


  startsAt: DateTime!


  status: DiscountStatus!


  summary: String!


  title: String!


  updatedAt: DateTime!


  usageCount: Int! @deprecated(reason: "Use `asyncUsageCount` instead.")


  usesPerOrderLimit: Int
}


type DiscountAutomaticBxgyCreatePayload {

  automaticDiscountNode: DiscountAutomaticNode


  userErrors: [DiscountUserError!]!
}


input DiscountAutomaticBxgyInput {

  combinesWith: DiscountCombinesWithInput


  startsAt: DateTime


  endsAt: DateTime


  title: String


  usesPerOrderLimit: UnsignedInt64


  customerBuys: DiscountCustomerBuysInput


  customerGets: DiscountCustomerGetsInput
}


type DiscountAutomaticBxgyUpdatePayload {

  automaticDiscountNode: DiscountAutomaticNode


  userErrors: [DiscountUserError!]!
}


type DiscountAutomaticConnection {

  edges: [DiscountAutomaticEdge!]!


  nodes: [DiscountAutomatic!]!


  pageInfo: PageInfo!
}


type DiscountAutomaticDeactivatePayload {

  automaticDiscountNode: DiscountAutomaticNode


  userErrors: [DiscountUserError!]!
}


type DiscountAutomaticDeletePayload {

  deletedAutomaticDiscountId: ID


  userErrors: [DiscountUserError!]!
}


type DiscountAutomaticEdge {

  cursor: String!


  node: DiscountAutomatic!
}


type DiscountAutomaticFreeShipping {

  appliesOnOneTimePurchase: Boolean!


  appliesOnSubscription: Boolean!


  asyncUsageCount: Int!


  combinesWith: DiscountCombinesWith!


  createdAt: DateTime!


  destinationSelection: DiscountShippingDestinationSelection!


  discountClass: ShippingDiscountClass!


  endsAt: DateTime


  hasTimelineComment: Boolean!


  maximumShippingPrice: MoneyV2


  minimumRequirement: DiscountMinimumRequirement!


  recurringCycleLimit: Int!


  shortSummary: String!


  startsAt: DateTime!


  status: DiscountStatus!


  summary: String!


  title: String!


  totalSales: MoneyV2


  updatedAt: DateTime!
}


type DiscountAutomaticFreeShippingCreatePayload {

  automaticDiscountNode: DiscountAutomaticNode


  userErrors: [DiscountUserError!]!
}


input DiscountAutomaticFreeShippingInput {

  combinesWith: DiscountCombinesWithInput


  title: String


  startsAt: DateTime


  endsAt: DateTime


  minimumRequirement: DiscountMinimumRequirementInput


  destination: DiscountShippingDestinationSelectionInput


  maximumShippingPrice: Decimal


  appliesOnOneTimePurchase: Boolean = true


  appliesOnSubscription: Boolean = false


  recurringCycleLimit: Int
}


type DiscountAutomaticFreeShippingUpdatePayload {

  automaticDiscountNode: DiscountAutomaticNode


  userErrors: [DiscountUserError!]!
}


type DiscountAutomaticNode implements HasEvents & HasMetafieldDefinitions & HasMetafields & Node {

  automaticDiscount: DiscountAutomatic!


  events(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: EventSortKeys = ID


    query: String
  ): EventConnection!


  id: ID!


  metafield(

    namespace: String


    key: String!
  ): Metafield


  metafieldDefinitions(

    namespace: String


    pinnedStatus: MetafieldDefinitionPinnedStatus = ANY


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: MetafieldDefinitionSortKeys = ID


    query: String
  ): MetafieldDefinitionConnection!


  metafields(

    namespace: String


    keys: [String!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  privateMetafield(

    namespace: String!


    key: String!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")
}


type DiscountAutomaticNodeConnection {

  edges: [DiscountAutomaticNodeEdge!]!


  nodes: [DiscountAutomaticNode!]!


  pageInfo: PageInfo!
}


type DiscountAutomaticNodeEdge {

  cursor: String!


  node: DiscountAutomaticNode!
}


enum DiscountClass {

  PRODUCT


  ORDER


  SHIPPING
}


union DiscountCode = DiscountCodeApp | DiscountCodeBasic | DiscountCodeBxgy | DiscountCodeFreeShipping


type DiscountCodeActivatePayload {

  codeDiscountNode: DiscountCodeNode


  userErrors: [DiscountUserError!]!
}


type DiscountCodeApp {

  appDiscountType: AppDiscountType!


  appliesOncePerCustomer: Boolean!


  asyncUsageCount: Int!


  codeCount: Int!


  codes(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: DiscountCodeSortKeys = ID


    query: String


    savedSearchId: ID
  ): DiscountRedeemCodeConnection!


  combinesWith: DiscountCombinesWith!


  createdAt: DateTime!


  customerSelection: DiscountCustomerSelection!


  discountClass: DiscountClass!


  discountId: ID!


  endsAt: DateTime


  errorHistory: FunctionsErrorHistory


  hasTimelineComment: Boolean!


  recurringCycleLimit: Int


  shareableUrls: [DiscountShareableUrl!]!


  startsAt: DateTime!


  status: DiscountStatus!


  title: String!


  totalSales: MoneyV2


  updatedAt: DateTime!


  usageLimit: Int
}


type DiscountCodeAppCreatePayload {

  codeAppDiscount: DiscountCodeApp


  userErrors: [DiscountUserError!]!
}


input DiscountCodeAppInput {

  combinesWith: DiscountCombinesWithInput


  functionId: String


  title: String


  startsAt: DateTime


  endsAt: DateTime


  usageLimit: Int


  appliesOncePerCustomer: Boolean


  customerSelection: DiscountCustomerSelectionInput


  code: String


  metafields: [MetafieldInput!] = []
}


type DiscountCodeApplication implements DiscountApplication {

  allocationMethod: DiscountApplicationAllocationMethod!


  code: String!


  index: Int!


  targetSelection: DiscountApplicationTargetSelection!


  targetType: DiscountApplicationTargetType!


  value: PricingValue!
}


type DiscountCodeAppUpdatePayload {

  codeAppDiscount: DiscountCodeApp


  userErrors: [DiscountUserError!]!
}


type DiscountCodeBasic {

  appliesOncePerCustomer: Boolean!


  asyncUsageCount: Int!


  codeCount: Int!


  codes(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: DiscountCodeSortKeys = ID


    query: String


    savedSearchId: ID
  ): DiscountRedeemCodeConnection!


  combinesWith: DiscountCombinesWith!


  createdAt: DateTime!


  customerGets: DiscountCustomerGets!


  customerSelection: DiscountCustomerSelection!


  discountClass: MerchandiseDiscountClass!


  endsAt: DateTime


  hasTimelineComment: Boolean!


  minimumRequirement: DiscountMinimumRequirement


  recurringCycleLimit: Int


  shareableUrls: [DiscountShareableUrl!]!


  shortSummary: String!


  startsAt: DateTime!


  status: DiscountStatus!


  summary: String!


  title: String!


  totalSales: MoneyV2


  updatedAt: DateTime!


  usageLimit: Int
}


type DiscountCodeBasicCreatePayload {

  codeDiscountNode: DiscountCodeNode


  userErrors: [DiscountUserError!]!
}


input DiscountCodeBasicInput {

  combinesWith: DiscountCombinesWithInput


  title: String


  startsAt: DateTime


  endsAt: DateTime


  usageLimit: Int


  appliesOncePerCustomer: Boolean


  minimumRequirement: DiscountMinimumRequirementInput


  customerGets: DiscountCustomerGetsInput


  customerSelection: DiscountCustomerSelectionInput


  code: String


  recurringCycleLimit: Int
}


type DiscountCodeBasicUpdatePayload {

  codeDiscountNode: DiscountCodeNode


  userErrors: [DiscountUserError!]!
}


type DiscountCodeBulkActivatePayload {

  job: Job


  userErrors: [DiscountUserError!]!
}


type DiscountCodeBulkDeactivatePayload {

  job: Job


  userErrors: [DiscountUserError!]!
}


type DiscountCodeBulkDeletePayload {

  job: Job


  userErrors: [DiscountUserError!]!
}


type DiscountCodeBxgy {

  appliesOncePerCustomer: Boolean!


  asyncUsageCount: Int!


  codeCount: Int!


  codes(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: DiscountCodeSortKeys = ID


    query: String


    savedSearchId: ID
  ): DiscountRedeemCodeConnection!


  combinesWith: DiscountCombinesWith!


  createdAt: DateTime!


  customerBuys: DiscountCustomerBuys!


  customerGets: DiscountCustomerGets!


  customerSelection: DiscountCustomerSelection!


  discountClass: MerchandiseDiscountClass!


  endsAt: DateTime


  hasTimelineComment: Boolean!


  shareableUrls: [DiscountShareableUrl!]!


  startsAt: DateTime!


  status: DiscountStatus!


  summary: String!


  title: String!


  totalSales: MoneyV2


  updatedAt: DateTime!


  usageLimit: Int


  usesPerOrderLimit: Int
}


type DiscountCodeBxgyCreatePayload {

  codeDiscountNode: DiscountCodeNode


  userErrors: [DiscountUserError!]!
}


input DiscountCodeBxgyInput {

  combinesWith: DiscountCombinesWithInput


  title: String


  startsAt: DateTime


  endsAt: DateTime


  customerBuys: DiscountCustomerBuysInput


  customerGets: DiscountCustomerGetsInput


  customerSelection: DiscountCustomerSelectionInput


  code: String


  usageLimit: Int


  usesPerOrderLimit: Int


  appliesOncePerCustomer: Boolean
}


type DiscountCodeBxgyUpdatePayload {

  codeDiscountNode: DiscountCodeNode


  userErrors: [DiscountUserError!]!
}


type DiscountCodeDeactivatePayload {

  codeDiscountNode: DiscountCodeNode


  userErrors: [DiscountUserError!]!
}


type DiscountCodeDeletePayload {

  deletedCodeDiscountId: ID


  userErrors: [DiscountUserError!]!
}


type DiscountCodeFreeShipping {

  appliesOnOneTimePurchase: Boolean!


  appliesOnSubscription: Boolean!


  appliesOncePerCustomer: Boolean!


  asyncUsageCount: Int!


  codeCount: Int!


  codes(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: DiscountCodeSortKeys = ID


    query: String


    savedSearchId: ID
  ): DiscountRedeemCodeConnection!


  combinesWith: DiscountCombinesWith!


  createdAt: DateTime!


  customerSelection: DiscountCustomerSelection!


  destinationSelection: DiscountShippingDestinationSelection!


  discountClass: ShippingDiscountClass!


  endsAt: DateTime


  hasTimelineComment: Boolean!


  maximumShippingPrice: MoneyV2


  minimumRequirement: DiscountMinimumRequirement


  recurringCycleLimit: Int


  shareableUrls: [DiscountShareableUrl!]!


  shortSummary: String!


  startsAt: DateTime!


  status: DiscountStatus!


  summary: String!


  title: String!


  totalSales: MoneyV2


  updatedAt: DateTime!


  usageLimit: Int
}


type DiscountCodeFreeShippingCreatePayload {

  codeDiscountNode: DiscountCodeNode


  userErrors: [DiscountUserError!]!
}


input DiscountCodeFreeShippingInput {

  combinesWith: DiscountCombinesWithInput


  title: String


  startsAt: DateTime


  endsAt: DateTime


  code: String


  usageLimit: Int


  appliesOncePerCustomer: Boolean


  minimumRequirement: DiscountMinimumRequirementInput


  customerSelection: DiscountCustomerSelectionInput


  destination: DiscountShippingDestinationSelectionInput


  maximumShippingPrice: Decimal


  recurringCycleLimit: Int


  appliesOnOneTimePurchase: Boolean


  appliesOnSubscription: Boolean
}


type DiscountCodeFreeShippingUpdatePayload {

  codeDiscountNode: DiscountCodeNode


  userErrors: [DiscountUserError!]!
}


type DiscountCodeNode implements HasEvents & HasMetafieldDefinitions & HasMetafields & Node {

  codeDiscount: DiscountCode!


  events(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: EventSortKeys = ID


    query: String
  ): EventConnection!


  id: ID!


  metafield(

    namespace: String


    key: String!
  ): Metafield


  metafieldDefinitions(

    namespace: String


    pinnedStatus: MetafieldDefinitionPinnedStatus = ANY


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: MetafieldDefinitionSortKeys = ID


    query: String
  ): MetafieldDefinitionConnection!


  metafields(

    namespace: String


    keys: [String!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  privateMetafield(

    namespace: String!


    key: String!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")
}


type DiscountCodeNodeConnection {

  edges: [DiscountCodeNodeEdge!]!


  nodes: [DiscountCodeNode!]!


  pageInfo: PageInfo!
}


type DiscountCodeNodeEdge {

  cursor: String!


  node: DiscountCodeNode!
}


type DiscountCodeRedeemCodeBulkDeletePayload {

  job: Job


  userErrors: [DiscountUserError!]!
}


enum DiscountCodeSortKeys {

  CODE


  CREATED_AT


  ID


  RELEVANCE
}


type DiscountCollections {

  collections(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): CollectionConnection!
}


input DiscountCollectionsInput {

  add: [ID!]


  remove: [ID!]
}


type DiscountCombinesWith {

  orderDiscounts: Boolean!


  productDiscounts: Boolean!


  shippingDiscounts: Boolean!
}


input DiscountCombinesWithInput {

  productDiscounts: Boolean = false


  orderDiscounts: Boolean = false


  shippingDiscounts: Boolean = false
}


type DiscountCountries {

  countries: [CountryCode!]!


  includeRestOfWorld: Boolean!
}


input DiscountCountriesInput {

  add: [CountryCode!]


  remove: [CountryCode!]


  includeRestOfWorld: Boolean = false
}


type DiscountCountryAll {

  allCountries: Boolean!
}


type DiscountCustomerAll {

  allCustomers: Boolean!
}


type DiscountCustomerBuys {

  items: DiscountItems!


  value: DiscountCustomerBuysValue!
}


input DiscountCustomerBuysInput {

  value: DiscountCustomerBuysValueInput


  items: DiscountItemsInput
}


union DiscountCustomerBuysValue = DiscountPurchaseAmount | DiscountQuantity


input DiscountCustomerBuysValueInput {

  quantity: UnsignedInt64


  amount: Decimal
}


type DiscountCustomerGets {

  appliesOnOneTimePurchase: Boolean!


  appliesOnSubscription: Boolean!


  items: DiscountItems!


  value: DiscountCustomerGetsValue!
}


input DiscountCustomerGetsInput {

  value: DiscountCustomerGetsValueInput


  items: DiscountItemsInput


  appliesOnOneTimePurchase: Boolean


  appliesOnSubscription: Boolean
}


union DiscountCustomerGetsValue = DiscountAmount | DiscountOnQuantity | DiscountPercentage


input DiscountCustomerGetsValueInput {

  discountOnQuantity: DiscountOnQuantityInput


  percentage: Float


  discountAmount: DiscountAmountInput
}


type DiscountCustomers {

  customers: [Customer!]!
}


type DiscountCustomerSegments {

  segments: [Segment!]!
}


input DiscountCustomerSegmentsInput {

  add: [ID!]


  remove: [ID!]
}


union DiscountCustomerSelection = DiscountCustomerAll | DiscountCustomerSegments | DiscountCustomers


input DiscountCustomerSelectionInput {

  all: Boolean


  customers: DiscountCustomersInput


  customerSegments: DiscountCustomerSegmentsInput
}


input DiscountCustomersInput {

  add: [ID!]


  remove: [ID!]
}


union DiscountEffect = DiscountAmount | DiscountPercentage


input DiscountEffectInput {

  percentage: Float


  amount: Decimal
}


enum DiscountErrorCode {

  BLANK


  PRESENT


  EQUAL_TO


  GREATER_THAN


  GREATER_THAN_OR_EQUAL_TO


  INVALID


  LESS_THAN_OR_EQUAL_TO


  LESS_THAN


  TAKEN


  TOO_LONG


  TOO_SHORT


  INTERNAL_ERROR


  TOO_MANY_ARGUMENTS


  MISSING_ARGUMENT


  ACTIVE_PERIOD_OVERLAP


  EXCEEDED_MAX


  MINIMUM_SUBTOTAL_AND_QUANTITY_RANGE_BOTH_PRESENT


  VALUE_OUTSIDE_RANGE


  CONFLICT


  IMPLICIT_DUPLICATE


  DUPLICATE


  INCLUSION


  INVALID_COMBINES_WITH_FOR_DISCOUNT_CLASS


  INVALID_DISCOUNT_CLASS_FOR_PRICE_RULE


  MAX_APP_DISCOUNTS
}


union DiscountItems = AllDiscountItems | DiscountCollections | DiscountProducts


input DiscountItemsInput {

  products: DiscountProductsInput


  collections: DiscountCollectionsInput


  all: Boolean
}


type DiscountMinimumQuantity {

  greaterThanOrEqualToQuantity: UnsignedInt64!
}


input DiscountMinimumQuantityInput {

  greaterThanOrEqualToQuantity: UnsignedInt64
}


union DiscountMinimumRequirement = DiscountMinimumQuantity | DiscountMinimumSubtotal


input DiscountMinimumRequirementInput {

  quantity: DiscountMinimumQuantityInput


  subtotal: DiscountMinimumSubtotalInput
}


type DiscountMinimumSubtotal {

  greaterThanOrEqualToSubtotal: MoneyV2!
}


input DiscountMinimumSubtotalInput {

  greaterThanOrEqualToSubtotal: Decimal
}


type DiscountNode implements HasEvents & HasMetafieldDefinitions & HasMetafields & Node {

  discount: Discount!


  events(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: EventSortKeys = ID


    query: String
  ): EventConnection!


  id: ID!


  metafield(

    namespace: String


    key: String!
  ): Metafield


  metafieldDefinitions(

    namespace: String


    pinnedStatus: MetafieldDefinitionPinnedStatus = ANY


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: MetafieldDefinitionSortKeys = ID


    query: String
  ): MetafieldDefinitionConnection!


  metafields(

    namespace: String


    keys: [String!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  privateMetafield(

    namespace: String!


    key: String!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")
}


type DiscountNodeConnection {

  edges: [DiscountNodeEdge!]!


  nodes: [DiscountNode!]!


  pageInfo: PageInfo!
}


type DiscountNodeEdge {

  cursor: String!


  node: DiscountNode!
}


type DiscountOnQuantity {

  effect: DiscountEffect!


  quantity: DiscountQuantity!
}


input DiscountOnQuantityInput {

  quantity: UnsignedInt64


  effect: DiscountEffectInput
}


type DiscountPercentage {

  percentage: Float!
}


type DiscountProducts {

  productVariants(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ProductVariantConnection!


  products(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ProductConnection!
}


input DiscountProductsInput {

  productsToAdd: [ID!]


  productsToRemove: [ID!]


  productVariantsToAdd: [ID!]


  productVariantsToRemove: [ID!]
}


type DiscountPurchaseAmount {

  amount: Decimal!
}


type DiscountQuantity {

  quantity: UnsignedInt64!
}


type DiscountRedeemCode {

  asyncUsageCount: Int!


  code: String!


  createdBy: App


  id: ID!
}


type DiscountRedeemCodeBulkAddPayload {

  bulkCreation: DiscountRedeemCodeBulkCreation


  userErrors: [DiscountUserError!]!
}


type DiscountRedeemCodeBulkCreation implements Node {

  codes(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): DiscountRedeemCodeBulkCreationCodeConnection!


  codesCount: Int!


  createdAt: DateTime!


  discountCode: DiscountCodeNode


  done: Boolean!


  failedCount: Int!


  id: ID!


  importedCount: Int!
}


type DiscountRedeemCodeBulkCreationCode {

  code: String!


  discountRedeemCode: DiscountRedeemCode


  errors: [DiscountUserError!]!
}


type DiscountRedeemCodeBulkCreationCodeConnection {

  edges: [DiscountRedeemCodeBulkCreationCodeEdge!]!


  nodes: [DiscountRedeemCodeBulkCreationCode!]!


  pageInfo: PageInfo!
}


type DiscountRedeemCodeBulkCreationCodeEdge {

  cursor: String!


  node: DiscountRedeemCodeBulkCreationCode!
}


type DiscountRedeemCodeConnection {

  edges: [DiscountRedeemCodeEdge!]!


  nodes: [DiscountRedeemCode!]!


  pageInfo: PageInfo!
}


type DiscountRedeemCodeEdge {

  cursor: String!


  node: DiscountRedeemCode!
}


input DiscountRedeemCodeInput {

  code: String!
}


type DiscountShareableUrl {

  targetItemImage: Image


  targetType: DiscountShareableUrlTargetType!


  title: String!


  url: URL!
}


enum DiscountShareableUrlTargetType {

  HOME


  PRODUCT


  COLLECTION
}


union DiscountShippingDestinationSelection = DiscountCountries | DiscountCountryAll


input DiscountShippingDestinationSelectionInput {

  all: Boolean = false


  countries: DiscountCountriesInput
}


enum DiscountSortKeys {

  STARTS_AT


  ENDS_AT


  TITLE


  CREATED_AT


  UPDATED_AT


  ID


  RELEVANCE
}


enum DiscountStatus {

  ACTIVE


  EXPIRED


  SCHEDULED
}


enum DiscountTargetType {

  LINE_ITEM


  SHIPPING_LINE
}


enum DiscountType {

  MANUAL


  CODE_DISCOUNT


  AUTOMATIC_DISCOUNT
}


type DiscountUserError implements DisplayableError {

  code: DiscountErrorCode


  extraInfo: String


  field: [String!]


  message: String!
}


interface DisplayableError {

  field: [String!]


  message: String!
}


type DisputeEvidenceUpdatePayload {

  disputeEvidence: ShopifyPaymentsDisputeEvidence


  userErrors: [DisputeEvidenceUpdateUserError!]!
}


type DisputeEvidenceUpdateUserError implements DisplayableError {

  code: DisputeEvidenceUpdateUserErrorCode


  field: [String!]


  message: String!
}


enum DisputeEvidenceUpdateUserErrorCode {

  DISPUTE_EVIDENCE_NOT_FOUND


  EVIDENCE_ALREADY_ACCEPTED


  EVIDENCE_PAST_DUE_DATE


  FILES_SIZE_EXCEEDED_LIMIT


  TOO_LARGE


  INVALID
}


enum DisputeStatus {
  ACCEPTED
  LOST
  NEEDS_RESPONSE
  UNDER_REVIEW
  WON


  CHARGE_REFUNDED @deprecated(reason: "CHARGE_REFUNDED is no longer supported.")
}


enum DisputeType {

  CHARGEBACK


  INQUIRY
}


type Domain implements Node {

  host: String!


  id: ID!


  localization: DomainLocalization


  marketWebPresence: MarketWebPresence


  sslEnabled: Boolean!


  url: URL!
}


type DomainLocalization {

  alternateLocales: [String!]!


  country: String


  defaultLocale: String!
}


type DraftOrder implements CommentEventSubject & HasEvents & HasLocalizationExtensions & HasMetafields & LegacyInteroperability & Navigable & Node {

  appliedDiscount: DraftOrderAppliedDiscount


  billingAddress: MailingAddress


  billingAddressMatchesShippingAddress: Boolean!


  completedAt: DateTime


  createdAt: DateTime!


  currencyCode: CurrencyCode!


  customAttributes: [Attribute!]!


  customer: Customer


  defaultCursor: String!


  email: String


  events(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: EventSortKeys = ID


    query: String
  ): EventConnection!


  hasTimelineComment: Boolean!


  id: ID!


  invoiceEmailTemplateSubject: String!


  invoiceSentAt: DateTime


  invoiceUrl: URL


  legacyResourceId: UnsignedInt64!


  lineItems(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): DraftOrderLineItemConnection!


  lineItemsSubtotalPrice: MoneyBag!


  localizationExtensions(

    countryCodes: [CountryCode!]


    purposes: [LocalizationExtensionPurpose!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): LocalizationExtensionConnection!


  marketName: String!


  marketRegionCountryCode: CountryCode!


  metafield(

    namespace: String


    key: String!
  ): Metafield


  metafields(

    namespace: String


    keys: [String!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  name: String!


  note2: String


  order: Order


  paymentTerms: PaymentTerms


  phone: String


  poNumber: String


  presentmentCurrencyCode: CurrencyCode!


  privateMetafield(

    namespace: String!


    key: String!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  purchasingEntity: PurchasingEntity


  ready: Boolean!


  reserveInventoryUntil: DateTime


  shippingAddress: MailingAddress


  shippingLine: ShippingLine


  status: DraftOrderStatus!


  subtotalPrice: Money!


  subtotalPriceSet: MoneyBag!


  tags: [String!]!


  taxExempt: Boolean!


  taxLines: [TaxLine!]!


  taxesIncluded: Boolean!


  totalDiscountsSet: MoneyBag!


  totalLineItemsPriceSet: MoneyBag!


  totalPrice: Money!


  totalPriceSet: MoneyBag!


  totalShippingPrice: Money!


  totalShippingPriceSet: MoneyBag!


  totalTax: Money!


  totalTaxSet: MoneyBag!


  totalWeight: UnsignedInt64!


  updatedAt: DateTime!


  visibleToCustomer: Boolean!
}


type DraftOrderAppliedDiscount {

  amount: Money! @deprecated(reason: "Use `amountV2` instead.")


  amountSet: MoneyBag!


  amountV2: MoneyV2!


  description: String!


  title: String


  value: Float!


  valueType: DraftOrderAppliedDiscountType!
}


input DraftOrderAppliedDiscountInput {

  amount: Money


  description: String


  title: String


  value: Float!


  valueType: DraftOrderAppliedDiscountType!
}


enum DraftOrderAppliedDiscountType {

  FIXED_AMOUNT


  PERCENTAGE
}


type DraftOrderBulkAddTagsPayload {

  job: Job


  userErrors: [UserError!]!
}


type DraftOrderBulkDeletePayload {

  job: Job


  userErrors: [UserError!]!
}


type DraftOrderBulkRemoveTagsPayload {

  job: Job


  userErrors: [UserError!]!
}


type DraftOrderCalculatePayload {

  calculatedDraftOrder: CalculatedDraftOrder


  userErrors: [UserError!]!
}


type DraftOrderCompletePayload {

  draftOrder: DraftOrder


  userErrors: [UserError!]!
}


type DraftOrderConnection {

  edges: [DraftOrderEdge!]!


  nodes: [DraftOrder!]!


  pageInfo: PageInfo!
}


type DraftOrderCreateFromOrderPayload {

  draftOrder: DraftOrder


  userErrors: [UserError!]!
}


type DraftOrderCreateMerchantCheckoutPayload {

  userErrors: [UserError!]!
}


type DraftOrderCreatePayload {

  draftOrder: DraftOrder


  userErrors: [UserError!]!
}


input DraftOrderDeleteInput {

  id: ID!
}


type DraftOrderDeletePayload {

  deletedId: ID


  userErrors: [UserError!]!
}


type DraftOrderDuplicatePayload {

  draftOrder: DraftOrder


  userErrors: [UserError!]!
}


type DraftOrderEdge {

  cursor: String!


  node: DraftOrder!
}


input DraftOrderInput {

  appliedDiscount: DraftOrderAppliedDiscountInput


  billingAddress: MailingAddressInput


  customAttributes: [AttributeInput!]


  email: String


  lineItems: [DraftOrderLineItemInput!]


  metafields: [MetafieldInput!]


  localizationExtensions: [LocalizationExtensionInput!]


  note: String


  shippingAddress: MailingAddressInput


  shippingLine: ShippingLineInput


  tags: [String!]


  taxExempt: Boolean


  useCustomerDefaultAddress: Boolean


  visibleToCustomer: Boolean


  reserveInventoryUntil: DateTime


  presentmentCurrencyCode: CurrencyCode


  marketRegionCountryCode: CountryCode


  phone: String


  paymentTerms: PaymentTermsInput


  purchasingEntity: PurchasingEntityInput


  sourceName: String


  poNumber: String
}


type DraftOrderInvoicePreviewPayload {

  previewHtml: HTML


  previewSubject: HTML


  userErrors: [UserError!]!
}


type DraftOrderInvoiceSendPayload {

  draftOrder: DraftOrder


  userErrors: [UserError!]!
}


type DraftOrderLineItem implements Node {

  appliedDiscount: DraftOrderAppliedDiscount


  custom: Boolean!


  customAttributes: [Attribute!]!


  customAttributesV2: [TypedAttribute!]!


  discountedTotal: Money!


  discountedTotalSet: MoneyBag!


  discountedUnitPrice: Money!


  discountedUnitPriceSet: MoneyBag!


  fulfillmentService: FulfillmentService


  grams: Int @deprecated(reason: "Use `weight` instead.")


  id: ID!


  image: Image


  isGiftCard: Boolean!


  name: String!


  originalTotal: Money!


  originalTotalSet: MoneyBag!


  originalUnitPrice: Money!


  originalUnitPriceSet: MoneyBag!


  product: Product


  quantity: Int!


  requiresShipping: Boolean!


  sku: String


  taxLines: [TaxLine!]!


  taxable: Boolean!


  title: String!


  totalDiscount: Money!


  totalDiscountSet: MoneyBag!


  variant: ProductVariant


  variantTitle: String


  vendor: String


  weight: Weight
}


type DraftOrderLineItemConnection {

  edges: [DraftOrderLineItemEdge!]!


  nodes: [DraftOrderLineItem!]!


  pageInfo: PageInfo!
}


type DraftOrderLineItemEdge {

  cursor: String!


  node: DraftOrderLineItem!
}


input DraftOrderLineItemInput {

  appliedDiscount: DraftOrderAppliedDiscountInput


  customAttributes: [AttributeInput!]


  originalUnitPrice: Money


  quantity: Int!


  requiresShipping: Boolean


  sku: String


  taxable: Boolean


  title: String


  variantId: ID


  weight: WeightInput
}


enum DraftOrderSortKeys {

  NUMBER


  UPDATED_AT


  STATUS


  TOTAL_PRICE


  CUSTOMER_NAME


  ID


  RELEVANCE
}


enum DraftOrderStatus {

  COMPLETED


  INVOICE_SENT


  OPEN
}


type DraftOrderTag implements Node {

  handle: String!


  id: ID!


  title: String!
}


type DraftOrderUpdatePayload {

  draftOrder: DraftOrder


  userErrors: [UserError!]!
}


type Duty implements Node {

  countryCodeOfOrigin: CountryCode


  harmonizedSystemCode: String


  id: ID!


  price: MoneyBag!


  taxLines: [TaxLine!]!
}


type DutySale implements Sale {

  actionType: SaleActionType!


  duty: Duty!


  id: ID!


  lineType: SaleLineType!


  quantity: Int


  taxes: [SaleTax!]!


  totalAmount: MoneyBag!


  totalDiscountAmountAfterTaxes: MoneyBag!


  totalDiscountAmountBeforeTaxes: MoneyBag!


  totalTaxAmount: MoneyBag!
}


type EditableProperty {

  locked: Boolean!


  reason: FormattedString
}


input EmailInput {

  subject: String


  to: String


  from: String


  body: String


  bcc: [String!]


  customMessage: String
}


type ErrorPosition {

  character: Int!


  line: Int!
}


type ErrorsServerPixelUserError implements DisplayableError {

  code: ErrorsServerPixelUserErrorCode


  field: [String!]


  message: String!
}


enum ErrorsServerPixelUserErrorCode {

  NOT_FOUND


  ALREADY_EXISTS


  PUB_SUB_ERROR


  NEEDS_CONFIGURATION_TO_CONNECT
}


type ErrorsWebPixelUserError implements DisplayableError {

  code: ErrorsWebPixelUserErrorCode


  field: [String!]


  message: String!
}


enum ErrorsWebPixelUserErrorCode {

  BLANK


  TAKEN


  NOT_FOUND


  INVALID_SETTINGS


  UNABLE_TO_DELETE
}


interface Event {

  appTitle: String


  attributeToApp: Boolean!


  attributeToUser: Boolean!


  createdAt: DateTime!


  criticalAlert: Boolean!


  id: ID!


  message: FormattedString!
}


type EventBridgeServerPixelUpdatePayload {

  serverPixel: ServerPixel


  userErrors: [ErrorsServerPixelUserError!]!
}


type EventBridgeWebhookSubscriptionCreatePayload {

  userErrors: [UserError!]!


  webhookSubscription: WebhookSubscription
}


input EventBridgeWebhookSubscriptionInput {

  arn: ARN


  format: WebhookSubscriptionFormat


  includeFields: [String!]


  metafieldNamespaces: [String!]
}


type EventBridgeWebhookSubscriptionUpdatePayload {

  userErrors: [UserError!]!


  webhookSubscription: WebhookSubscription
}


type EventConnection {

  edges: [EventEdge!]!


  nodes: [Event!]!


  pageInfo: PageInfo!
}


type EventEdge {

  cursor: String!


  node: Event!
}


enum EventSortKeys {

  CREATED_AT


  ID


  RELEVANCE
}


type ExchangeV2 implements Node {

  additions: ExchangeV2Additions!


  completedAt: DateTime


  createdAt: DateTime!


  id: ID!


  location: Location


  note: String


  refunds: [Refund!]!


  returns: ExchangeV2Returns!


  staffMember: StaffMember


  totalAmountProcessedSet: MoneyBag!


  totalPriceSet: MoneyBag!


  transactions: [OrderTransaction!]!
}


type ExchangeV2Additions {

  lineItems: [ExchangeV2LineItem!]!


  subtotalPriceSet: MoneyBag!


  taxLines: [TaxLine!]!


  totalPriceSet: MoneyBag!
}


type ExchangeV2Connection {

  edges: [ExchangeV2Edge!]!


  nodes: [ExchangeV2!]!


  pageInfo: PageInfo!
}


type ExchangeV2Edge {

  cursor: String!


  node: ExchangeV2!
}


type ExchangeV2LineItem {

  customAttributes: [Attribute!]!


  discountedTotalSet: MoneyBag!


  discountedUnitPriceSet: MoneyBag!


  fulfillmentService: FulfillmentService


  giftCard: Boolean!


  giftCards: [GiftCard!]!


  lineItem: LineItem


  name: String!


  originalTotalSet: MoneyBag!


  originalUnitPriceSet: MoneyBag!


  quantity: Int!


  requiresShipping: Boolean!


  sku: String


  taxLines: [TaxLine!]!


  taxable: Boolean!


  title: String!


  variant: ProductVariant


  variantTitle: String


  vendor: String
}


type ExchangeV2Returns {

  lineItems: [ExchangeV2LineItem!]!


  orderDiscountAmountSet: MoneyBag!


  shippingRefundAmountSet: MoneyBag!


  subtotalPriceSet: MoneyBag!


  taxLines: [TaxLine!]!


  tipRefundAmountSet: MoneyBag!


  totalPriceSet: MoneyBag!
}


type ExternalVideo implements Media & Node {

  alt: String


  embedUrl: URL!


  embeddedUrl: URL! @deprecated(reason: "Use `originUrl` instead.")


  host: MediaHost!


  id: ID!


  mediaContentType: MediaContentType!


  mediaErrors: [MediaError!]!


  mediaWarnings: [MediaWarning!]!


  originUrl: URL!


  preview: MediaPreviewImage


  status: MediaStatus!
}


type FailedRequirement {

  action: NavigationItem


  message: String!
}


interface File {

  alt: String


  createdAt: DateTime!


  fileErrors: [FileError!]!


  fileStatus: FileStatus!


  id: ID!


  preview: MediaPreviewImage


  updatedAt: DateTime!
}


type FileAcknowledgeUpdateFailedPayload {

  files: [File!]


  userErrors: [FilesUserError!]!
}


type FileConnection {

  edges: [FileEdge!]!


  nodes: [File!]!


  pageInfo: PageInfo!
}


enum FileContentType {

  IMAGE


  FILE


  VIDEO
}


input FileCreateInput {

  filename: String


  originalSource: String!


  contentType: FileContentType


  alt: String


  duplicateResolutionMode: FileCreateInputDuplicateResolutionMode = APPEND_UUID
}


enum FileCreateInputDuplicateResolutionMode {

  APPEND_UUID


  RAISE_ERROR


  REPLACE
}


type FileCreatePayload {

  files: [File!]


  userErrors: [FilesUserError!]!
}


type FileDeletePayload {

  deletedFileIds: [ID!]


  userErrors: [FilesUserError!]!
}


type FileEdge {

  cursor: String!


  node: File!
}


type FileError {

  code: FileErrorCode!


  details: String


  message: String!
}


enum FileErrorCode {

  UNKNOWN


  INVALID_SIGNED_URL


  IMAGE_DOWNLOAD_FAILURE


  IMAGE_PROCESSING_FAILURE


  MEDIA_TIMEOUT_ERROR


  EXTERNAL_VIDEO_NOT_FOUND


  EXTERNAL_VIDEO_UNLISTED


  EXTERNAL_VIDEO_INVALID_ASPECT_RATIO


  EXTERNAL_VIDEO_EMBED_DISABLED


  EXTERNAL_VIDEO_EMBED_NOT_FOUND_OR_TRANSCODING


  GENERIC_FILE_DOWNLOAD_FAILURE


  GENERIC_FILE_INVALID_SIZE


  VIDEO_METADATA_READ_ERROR


  VIDEO_INVALID_FILETYPE_ERROR


  VIDEO_MIN_WIDTH_ERROR


  VIDEO_MAX_WIDTH_ERROR


  VIDEO_MIN_HEIGHT_ERROR


  VIDEO_MAX_HEIGHT_ERROR


  VIDEO_MIN_DURATION_ERROR


  VIDEO_MAX_DURATION_ERROR


  VIDEO_VALIDATION_ERROR


  MODEL3D_VALIDATION_ERROR


  MODEL3D_THUMBNAIL_GENERATION_ERROR


  MODEL3D_THUMBNAIL_REGENERATION_ERROR


  MODEL3D_GLB_TO_USDZ_CONVERSION_ERROR


  MODEL3D_GLB_OUTPUT_CREATION_ERROR


  MODEL3D_PROCESSING_FAILURE


  UNSUPPORTED_IMAGE_FILE_TYPE


  INVALID_IMAGE_FILE_SIZE


  INVALID_IMAGE_ASPECT_RATIO


  INVALID_IMAGE_RESOLUTION


  FILE_STORAGE_LIMIT_EXCEEDED


  DUPLICATE_FILENAME_ERROR
}


enum FilesErrorCode {

  INVALID


  FILE_DOES_NOT_EXIST


  FILE_LOCKED


  UNSUPPORTED_MEDIA_TYPE_FOR_FILENAME_UPDATE


  TOO_MANY_ARGUMENTS


  BLANK_SEARCH


  MISSING_ARGUMENTS


  INVALID_QUERY


  INVALID_FILENAME_EXTENSION


  INVALID_FILENAME


  FILENAME_ALREADY_EXISTS


  UNACCEPTABLE_UNVERIFIED_TRIAL_ASSET


  UNACCEPTABLE_ASSET


  UNACCEPTABLE_TRIAL_ASSET


  ALT_VALUE_LIMIT_EXCEEDED


  NON_READY_STATE


  NON_IMAGE_MEDIA_PER_SHOP_LIMIT_EXCEEDED


  MISMATCHED_FILENAME_AND_ORIGINAL_SOURCE


  INVALID_DUPLICATE_MODE_FOR_TYPE


  INVALID_IMAGE_SOURCE_URL


  MISSING_FILENAME_FOR_DUPLICATE_MODE_REPLACE
}


enum FileSortKeys {

  FILENAME


  ORIGINAL_UPLOAD_SIZE


  CREATED_AT


  UPDATED_AT


  ID


  RELEVANCE
}


enum FileStatus {

  UPLOADED


  PROCESSING


  READY


  FAILED
}


type FilesUserError implements DisplayableError {

  code: FilesErrorCode


  field: [String!]


  message: String!
}


input FileUpdateInput {

  id: ID!


  alt: String


  originalSource: String


  previewImageSource: String


  filename: String
}


type FileUpdatePayload {

  files: [File!]


  userErrors: [FilesUserError!]!
}


type FilterOption {

  label: String!


  value: String!
}


type FinancialSummaryDiscountAllocation {

  approximateAllocatedAmountPerItem: MoneyBag!


  discountApplication: FinancialSummaryDiscountApplication!
}


type FinancialSummaryDiscountApplication {

  allocationMethod: DiscountApplicationAllocationMethod!


  targetSelection: DiscountApplicationTargetSelection!


  targetType: DiscountApplicationTargetType!
}


type FlowGenerateSignaturePayload {

  payload: String


  signature: String


  userErrors: [UserError!]!
}


type FlowTriggerReceivePayload {

  userErrors: [UserError!]!
}


scalar FormattedString


type Fulfillment implements LegacyInteroperability & Node {

  createdAt: DateTime!


  deliveredAt: DateTime


  displayStatus: FulfillmentDisplayStatus


  estimatedDeliveryAt: DateTime


  events(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: FulfillmentEventSortKeys = HAPPENED_AT
  ): FulfillmentEventConnection!


  fulfillmentLineItems(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): FulfillmentLineItemConnection!


  fulfillmentOrders(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): FulfillmentOrderConnection!


  id: ID!


  inTransitAt: DateTime


  legacyResourceId: UnsignedInt64!


  location: Location


  name: String!


  order: Order!


  originAddress: FulfillmentOriginAddress


  requiresShipping: Boolean!


  service: FulfillmentService


  shippingLabel: ShippingLabel


  status: FulfillmentStatus!


  totalQuantity: Int!


  trackingInfo(

    first: Int
  ): [FulfillmentTrackingInfo!]!


  updatedAt: DateTime!
}


type FulfillmentCancelPayload {

  fulfillment: Fulfillment


  userErrors: [UserError!]!
}


type FulfillmentConnection {

  edges: [FulfillmentEdge!]!


  nodes: [Fulfillment!]!


  pageInfo: PageInfo!
}


type FulfillmentConstraintRule implements HasMetafields & Node {

  function: ShopifyFunction!


  id: ID!


  metafield(

    namespace: String


    key: String!
  ): Metafield


  metafields(

    namespace: String


    keys: [String!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  privateMetafield(

    namespace: String!


    key: String!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")
}


type FulfillmentConstraintRuleCreatePayload {

  fulfillmentConstraintRule: FulfillmentConstraintRule


  userErrors: [FulfillmentConstraintRuleCreateUserError!]!
}


type FulfillmentConstraintRuleCreateUserError implements DisplayableError {

  code: FulfillmentConstraintRuleCreateUserErrorCode


  field: [String!]


  message: String!
}


enum FulfillmentConstraintRuleCreateUserErrorCode {

  INPUT_INVALID


  FUNCTION_NOT_FOUND


  FUNCTION_ALREADY_REGISTERED


  FUNCTION_DOES_NOT_IMPLEMENT


  CUSTOM_APP_FUNCTION_NOT_ELIGIBLE


  FUNCTION_PENDING_DELETION
}


type FulfillmentConstraintRuleDeletePayload {

  success: Boolean


  userErrors: [FulfillmentConstraintRuleDeleteUserError!]!
}


type FulfillmentConstraintRuleDeleteUserError implements DisplayableError {

  code: FulfillmentConstraintRuleDeleteUserErrorCode


  field: [String!]


  message: String!
}


enum FulfillmentConstraintRuleDeleteUserErrorCode {

  NOT_FOUND


  UNAUTHORIZED_APP_SCOPE
}


type FulfillmentCreateV2Payload {

  fulfillment: Fulfillment


  userErrors: [UserError!]!
}


enum FulfillmentDisplayStatus {

  ATTEMPTED_DELIVERY


  CANCELED


  CONFIRMED


  DELIVERED


  FAILURE


  FULFILLED


  IN_TRANSIT


  LABEL_PRINTED


  LABEL_PURCHASED


  LABEL_VOIDED


  MARKED_AS_FULFILLED


  NOT_DELIVERED


  OUT_FOR_DELIVERY


  READY_FOR_PICKUP


  PICKED_UP


  SUBMITTED
}


type FulfillmentEdge {

  cursor: String!


  node: Fulfillment!
}


type FulfillmentEvent implements Node {

  address1: String


  city: String


  country: String


  estimatedDeliveryAt: DateTime


  happenedAt: DateTime!


  id: ID!


  latitude: Float


  longitude: Float


  message: String


  province: String


  status: FulfillmentEventStatus!


  zip: String
}


type FulfillmentEventConnection {

  edges: [FulfillmentEventEdge!]!


  nodes: [FulfillmentEvent!]!


  pageInfo: PageInfo!
}


type FulfillmentEventCreatePayload {

  fulfillmentEvent: FulfillmentEvent


  userErrors: [UserError!]!
}


type FulfillmentEventEdge {

  cursor: String!


  node: FulfillmentEvent!
}


input FulfillmentEventInput {

  address1: String


  city: String


  country: String


  estimatedDeliveryAt: DateTime


  happenedAt: DateTime


  fulfillmentId: ID!


  latitude: Float


  longitude: Float


  message: String


  province: String


  status: FulfillmentEventStatus!


  zip: String
}


enum FulfillmentEventSortKeys {

  HAPPENED_AT


  ID


  RELEVANCE
}


enum FulfillmentEventStatus {

  LABEL_PURCHASED


  LABEL_PRINTED


  READY_FOR_PICKUP


  CONFIRMED


  IN_TRANSIT


  OUT_FOR_DELIVERY


  ATTEMPTED_DELIVERY


  DELIVERED


  FAILURE
}


type FulfillmentHold {

  heldBy: String


  reason: FulfillmentHoldReason!


  reasonNotes: String
}


enum FulfillmentHoldReason {

  AWAITING_PAYMENT


  HIGH_RISK_OF_FRAUD


  INCORRECT_ADDRESS


  INVENTORY_OUT_OF_STOCK


  UNKNOWN_DELIVERY_DATE


  ONLINE_STORE_POST_PURCHASE_CROSS_SELL


  AWAITING_RETURN_ITEMS


  OTHER
}


type FulfillmentLineItem implements Node {

  discountedTotal: Money! @deprecated(reason: "Use `discountedTotalSet` instead.")


  discountedTotalSet: MoneyBag!


  id: ID!


  lineItem: LineItem!


  originalTotal: Money! @deprecated(reason: "Use `originalTotalSet` instead.")


  originalTotalSet: MoneyBag!


  quantity: Int
}


type FulfillmentLineItemConnection {

  edges: [FulfillmentLineItemEdge!]!


  nodes: [FulfillmentLineItem!]!


  pageInfo: PageInfo!
}


type FulfillmentLineItemEdge {

  cursor: String!


  node: FulfillmentLineItem!
}


type FulfillmentOrder implements Node {

  assignedLocation: FulfillmentOrderAssignedLocation!


  channelId: ID


  createdAt: DateTime!


  deliveryMethod: DeliveryMethod


  destination: FulfillmentOrderDestination


  fulfillAt: DateTime


  fulfillBy: DateTime


  fulfillmentHolds: [FulfillmentHold!]!


  fulfillmentOrdersForMerge(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): FulfillmentOrderConnection!


  fulfillments(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): FulfillmentConnection!


  id: ID!


  internationalDuties: FulfillmentOrderInternationalDuties


  lineItems(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): FulfillmentOrderLineItemConnection!


  locationsForMove(

    lineItemIds: [ID!] = []


    query: String


    locationIds: [ID!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): FulfillmentOrderLocationForMoveConnection!


  merchantRequests(

    kind: FulfillmentOrderMerchantRequestKind


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): FulfillmentOrderMerchantRequestConnection!


  order: Order!


  orderId: ID!


  orderName: String!


  orderProcessedAt: DateTime!


  requestStatus: FulfillmentOrderRequestStatus!


  status: FulfillmentOrderStatus!


  supportedActions: [FulfillmentOrderSupportedAction!]!


  updatedAt: DateTime!
}


type FulfillmentOrderAcceptCancellationRequestPayload {

  fulfillmentOrder: FulfillmentOrder


  userErrors: [UserError!]!
}


type FulfillmentOrderAcceptFulfillmentRequestPayload {

  fulfillmentOrder: FulfillmentOrder


  userErrors: [UserError!]!
}


enum FulfillmentOrderAction {

  CREATE_FULFILLMENT


  REQUEST_FULFILLMENT


  CANCEL_FULFILLMENT_ORDER


  MOVE


  REQUEST_CANCELLATION


  MARK_AS_OPEN


  RELEASE_HOLD


  HOLD


  EXTERNAL


  SPLIT


  MERGE
}


type FulfillmentOrderAssignedLocation {

  address1: String


  address2: String


  city: String


  countryCode: CountryCode!


  location: Location


  name: String!


  phone: String


  province: String


  zip: String
}


enum FulfillmentOrderAssignmentStatus {

  CANCELLATION_REQUESTED


  FULFILLMENT_REQUESTED


  FULFILLMENT_ACCEPTED
}


type FulfillmentOrderCancelPayload {

  fulfillmentOrder: FulfillmentOrder


  replacementFulfillmentOrder: FulfillmentOrder


  userErrors: [UserError!]!
}


type FulfillmentOrderClosePayload {

  fulfillmentOrder: FulfillmentOrder


  userErrors: [UserError!]!
}


type FulfillmentOrderConnection {

  edges: [FulfillmentOrderEdge!]!


  nodes: [FulfillmentOrder!]!


  pageInfo: PageInfo!
}


type FulfillmentOrderDestination implements Node {

  address1: String


  address2: String


  city: String


  company: String


  countryCode: CountryCode


  email: String


  firstName: String


  id: ID!


  lastName: String


  phone: String


  province: String


  zip: String
}


type FulfillmentOrderEdge {

  cursor: String!


  node: FulfillmentOrder!
}


input FulfillmentOrderHoldInput {

  reason: FulfillmentHoldReason!


  reasonNotes: String


  notifyMerchant: Boolean = false


  externalId: String


  fulfillmentOrderLineItems: [FulfillmentOrderLineItemInput!] = []
}


type FulfillmentOrderHoldPayload {

  fulfillmentOrder: FulfillmentOrder


  remainingFulfillmentOrder: FulfillmentOrder


  userErrors: [FulfillmentOrderHoldUserError!]!
}


type FulfillmentOrderHoldUserError implements DisplayableError {

  code: FulfillmentOrderHoldUserErrorCode


  field: [String!]


  message: String!
}


enum FulfillmentOrderHoldUserErrorCode {

  FULFILLMENT_ORDER_NOT_FOUND


  TAKEN


  GREATER_THAN_ZERO


  INVALID_LINE_ITEM_QUANTITY
}


type FulfillmentOrderInternationalDuties {

  incoterm: String!
}


type FulfillmentOrderLineItem implements Node {

  financialSummaries: [FulfillmentOrderLineItemFinancialSummary!]!


  id: ID!


  image: Image


  inventoryItemId: ID


  lineItem: LineItem! @deprecated(reason: "          As of API version 2023-01, this field has been deprecated. The order line item associated with a `FulfillmentOrderLineItem`\n          shouldn't be used to determine what to fulfill. Use the `FulfillmentOrderLineItem` and `FulfillmentOrder` objects\n          instead. An order `LineItem` represents a single line item on an order, but it doesn't represent what should be fulfilled.\n")


  originalUnitPriceSet: MoneyBag! @deprecated(reason: "Use `financialSummaries` instead.")


  productTitle: String!


  remainingQuantity: Int!


  requiresShipping: Boolean!


  sku: String


  totalQuantity: Int!


  variantTitle: String


  vendor: String


  warnings: [FulfillmentOrderLineItemWarning!]!


  weight: Weight
}


type FulfillmentOrderLineItemConnection {

  edges: [FulfillmentOrderLineItemEdge!]!


  nodes: [FulfillmentOrderLineItem!]!


  pageInfo: PageInfo!
}


type FulfillmentOrderLineItemEdge {

  cursor: String!


  node: FulfillmentOrderLineItem!
}


type FulfillmentOrderLineItemFinancialSummary {

  approximateDiscountedUnitPriceSet: MoneyBag!


  discountAllocations: [FinancialSummaryDiscountAllocation!]!


  originalUnitPriceSet: MoneyBag!


  quantity: Int!
}


input FulfillmentOrderLineItemInput {

  id: ID!


  quantity: Int!
}


input FulfillmentOrderLineItemsInput {

  fulfillmentOrderId: ID!


  fulfillmentOrderLineItems: [FulfillmentOrderLineItemInput!]
}


input FulfillmentOrderLineItemsPreparedForPickupInput {

  lineItemsByFulfillmentOrder: [PreparedFulfillmentOrderLineItemsInput!]!
}


type FulfillmentOrderLineItemsPreparedForPickupPayload {

  userErrors: [FulfillmentOrderLineItemsPreparedForPickupUserError!]!
}


type FulfillmentOrderLineItemsPreparedForPickupUserError implements DisplayableError {

  code: FulfillmentOrderLineItemsPreparedForPickupUserErrorCode


  field: [String!]


  message: String!
}


enum FulfillmentOrderLineItemsPreparedForPickupUserErrorCode {

  NO_LINE_ITEMS_TO_PREPARE_FOR_FULFILLMENT_ORDER


  FULFILLMENT_ORDER_INVALID


  UNABLE_TO_PREPARE_QUANTITY
}


type FulfillmentOrderLineItemWarning {

  description: String


  title: String
}


type FulfillmentOrderLocationForMove {

  availableLineItems(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): FulfillmentOrderLineItemConnection!


  availableLineItemsCount: UnsignedInt64!


  location: Location!


  message: String


  movable: Boolean!


  unavailableLineItems(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): FulfillmentOrderLineItemConnection!


  unavailableLineItemsCount: UnsignedInt64!
}


type FulfillmentOrderLocationForMoveConnection {

  edges: [FulfillmentOrderLocationForMoveEdge!]!


  nodes: [FulfillmentOrderLocationForMove!]!


  pageInfo: PageInfo!
}


type FulfillmentOrderLocationForMoveEdge {

  cursor: String!


  node: FulfillmentOrderLocationForMove!
}


type FulfillmentOrderMerchantRequest implements Node {

  fulfillmentOrder: FulfillmentOrder!


  id: ID!


  kind: FulfillmentOrderMerchantRequestKind!


  message: String


  requestOptions: JSON


  responseData: JSON


  sentAt: DateTime!
}


type FulfillmentOrderMerchantRequestConnection {

  edges: [FulfillmentOrderMerchantRequestEdge!]!


  nodes: [FulfillmentOrderMerchantRequest!]!


  pageInfo: PageInfo!
}


type FulfillmentOrderMerchantRequestEdge {

  cursor: String!


  node: FulfillmentOrderMerchantRequest!
}


enum FulfillmentOrderMerchantRequestKind {

  FULFILLMENT_REQUEST


  CANCELLATION_REQUEST
}


input FulfillmentOrderMergeInput {

  mergeIntents: [FulfillmentOrderMergeInputMergeIntent!]!
}


input FulfillmentOrderMergeInputMergeIntent {

  fulfillmentOrderLineItems: [FulfillmentOrderLineItemInput!]


  fulfillmentOrderId: ID!
}


type FulfillmentOrderMergePayload {

  fulfillmentOrderMerges: [FulfillmentOrderMergeResult!]


  userErrors: [FulfillmentOrderMergeUserError!]!
}


type FulfillmentOrderMergeResult {

  fulfillmentOrder: FulfillmentOrder!
}


type FulfillmentOrderMergeUserError implements DisplayableError {

  code: FulfillmentOrderMergeUserErrorCode


  field: [String!]


  message: String!
}


enum FulfillmentOrderMergeUserErrorCode {

  FULFILLMENT_ORDER_NOT_FOUND


  GREATER_THAN


  INVALID_LINE_ITEM_QUANTITY
}


type FulfillmentOrderMovePayload {

  movedFulfillmentOrder: FulfillmentOrder


  originalFulfillmentOrder: FulfillmentOrder


  remainingFulfillmentOrder: FulfillmentOrder


  userErrors: [UserError!]!
}


type FulfillmentOrderOpenPayload {

  fulfillmentOrder: FulfillmentOrder


  userErrors: [UserError!]!
}


type FulfillmentOrderRejectCancellationRequestPayload {

  fulfillmentOrder: FulfillmentOrder


  userErrors: [UserError!]!
}


type FulfillmentOrderRejectFulfillmentRequestPayload {

  fulfillmentOrder: FulfillmentOrder


  userErrors: [UserError!]!
}


enum FulfillmentOrderRejectionReason {

  INCORRECT_ADDRESS


  INVENTORY_OUT_OF_STOCK


  INELIGIBLE_PRODUCT


  UNDELIVERABLE_DESTINATION


  OTHER
}


type FulfillmentOrderReleaseHoldPayload {

  fulfillmentOrder: FulfillmentOrder


  userErrors: [FulfillmentOrderReleaseHoldUserError!]!
}


type FulfillmentOrderReleaseHoldUserError implements DisplayableError {

  code: FulfillmentOrderReleaseHoldUserErrorCode


  field: [String!]


  message: String!
}


enum FulfillmentOrderReleaseHoldUserErrorCode {

  FULFILLMENT_ORDER_NOT_FOUND


  GREATER_THAN_ZERO


  INVALID_LINE_ITEM_QUANTITY
}


enum FulfillmentOrderRequestStatus {

  UNSUBMITTED


  SUBMITTED


  ACCEPTED


  REJECTED


  CANCELLATION_REQUESTED


  CANCELLATION_ACCEPTED


  CANCELLATION_REJECTED


  CLOSED
}


type FulfillmentOrderReschedulePayload {

  fulfillmentOrder: FulfillmentOrder


  userErrors: [FulfillmentOrderRescheduleUserError!]!
}


type FulfillmentOrderRescheduleUserError implements DisplayableError {

  code: FulfillmentOrderRescheduleUserErrorCode


  field: [String!]


  message: String!
}


enum FulfillmentOrderRescheduleUserErrorCode {

  FULFILLMENT_ORDER_NOT_FOUND
}


enum FulfillmentOrderSortKeys {

  ID


  RELEVANCE
}


input FulfillmentOrderSplitInput {

  fulfillmentOrderLineItems: [FulfillmentOrderLineItemInput!]!


  fulfillmentOrderId: ID!
}


type FulfillmentOrderSplitPayload {

  fulfillmentOrderSplits: [FulfillmentOrderSplitResult!]


  userErrors: [FulfillmentOrderSplitUserError!]!
}


type FulfillmentOrderSplitResult {

  fulfillmentOrder: FulfillmentOrder!


  remainingFulfillmentOrder: FulfillmentOrder!


  replacementFulfillmentOrder: FulfillmentOrder
}


type FulfillmentOrderSplitUserError implements DisplayableError {

  code: FulfillmentOrderSplitUserErrorCode


  field: [String!]


  message: String!
}


enum FulfillmentOrderSplitUserErrorCode {

  FULFILLMENT_ORDER_NOT_FOUND


  GREATER_THAN


  INVALID_LINE_ITEM_QUANTITY


  NO_LINE_ITEMS_PROVIDED_TO_SPLIT
}


type FulfillmentOrdersReleaseHoldsPayload {

  job: Job


  userErrors: [FulfillmentOrdersReleaseHoldsUserError!]!
}


type FulfillmentOrdersReleaseHoldsUserError implements DisplayableError {

  code: FulfillmentOrdersReleaseHoldsUserErrorCode


  field: [String!]


  message: String!
}


enum FulfillmentOrdersReleaseHoldsUserErrorCode {

  FAILED_TO_CREATE_JOB
}


type FulfillmentOrdersSetFulfillmentDeadlinePayload {

  success: Boolean


  userErrors: [FulfillmentOrdersSetFulfillmentDeadlineUserError!]!
}


type FulfillmentOrdersSetFulfillmentDeadlineUserError implements DisplayableError {

  code: FulfillmentOrdersSetFulfillmentDeadlineUserErrorCode


  field: [String!]


  message: String!
}


enum FulfillmentOrdersSetFulfillmentDeadlineUserErrorCode {

  FULFILLMENT_ORDERS_NOT_FOUND
}


enum FulfillmentOrderStatus {

  OPEN


  IN_PROGRESS


  CANCELLED


  INCOMPLETE


  CLOSED


  SCHEDULED


  ON_HOLD
}


type FulfillmentOrderSubmitCancellationRequestPayload {

  fulfillmentOrder: FulfillmentOrder


  userErrors: [UserError!]!
}


type FulfillmentOrderSubmitFulfillmentRequestPayload {

  originalFulfillmentOrder: FulfillmentOrder


  submittedFulfillmentOrder: FulfillmentOrder


  unsubmittedFulfillmentOrder: FulfillmentOrder


  userErrors: [UserError!]!
}


type FulfillmentOrderSupportedAction {

  action: FulfillmentOrderAction!


  externalUrl: URL
}


type FulfillmentOriginAddress {

  address1: String


  address2: String


  city: String


  countryCode: String!


  provinceCode: String


  zip: String
}


input FulfillmentOriginAddressInput {

  address1: String


  address2: String


  city: String


  zip: String


  provinceCode: String


  countryCode: String!
}


type FulfillmentService {

  callbackUrl: URL


  fulfillmentOrdersOptIn: Boolean! @deprecated(reason: "Migration period ended. All correctly functioning fulfillment services have `fulfillmentOrdersOptIn` set to `true`.")


  handle: String!


  id: ID!


  inventoryManagement: Boolean!


  location: Location


  permitsSkuSharing: Boolean!


  productBased: Boolean!


  serviceName: String!


  shippingMethods: [ShippingMethod!]! @deprecated(reason: "The Fulfillment by Amazon feature will no longer be supported from March 30, 2023. To continue using Amazon fulfillment, merchants need to set up a Multi-Channel Fulfillment solution recommended by Amazon: https://help.shopify.com/manual/shipping/fulfillment-services/amazon#activate-fulfillment-by-amazon")


  type: FulfillmentServiceType!
}


type FulfillmentServiceCreatePayload {

  fulfillmentService: FulfillmentService


  userErrors: [UserError!]!
}


type FulfillmentServiceDeletePayload {

  deletedId: ID


  userErrors: [UserError!]!
}


enum FulfillmentServiceType {

  GIFT_CARD


  MANUAL


  THIRD_PARTY
}


type FulfillmentServiceUpdatePayload {

  fulfillmentService: FulfillmentService


  userErrors: [UserError!]!
}


enum FulfillmentStatus {

  PENDING @deprecated(reason: "This is a legacy status and is due to be deprecated.")


  OPEN @deprecated(reason: "This is a legacy status and is due to be deprecated.")


  SUCCESS


  CANCELLED


  ERROR


  FAILURE
}


type FulfillmentTrackingInfo {

  company: String


  number: String


  url: URL
}


type FulfillmentTrackingInfoUpdateV2Payload {

  fulfillment: Fulfillment


  userErrors: [UserError!]!
}


input FulfillmentTrackingInput {

  number: String


  url: URL


  company: String


  numbers: [String!]


  urls: [URL!]
}


input FulfillmentV2Input {

  trackingInfo: FulfillmentTrackingInput


  notifyCustomer: Boolean = false


  lineItemsByFulfillmentOrder: [FulfillmentOrderLineItemsInput!]!


  originAddress: FulfillmentOriginAddressInput
}


type FunctionsAppBridge {

  createPath: String!


  detailsPath: String!
}


type FunctionsErrorHistory {

  errorsFirstOccurredAt: DateTime!


  firstOccurredAt: DateTime!


  hasBeenSharedSinceLastError: Boolean!


  hasSharedRecentErrors: Boolean!
}


type GenericFile implements File & Node {

  alt: String


  createdAt: DateTime!


  fileErrors: [FileError!]!


  fileStatus: FileStatus!


  id: ID!


  mimeType: String


  originalFileSize: Int


  preview: MediaPreviewImage


  updatedAt: DateTime!


  url: URL
}


type GiftCard implements Node {

  balance: MoneyV2!


  createdAt: DateTime!


  customer: Customer


  disabledAt: DateTime


  enabled: Boolean!


  expiresOn: Date


  id: ID!


  initialValue: MoneyV2!


  lastCharacters: String!


  maskedCode: String!


  note: String


  order: Order
}


type GiftCardConnection {

  edges: [GiftCardEdge!]!


  nodes: [GiftCard!]!


  pageInfo: PageInfo!
}


input GiftCardCreateInput {

  initialValue: Decimal!


  code: String


  customerId: ID


  expiresOn: Date


  note: String


  templateSuffix: String
}


type GiftCardCreatePayload {

  giftCard: GiftCard


  giftCardCode: String


  userErrors: [GiftCardUserError!]!
}


type GiftCardDisablePayload {

  giftCard: GiftCard


  userErrors: [UserError!]!
}


type GiftCardEdge {

  cursor: String!


  node: GiftCard!
}


enum GiftCardErrorCode {

  TOO_LONG


  TOO_SHORT


  TAKEN


  INVALID


  INTERNAL_ERROR


  MISSING_ARGUMENT


  GREATER_THAN
}


type GiftCardSale implements Sale {

  actionType: SaleActionType!


  id: ID!


  lineItem: LineItem!


  lineType: SaleLineType!


  quantity: Int


  taxes: [SaleTax!]!


  totalAmount: MoneyBag!


  totalDiscountAmountAfterTaxes: MoneyBag!


  totalDiscountAmountBeforeTaxes: MoneyBag!


  totalTaxAmount: MoneyBag!
}


enum GiftCardSortKeys {

  CREATED_AT


  UPDATED_AT


  CUSTOMER_NAME


  CODE


  BALANCE


  AMOUNT_SPENT


  INITIAL_VALUE


  DISABLED_AT


  EXPIRES_ON


  ID


  RELEVANCE
}


input GiftCardUpdateInput {

  note: String


  expiresOn: Date


  customerId: ID


  templateSuffix: String
}


type GiftCardUpdatePayload {

  giftCard: GiftCard


  userErrors: [UserError!]!
}


type GiftCardUserError implements DisplayableError {

  code: GiftCardErrorCode


  field: [String!]


  message: String!
}


interface HasEvents {

  events(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: EventSortKeys = ID


    query: String
  ): EventConnection!
}


interface HasLocalizationExtensions {

  localizationExtensions(

    countryCodes: [CountryCode!]


    purposes: [LocalizationExtensionPurpose!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): LocalizationExtensionConnection!
}


interface HasMetafieldDefinitions {

  metafieldDefinitions(

    namespace: String


    pinnedStatus: MetafieldDefinitionPinnedStatus = ANY


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: MetafieldDefinitionSortKeys = ID


    query: String
  ): MetafieldDefinitionConnection!
}


interface HasMetafields {

  metafield(

    namespace: String


    key: String!
  ): Metafield


  metafields(

    namespace: String


    keys: [String!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  privateMetafield(

    namespace: String!


    key: String!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")
}


interface HasPublishedTranslations {

  translations(

    locale: String!


    marketId: ID
  ): [Translation!]!
}


scalar HTML


type Image implements HasMetafields {

  altText: String


  height: Int


  id: ID


  metafield(

    namespace: String


    key: String!
  ): Metafield


  metafields(

    namespace: String


    keys: [String!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  originalSrc: URL! @deprecated(reason: "Use `url` instead.")


  privateMetafield(

    namespace: String!


    key: String!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  src: URL! @deprecated(reason: "Use `url` instead.")


  transformedSrc(

    maxWidth: Int


    maxHeight: Int


    crop: CropRegion


    scale: Int = 1


    preferredContentType: ImageContentType
  ): URL! @deprecated(reason: "Use `url(transform:)` instead")


  url(

    transform: ImageTransformInput
  ): URL!


  width: Int
}


type ImageConnection {

  edges: [ImageEdge!]!


  nodes: [Image!]!


  pageInfo: PageInfo!
}


enum ImageContentType {

  PNG


  JPG


  WEBP
}


type ImageEdge {

  cursor: String!


  node: Image!
}


input ImageInput {

  id: ID


  altText: String


  src: String
}


input ImageTransformInput {

  crop: CropRegion


  maxWidth: Int


  maxHeight: Int


  scale: Int = 1


  preferredContentType: ImageContentType
}


type ImageUploadParameter {

  name: String!


  value: String!
}


input IncomingRequestLineItemInput {

  fulfillmentOrderLineItemId: ID!


  message: String
}


type InventoryActivatePayload {

  inventoryLevel: InventoryLevel


  userErrors: [UserError!]!
}


input InventoryAdjustItemInput {

  inventoryItemId: ID!


  availableDelta: Int!
}


type InventoryAdjustmentGroup implements Node {

  app: App


  changes(

    inventoryItemIds: [ID!]


    locationIds: [ID!]


    quantityNames: [String!]
  ): [InventoryChange!]!


  createdAt: DateTime!


  id: ID!


  reason: String!


  referenceDocumentUri: String


  staffMember: StaffMember
}


input InventoryAdjustQuantitiesInput {

  reason: String!


  name: String!


  referenceDocumentUri: String


  changes: [InventoryChangeInput!]!
}


type InventoryAdjustQuantitiesPayload {

  inventoryAdjustmentGroup: InventoryAdjustmentGroup


  userErrors: [InventoryAdjustQuantitiesUserError!]!
}


type InventoryAdjustQuantitiesUserError implements DisplayableError {

  code: InventoryAdjustQuantitiesUserErrorCode


  field: [String!]


  message: String!
}


enum InventoryAdjustQuantitiesUserErrorCode {

  INTERNAL_LEDGER_DOCUMENT


  INVALID_AVAILABLE_DOCUMENT


  INVALID_INVENTORY_ITEM


  INVALID_LEDGER_DOCUMENT


  INVALID_LOCATION


  INVALID_QUANTITY_DOCUMENT


  INVALID_QUANTITY_NAME


  INVALID_QUANTITY_TOO_LOW


  INVALID_QUANTITY_TOO_HIGH


  INVALID_REASON


  INVALID_REFERENCE_DOCUMENT


  ADJUST_QUANTITIES_FAILED


  MAX_ONE_LEDGER_DOCUMENT


  ITEM_NOT_STOCKED_AT_LOCATION


  NON_MUTABLE_INVENTORY_ITEM
}


input InventoryAdjustQuantityInput {

  inventoryLevelId: ID!


  availableDelta: Int!
}


type InventoryAdjustQuantityPayload {

  inventoryLevel: InventoryLevel


  userErrors: [UserError!]!
}


type InventoryBulkAdjustQuantityAtLocationPayload {

  inventoryLevels: [InventoryLevel!]


  userErrors: [UserError!]!
}


input InventoryBulkToggleActivationInput {

  locationId: ID!


  activate: Boolean!
}


type InventoryBulkToggleActivationPayload {

  inventoryItem: InventoryItem


  inventoryLevels: [InventoryLevel!]


  userErrors: [InventoryBulkToggleActivationUserError!]!
}


type InventoryBulkToggleActivationUserError implements DisplayableError {

  code: InventoryBulkToggleActivationUserErrorCode


  field: [String!]


  message: String!
}


enum InventoryBulkToggleActivationUserErrorCode {

  GENERIC_ERROR


  CANNOT_DEACTIVATE_FROM_ONLY_LOCATION


  COMMITTED_AND_INCOMING_INVENTORY_AT_LOCATION @deprecated(reason: "This error code is deprecated. Both INCOMING_INVENTORY_AT_LOCATION and COMMITTED_INVENTORY_AT_LOCATION codes will be returned as individual errors instead.")


  INCOMING_INVENTORY_AT_LOCATION


  COMMITTED_INVENTORY_AT_LOCATION


  RESERVED_INVENTORY_AT_LOCATION


  FAILED_TO_UNSTOCK_FROM_LOCATION


  INVENTORY_MANAGED_BY_3RD_PARTY


  INVENTORY_MANAGED_BY_SHOPIFY


  FAILED_TO_STOCK_AT_LOCATION


  MISSING_SKU


  LOCATION_NOT_FOUND


  INVENTORY_ITEM_NOT_FOUND
}


type InventoryChange {

  delta: Int!


  item: InventoryItem


  ledgerDocumentUri: String


  location: Location


  name: String!


  quantityAfterChange: Int
}


input InventoryChangeInput {

  delta: Int!


  inventoryItemId: ID!


  locationId: ID!


  ledgerDocumentUri: String
}


type InventoryDeactivatePayload {

  userErrors: [UserError!]!
}


type InventoryItem implements LegacyInteroperability & Node {

  countryCodeOfOrigin: CountryCode


  countryHarmonizedSystemCodes(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): CountryHarmonizedSystemCodeConnection!


  createdAt: DateTime!


  duplicateSkuCount: Int!


  harmonizedSystemCode: String


  id: ID!


  inventoryHistoryUrl: URL


  inventoryLevel(

    locationId: ID!
  ): InventoryLevel


  inventoryLevels(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    query: String
  ): InventoryLevelConnection!


  legacyResourceId: UnsignedInt64!


  locationsCount: Int!


  provinceCodeOfOrigin: String


  requiresShipping: Boolean!


  sku: String


  tracked: Boolean!


  trackedEditable: EditableProperty!


  unitCost: MoneyV2


  updatedAt: DateTime!


  variant: ProductVariant!
}


type InventoryItemConnection {

  edges: [InventoryItemEdge!]!


  nodes: [InventoryItem!]!


  pageInfo: PageInfo!
}


type InventoryItemEdge {

  cursor: String!


  node: InventoryItem!
}


input InventoryItemInput {

  cost: Decimal


  tracked: Boolean
}


input InventoryItemUpdateInput {

  cost: Decimal


  tracked: Boolean


  countryCodeOfOrigin: CountryCode


  provinceCodeOfOrigin: String


  harmonizedSystemCode: String


  countryHarmonizedSystemCodes: [CountryHarmonizedSystemCodeInput!]
}


type InventoryItemUpdatePayload {

  inventoryItem: InventoryItem


  userErrors: [UserError!]!
}


type InventoryLevel implements Node {

  available: Int! @deprecated(reason: "Use the `quantities` field instead and specify available for names. Example: `quantities(names:[\"available\"]){name quantity}`.\n")


  canDeactivate: Boolean!


  createdAt: DateTime!


  deactivationAlert: String


  deactivationAlertHtml: FormattedString @deprecated(reason: "Use `deactivationAlert` instead.")


  id: ID!


  incoming: Int! @deprecated(reason: "Use the `quantities` field instead and specify incoming for names. Example: `quantities(names:[\"incoming\"]){name quantity}`.\n")


  item: InventoryItem!


  location: Location!


  quantities(

    names: [String!]!
  ): [InventoryQuantity!]!


  scheduledChanges(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: ScheduledChangeSortKeys = ID


    query: String
  ): InventoryScheduledChangeConnection!


  updatedAt: DateTime!
}


type InventoryLevelConnection {

  edges: [InventoryLevelEdge!]!


  nodes: [InventoryLevel!]!


  pageInfo: PageInfo!
}


type InventoryLevelEdge {

  cursor: String!


  node: InventoryLevel!
}


input InventoryLevelInput {

  availableQuantity: Int!


  locationId: ID!
}


input InventoryMoveQuantitiesInput {

  reason: String!


  referenceDocumentUri: String!


  changes: [InventoryMoveQuantityChange!]!
}


type InventoryMoveQuantitiesPayload {

  inventoryAdjustmentGroup: InventoryAdjustmentGroup


  userErrors: [InventoryMoveQuantitiesUserError!]!
}


type InventoryMoveQuantitiesUserError implements DisplayableError {

  code: InventoryMoveQuantitiesUserErrorCode


  field: [String!]


  message: String!
}


enum InventoryMoveQuantitiesUserErrorCode {

  INTERNAL_LEDGER_DOCUMENT


  INVALID_AVAILABLE_DOCUMENT


  INVALID_INVENTORY_ITEM


  INVALID_LEDGER_DOCUMENT


  INVALID_LOCATION


  INVALID_QUANTITY_DOCUMENT


  INVALID_QUANTITY_NAME


  INVALID_QUANTITY_NEGATIVE


  INVALID_QUANTITY_TOO_HIGH


  INVALID_REASON


  INVALID_REFERENCE_DOCUMENT


  MOVE_QUANTITIES_FAILED


  DIFFERENT_LOCATIONS


  SAME_QUANTITY_NAME


  MAXIMUM_LEDGER_DOCUMENT_URIS


  ITEM_NOT_STOCKED_AT_LOCATION


  NON_MUTABLE_INVENTORY_ITEM
}


input InventoryMoveQuantityChange {

  inventoryItemId: ID!


  quantity: Int!


  from: InventoryMoveQuantityTerminalInput!


  to: InventoryMoveQuantityTerminalInput!
}


input InventoryMoveQuantityTerminalInput {

  locationId: ID!


  name: String!


  ledgerDocumentUri: String
}


type InventoryProperties {

  quantityNames: [InventoryQuantityName!]!
}


type InventoryQuantity implements Node {

  id: ID!


  name: String!


  quantity: Int!


  updatedAt: DateTime
}


type InventoryQuantityName {

  belongsTo: [String!]!


  comprises: [String!]!


  displayName: String


  isInUse: Boolean!


  name: String!
}


type InventoryScheduledChange {

  expectedAt: DateTime!


  fromName: String!


  inventoryLevel: InventoryLevel!


  ledgerDocumentUri: URL!


  quantity: Int!


  toName: String!
}


type InventoryScheduledChangeConnection {

  edges: [InventoryScheduledChangeEdge!]!


  nodes: [InventoryScheduledChange!]!


  pageInfo: PageInfo!
}


type InventoryScheduledChangeEdge {

  cursor: String!


  node: InventoryScheduledChange!
}


input InventoryScheduledChangeInput {

  expectedAt: DateTime!


  fromName: String!


  toName: String!
}


input InventoryScheduledChangeItemInput {

  inventoryItemId: ID!


  locationId: ID!


  ledgerDocumentUri: URL!


  scheduledChanges: [InventoryScheduledChangeInput!]!
}


input InventorySetOnHandQuantitiesInput {

  reason: String!


  referenceDocumentUri: String


  setQuantities: [InventorySetQuantityInput!]!
}


type InventorySetOnHandQuantitiesPayload {

  inventoryAdjustmentGroup: InventoryAdjustmentGroup


  userErrors: [InventorySetOnHandQuantitiesUserError!]!
}


type InventorySetOnHandQuantitiesUserError implements DisplayableError {

  code: InventorySetOnHandQuantitiesUserErrorCode


  field: [String!]


  message: String!
}


enum InventorySetOnHandQuantitiesUserErrorCode {

  INVALID_INVENTORY_ITEM


  INVALID_LOCATION


  INVALID_QUANTITY_NEGATIVE


  INVALID_REASON


  INVALID_REFERENCE_DOCUMENT


  SET_ON_HAND_QUANTITIES_FAILED


  ITEM_NOT_STOCKED_AT_LOCATION


  NON_MUTABLE_INVENTORY_ITEM


  INVALID_QUANTITY_TOO_HIGH
}


input InventorySetQuantityInput {

  inventoryItemId: ID!


  locationId: ID!


  quantity: Int!
}


input InventorySetScheduledChangesInput {

  reason: String!


  items: [InventoryScheduledChangeItemInput!]!


  referenceDocumentUri: URL!
}


type InventorySetScheduledChangesPayload {

  scheduledChanges: [InventoryScheduledChange!]


  userErrors: [InventorySetScheduledChangesUserError!]!
}


type InventorySetScheduledChangesUserError implements DisplayableError {

  code: InventorySetScheduledChangesUserErrorCode


  field: [String!]


  message: String!
}


enum InventorySetScheduledChangesUserErrorCode {

  ERROR_UPDATING_SCHEDULED


  SAME_FROM_TO_NAMES


  INVALID_FROM_NAME


  INVALID_TO_NAME


  DUPLICATE_TO_NAME


  INVALID_REASON


  DUPLICATE_FROM_NAME


  LOCATION_NOT_FOUND


  INVENTORY_STATE_NOT_FOUND


  ITEMS_EMPTY


  INVENTORY_ITEM_NOT_FOUND


  INCLUSION
}


type Job {

  done: Boolean!


  id: ID!


  query: QueryRoot
}


interface JobResult {

  done: Boolean!


  id: ID!
}


scalar JSON


enum LanguageCode {

  AF


  AK


  AM


  AR


  AS


  AZ


  BE


  BG


  BM


  BN


  BO


  BR


  BS


  CA


  CE


  CS


  CY


  DA


  DE


  DZ


  EE


  EL


  EN


  EO


  ES


  ET


  EU


  FA


  FF


  FI


  FO


  FR


  FY


  GA


  GD


  GL


  GU


  GV


  HA


  HE


  HI


  HR


  HU


  HY


  IA


  ID


  IG


  II


  IS


  IT


  JA


  JV


  KA


  KI


  KK


  KL


  KM


  KN


  KO


  KS


  KU


  KW


  KY


  LB


  LG


  LN


  LO


  LT


  LU


  LV


  MG


  MI


  MK


  ML


  MN


  MR


  MS


  MT


  MY


  NB


  ND


  NE


  NL


  NN


  NO


  OM


  OR


  OS


  PA


  PL


  PS


  PT_BR


  PT_PT


  QU


  RM


  RN


  RO


  RU


  RW


  SD


  SE


  SG


  SI


  SK


  SL


  SN


  SO


  SQ


  SR


  SU


  SV


  SW


  TA


  TE


  TG


  TH


  TI


  TK


  TO


  TR


  TT


  UG


  UK


  UR


  UZ


  VI


  WO


  XH


  YI


  YO


  ZH_CN


  ZH_TW


  ZU


  ZH


  PT


  CU


  VO
}


interface LegacyInteroperability {

  legacyResourceId: UnsignedInt64!
}


enum LengthUnit {

  MILLIMETERS


  CENTIMETERS


  METERS


  INCHES


  FEET


  YARDS
}


type LimitedPendingOrderCount {

  atMax: Boolean!


  count: Int!
}


type LineItem implements Node {

  canRestock: Boolean! @deprecated(reason: "Use `restockable` instead.")


  contract: SubscriptionContract


  currentQuantity: Int!


  customAttributes: [Attribute!]!


  discountAllocations: [DiscountAllocation!]!


  discountedTotal: Money! @deprecated(reason: "Use `discountedTotalSet` instead.")


  discountedTotalSet: MoneyBag!


  discountedUnitPrice: Money! @deprecated(reason: "Use `discountedUnitPriceSet` instead.")


  discountedUnitPriceAfterAllDiscountsSet: MoneyBag!


  discountedUnitPriceSet: MoneyBag!


  duties: [Duty!]!


  fulfillableQuantity: Int! @deprecated(reason: "Use [FulfillmentOrderLineItem#remainingQuantity](https://shopify.dev/api/admin-graphql/latest/objects/FulfillmentOrderLineItem#field-fulfillmentorderlineitem-remainingquantity) instead.")


  fulfillmentService: FulfillmentService @deprecated(reason: "\nThe [relationship between a product variant and a fulfillment service was changed in the `2022-07` API version](/changelog/fulfillment-service-sku-sharing). A [ProductVariant](/api/admin-graphql/latest/objects/ProductVariant) can be stocked by multiple fulfillment services. As a result, we recommend that you use the [inventoryItem field](/api/admin-graphql/latest/objects/ProductVariant#field-productvariant-inventoryitem) if you need to determine where a product variant is stocked.\n\nIf you need to determine whether a product is a gift card, then you should continue to use this field until an alternative is available.\n\nAltering the locations which stock a product variant won't change the value of this field for existing orders.\n\nLearn about [managing inventory quantities and states](/apps/fulfillment/inventory-management-apps/quantities-states).\n")


  fulfillmentStatus: String! @deprecated(reason: "Use [FulfillmentOrderLineItem#remainingQuantity](https://shopify.dev/api/admin-graphql/latest/objects/FulfillmentOrderLineItem#field-fulfillmentorderlineitem-remainingquantity) instead")


  id: ID!


  image: Image


  lineItemGroup: LineItemGroup


  merchantEditable: Boolean!


  name: String!


  nonFulfillableQuantity: Int!


  originalTotal: Money! @deprecated(reason: "Use `originalTotalSet` instead.")


  originalTotalSet: MoneyBag!


  originalUnitPrice: Money! @deprecated(reason: "Use `originalUnitPriceSet` instead.")


  originalUnitPriceSet: MoneyBag!


  product: Product


  quantity: Int!


  refundableQuantity: Int!


  requiresShipping: Boolean!


  restockable: Boolean!


  sellingPlan: LineItemSellingPlan


  sku: String


  staffMember: StaffMember


  taxLines(

    first: Int
  ): [TaxLine!]!


  taxable: Boolean!


  title: String!


  totalDiscount: Money! @deprecated(reason: "Use `totalDiscountSet` instead.")


  totalDiscountSet: MoneyBag!


  unfulfilledDiscountedTotal: Money! @deprecated(reason: "Use `unfulfilledDiscountedTotalSet` instead.")


  unfulfilledDiscountedTotalSet: MoneyBag!


  unfulfilledOriginalTotal: Money! @deprecated(reason: "Use `unfulfilledOriginalTotalSet` instead.")


  unfulfilledOriginalTotalSet: MoneyBag!


  unfulfilledQuantity: Int!


  variant: ProductVariant


  variantTitle: String


  vendor: String
}


type LineItemConnection {

  edges: [LineItemEdge!]!


  nodes: [LineItem!]!


  pageInfo: PageInfo!
}


type LineItemEdge {

  cursor: String!


  node: LineItem!
}


type LineItemGroup {

  id: ID!


  quantity: Int!


  title: String!


  variantId: ID


  variantSku: String
}


type LineItemMutable implements Node {

  canRestock: Boolean! @deprecated(reason: "Use `restockable` instead.")


  customAttributes: [Attribute!]!


  discountAllocations: [DiscountAllocation!]!


  discountedTotal: Money! @deprecated(reason: "Use `discountedTotalSet` instead.")


  discountedTotalSet: MoneyBag!


  discountedUnitPrice: Money! @deprecated(reason: "Use `discountedUnitPriceSet` instead.")


  discountedUnitPriceSet: MoneyBag!


  fulfillableQuantity: Int!


  fulfillmentService: FulfillmentService


  fulfillmentStatus: String!


  id: ID!


  image: Image


  merchantEditable: Boolean!


  name: String!


  nonFulfillableQuantity: Int!


  originalTotal: Money! @deprecated(reason: "Use `originalTotalSet` instead.")


  originalTotalSet: MoneyBag!


  originalUnitPrice: Money! @deprecated(reason: "Use `originalUnitPriceSet` instead.")


  originalUnitPriceSet: MoneyBag!


  product: Product


  quantity: Int!


  refundableQuantity: Int!


  requiresShipping: Boolean!


  restockable: Boolean!


  sku: String


  staffMember: StaffMember


  taxLines(

    first: Int
  ): [TaxLine!]!


  taxable: Boolean!


  title: String!


  totalDiscount: Money! @deprecated(reason: "Use `totalDiscountSet` instead.")


  totalDiscountSet: MoneyBag!


  unfulfilledDiscountedTotal: Money! @deprecated(reason: "Use `unfulfilledDiscountedTotalSet` instead.")


  unfulfilledDiscountedTotalSet: MoneyBag!


  unfulfilledOriginalTotal: Money! @deprecated(reason: "Use `unfulfilledOriginalTotalSet` instead.")


  unfulfilledOriginalTotalSet: MoneyBag!


  unfulfilledQuantity: Int!


  variant: ProductVariant


  variantTitle: String


  vendor: String
}


type LineItemMutableConnection {

  edges: [LineItemMutableEdge!]!


  nodes: [LineItemMutable!]!


  pageInfo: PageInfo!
}


type LineItemMutableEdge {

  cursor: String!


  node: LineItemMutable!
}


type LineItemSellingPlan {

  name: String!


  sellingPlanId: ID
}


type Link implements HasPublishedTranslations {

  label: String!


  translations(

    locale: String!


    marketId: ID
  ): [Translation!]!


  url: URL!
}


type Locale {

  isoCode: String!


  name: String!
}


enum LocalizableContentType {

  JSON_STRING


  JSON


  LIST_MULTI_LINE_TEXT_FIELD


  LIST_SINGLE_LINE_TEXT_FIELD


  LIST_URL


  MULTI_LINE_TEXT_FIELD


  RICH_TEXT_FIELD


  SINGLE_LINE_TEXT_FIELD


  STRING


  URL


  FILE_REFERENCE


  LIST_FILE_REFERENCE


  HTML


  URI


  INLINE_RICH_TEXT
}


type LocalizationExtension {

  countryCode: CountryCode!


  key: LocalizationExtensionKey!


  purpose: LocalizationExtensionPurpose!


  title: String!


  value: String!
}


type LocalizationExtensionConnection {

  edges: [LocalizationExtensionEdge!]!


  nodes: [LocalizationExtension!]!


  pageInfo: PageInfo!
}


type LocalizationExtensionEdge {

  cursor: String!


  node: LocalizationExtension!
}


input LocalizationExtensionInput {

  key: LocalizationExtensionKey!


  value: String!
}


enum LocalizationExtensionKey {

  TAX_CREDENTIAL_BR


  SHIPPING_CREDENTIAL_BR


  SHIPPING_CREDENTIAL_CN


  TAX_CREDENTIAL_IT


  TAX_EMAIL_IT


  SHIPPING_CREDENTIAL_KR
}


enum LocalizationExtensionPurpose {

  SHIPPING


  TAX
}


type Location implements HasMetafieldDefinitions & HasMetafields & LegacyInteroperability & Node {

  activatable: Boolean!


  address: LocationAddress!


  addressVerified: Boolean!


  deactivatable: Boolean!


  deactivatedAt: String


  deletable: Boolean!


  fulfillmentService: FulfillmentService


  fulfillsOnlineOrders: Boolean!


  hasActiveInventory: Boolean!


  hasUnfulfilledOrders: Boolean!


  id: ID!


  inventoryLevel(

    inventoryItemId: ID!
  ): InventoryLevel


  inventoryLevels(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    query: String
  ): InventoryLevelConnection!


  isActive: Boolean!


  isPrimary: Boolean! @deprecated(reason: "The concept of a primary location is deprecated, shipsInventory can be used to get a fallback location")


  legacyResourceId: UnsignedInt64!


  localPickupSettingsV2: DeliveryLocalPickupSettings


  metafield(

    namespace: String


    key: String!
  ): Metafield


  metafieldDefinitions(

    namespace: String


    pinnedStatus: MetafieldDefinitionPinnedStatus = ANY


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: MetafieldDefinitionSortKeys = ID


    query: String
  ): MetafieldDefinitionConnection!


  metafields(

    namespace: String


    keys: [String!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  name: String!


  privateMetafield(

    namespace: String!


    key: String!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  shipsInventory: Boolean!


  suggestedAddresses: [LocationSuggestedAddress!]!
}


type LocationActivatePayload {

  location: Location


  locationActivateUserErrors: [LocationActivateUserError!]!
}


type LocationActivateUserError implements DisplayableError {

  code: LocationActivateUserErrorCode


  field: [String!]


  message: String!
}


enum LocationActivateUserErrorCode {

  GENERIC_ERROR


  LOCATION_LIMIT


  HAS_ONGOING_RELOCATION


  LOCATION_NOT_FOUND


  HAS_NON_UNIQUE_NAME
}


input LocationAddAddressInput {

  address1: String


  address2: String


  city: String


  phone: String


  zip: String


  countryCode: CountryCode!


  provinceCode: String
}


input LocationAddInput {

  name: String!


  address: LocationAddAddressInput!


  fulfillsOnlineOrders: Boolean = true


  metafields: [MetafieldInput!]
}


type LocationAddPayload {

  location: Location


  userErrors: [LocationAddUserError!]!
}


type LocationAddress {

  address1: String


  address2: String


  city: String


  country: String


  countryCode: String


  formatted: [String!]!


  latitude: Float


  longitude: Float


  phone: String


  province: String


  provinceCode: String


  zip: String
}


type LocationAddUserError implements DisplayableError {

  code: LocationAddUserErrorCode


  field: [String!]


  message: String!
}


enum LocationAddUserErrorCode {

  INVALID


  TOO_LONG


  TAKEN


  BLANK


  INVALID_US_ZIPCODE


  GENERIC_ERROR


  INVALID_TYPE


  INVALID_VALUE


  APP_NOT_AUTHORIZED


  UNSTRUCTURED_RESERVED_NAMESPACE


  DISALLOWED_OWNER_TYPE


  INCLUSION


  PRESENT


  TOO_SHORT
}


type LocationConnection {

  edges: [LocationEdge!]!


  nodes: [Location!]!


  pageInfo: PageInfo!
}


type LocationDeactivatePayload {

  location: Location


  locationDeactivateUserErrors: [LocationDeactivateUserError!]!
}


type LocationDeactivateUserError implements DisplayableError {

  code: LocationDeactivateUserErrorCode


  field: [String!]


  message: String!
}


enum LocationDeactivateUserErrorCode {

  LOCATION_NOT_FOUND


  PERMANENTLY_BLOCKED_FROM_DEACTIVATION_ERROR


  TEMPORARILY_BLOCKED_FROM_DEACTIVATION_ERROR


  HAS_ACTIVE_RETAIL_SUBSCRIPTIONS


  DESTINATION_LOCATION_IS_THE_SAME_LOCATION


  DESTINATION_LOCATION_NOT_FOUND_OR_INACTIVE


  HAS_ACTIVE_INVENTORY_ERROR


  HAS_FULFILLMENT_ORDERS_ERROR


  HAS_OPEN_TRANSFERS_ERROR


  HAS_INCOMING_MOVEMENTS_ERROR


  HAS_OPEN_PURCHASE_ORDERS_ERROR


  FAILED_TO_RELOCATE_ACTIVE_INVENTORIES


  FAILED_TO_RELOCATE_OPEN_TRANSFERS


  FAILED_TO_RELOCATE_OPEN_PURCHASE_ORDERS


  FAILED_TO_RELOCATE_INCOMING_MOVEMENTS


  CANNOT_DISABLE_ONLINE_ORDER_FULFILLMENT
}


type LocationDeletePayload {

  deletedLocationId: ID


  locationDeleteUserErrors: [LocationDeleteUserError!]!
}


type LocationDeleteUserError implements DisplayableError {

  code: LocationDeleteUserErrorCode


  field: [String!]


  message: String!
}


enum LocationDeleteUserErrorCode {

  LOCATION_NOT_FOUND


  LOCATION_IS_ACTIVE


  GENERIC_ERROR


  LOCATION_HAS_INVENTORY


  LOCATION_HAS_PENDING_ORDERS


  LOCATION_HAS_ACTIVE_RETAIL_SUBSCRIPTION
}


type LocationEdge {

  cursor: String!


  node: Location!
}


input LocationEditAddressInput {

  address1: String


  address2: String


  city: String


  phone: String


  zip: String


  countryCode: CountryCode


  provinceCode: String
}


input LocationEditInput {

  name: String


  address: LocationEditAddressInput


  fulfillsOnlineOrders: Boolean


  metafields: [MetafieldInput!]
}


type LocationEditPayload {

  location: Location


  userErrors: [LocationEditUserError!]!
}


type LocationEditUserError implements DisplayableError {

  code: LocationEditUserErrorCode


  field: [String!]


  message: String!
}


enum LocationEditUserErrorCode {

  TOO_LONG


  BLANK


  NOT_FOUND


  INVALID


  TAKEN


  INVALID_US_ZIPCODE


  GENERIC_ERROR


  CANNOT_DISABLE_ONLINE_ORDER_FULFILLMENT


  CANNOT_MODIFY_ONLINE_ORDER_FULFILLMENT_FOR_FS_LOCATION


  INVALID_TYPE


  INVALID_VALUE


  APP_NOT_AUTHORIZED


  UNSTRUCTURED_RESERVED_NAMESPACE


  DISALLOWED_OWNER_TYPE


  INCLUSION


  PRESENT


  TOO_SHORT
}


type LocationLocalPickupDisablePayload {

  locationId: ID


  userErrors: [DeliveryLocationLocalPickupSettingsError!]!
}


type LocationLocalPickupEnablePayload {

  localPickupSettings: DeliveryLocalPickupSettings


  userErrors: [DeliveryLocationLocalPickupSettingsError!]!
}


enum LocationSortKeys {

  NAME


  ID


  RELEVANCE
}


type LocationSuggestedAddress {

  address1: String


  address2: String


  city: String


  country: String


  countryCode: CountryCode


  formatted: [String!]!


  province: String


  provinceCode: String


  zip: String
}


type MailingAddress implements Node {

  address1: String


  address2: String


  city: String


  company: String


  coordinatesValidated: Boolean!


  country: String


  countryCode: String @deprecated(reason: "Use `countryCodeV2` instead.")


  countryCodeV2: CountryCode


  firstName: String


  formatted(

    withName: Boolean = false


    withCompany: Boolean = true
  ): [String!]!


  formattedArea: String


  id: ID!


  lastName: String


  latitude: Float


  longitude: Float


  name: String


  phone: String


  province: String


  provinceCode: String


  timeZone: String


  zip: String
}


type MailingAddressConnection {

  edges: [MailingAddressEdge!]!


  nodes: [MailingAddress!]!


  pageInfo: PageInfo!
}


type MailingAddressEdge {

  cursor: String!


  node: MailingAddress!
}


input MailingAddressInput {

  address1: String


  address2: String


  city: String


  company: String


  countryCode: CountryCode


  firstName: String


  lastName: String


  phone: String


  provinceCode: String


  zip: String
}


type ManualDiscountApplication implements DiscountApplication {

  allocationMethod: DiscountApplicationAllocationMethod!


  description: String


  index: Int!


  targetSelection: DiscountApplicationTargetSelection!


  targetType: DiscountApplicationTargetType!


  title: String!


  value: PricingValue!
}


type Market implements HasMetafieldDefinitions & HasMetafields & Node {

  catalogs(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MarketCatalogConnection!


  currencySettings: MarketCurrencySettings!


  enabled: Boolean!


  handle: String!


  id: ID!


  metafield(

    namespace: String


    key: String!
  ): Metafield


  metafieldDefinitions(

    namespace: String


    pinnedStatus: MetafieldDefinitionPinnedStatus = ANY


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: MetafieldDefinitionSortKeys = ID


    query: String
  ): MetafieldDefinitionConnection!


  metafields(

    namespace: String


    keys: [String!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  name: String!


  priceList: PriceList @deprecated(reason: "Use `catalogs` instead.")


  primary: Boolean!


  privateMetafield(

    namespace: String!


    key: String!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  regions(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MarketRegionConnection!


  webPresence: MarketWebPresence


  webPresences(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MarketWebPresenceConnection!
}


type MarketCatalog implements Catalog & Node {

  id: ID!


  markets(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MarketConnection!


  operations: [ResourceOperation!]!


  priceList: PriceList


  publication: Publication


  status: CatalogStatus!


  title: String!
}


type MarketCatalogConnection {

  edges: [MarketCatalogEdge!]!


  nodes: [MarketCatalog!]!


  pageInfo: PageInfo!
}


type MarketCatalogEdge {

  cursor: String!


  node: MarketCatalog!
}


type MarketConnection {

  edges: [MarketEdge!]!


  nodes: [Market!]!


  pageInfo: PageInfo!
}


input MarketCreateInput {

  name: String!


  handle: String


  enabled: Boolean


  regions: [MarketRegionCreateInput!]!
}


type MarketCreatePayload {

  market: Market


  userErrors: [MarketUserError!]!
}


type MarketCurrencySettings {

  baseCurrency: CurrencySetting!


  localCurrencies: Boolean!
}


input MarketCurrencySettingsUpdateInput {

  baseCurrency: CurrencyCode


  localCurrencies: Boolean
}


type MarketCurrencySettingsUpdatePayload {

  market: Market


  userErrors: [MarketCurrencySettingsUserError!]!
}


type MarketCurrencySettingsUserError implements DisplayableError {

  code: MarketCurrencySettingsUserErrorCode


  field: [String!]


  message: String!
}


enum MarketCurrencySettingsUserErrorCode {

  MARKET_NOT_FOUND


  MANAGED_MARKET


  MULTIPLE_CURRENCIES_NOT_SUPPORTED


  NO_LOCAL_CURRENCIES_ON_SINGLE_COUNTRY_MARKET


  UNSUPPORTED_CURRENCY


  PRIMARY_MARKET_USES_SHOP_CURRENCY
}


type MarketDeletePayload {

  deletedId: ID


  userErrors: [MarketUserError!]!
}


type MarketEdge {

  cursor: String!


  node: Market!
}


type MarketingActivitiesDeleteAllExternalPayload {

  job: Job


  userErrors: [MarketingActivityUserError!]!
}


type MarketingActivity implements Node {

  activityListUrl: URL


  adSpend: MoneyV2


  app: App!


  appErrors: MarketingActivityExtensionAppErrors


  budget: MarketingBudget


  createdAt: DateTime!


  formData: String


  hierarchyLevel: MarketingActivityHierarchyLevel


  id: ID!


  inMainWorkflowVersion: Boolean!


  marketingChannel: MarketingChannel! @deprecated(reason: "Use `marketingChannelType` instead.")


  marketingChannelType: MarketingChannel!


  marketingEvent: MarketingEvent


  parentActivityId: ID


  parentRemoteId: String


  sourceAndMedium: String!


  status: MarketingActivityStatus!


  statusBadgeType: MarketingActivityStatusBadgeType @deprecated(reason: "Use `statusBadgeTypeV2` instead.")


  statusBadgeTypeV2: BadgeType


  statusLabel: String!


  statusTransitionedAt: DateTime


  tactic: MarketingTactic!


  targetStatus: MarketingActivityStatus


  title: String!


  updatedAt: DateTime!


  urlParameterValue: String


  utmParameters: UTMParameters
}


input MarketingActivityBudgetInput {

  budgetType: MarketingBudgetBudgetType


  total: MoneyInput
}


type MarketingActivityConnection {

  edges: [MarketingActivityEdge!]!


  nodes: [MarketingActivity!]!


  pageInfo: PageInfo!
}


input MarketingActivityCreateExternalInput {

  title: String!


  utm: UTMInput


  urlParameterValue: String


  budget: MarketingActivityBudgetInput


  adSpend: MoneyInput


  remoteId: String


  status: MarketingActivityExternalStatus


  remoteUrl: URL!


  remotePreviewImageUrl: URL


  tactic: MarketingTactic!


  marketingChannelType: MarketingChannel!


  referringDomain: String


  channelHandle: String


  scheduledStart: DateTime


  scheduledEnd: DateTime


  start: DateTime


  end: DateTime


  parentActivityId: ID


  parentRemoteId: String


  hierarchyLevel: MarketingActivityHierarchyLevel
}


type MarketingActivityCreateExternalPayload {

  marketingActivity: MarketingActivity


  userErrors: [MarketingActivityUserError!]!
}


input MarketingActivityCreateInput {

  marketingActivityTitle: String


  formData: String


  marketingActivityExtensionId: ID!


  context: String


  utm: UTMInput


  status: MarketingActivityStatus!


  budget: MarketingActivityBudgetInput
}


type MarketingActivityCreatePayload {

  marketingActivity: MarketingActivity


  redirectPath: String


  userErrors: [UserError!]!
}


type MarketingActivityDeleteExternalPayload {

  deletedMarketingActivityId: ID


  userErrors: [MarketingActivityUserError!]!
}


type MarketingActivityEdge {

  cursor: String!


  node: MarketingActivity!
}


enum MarketingActivityExtensionAppErrorCode {

  NOT_ONBOARDED_ERROR


  VALIDATION_ERROR


  API_ERROR


  PLATFORM_ERROR


  INSTALL_REQUIRED_ERROR
}


type MarketingActivityExtensionAppErrors {

  code: MarketingActivityExtensionAppErrorCode!


  userErrors: [UserError!]!
}


enum MarketingActivityExternalStatus {

  ACTIVE


  INACTIVE


  PAUSED


  SCHEDULED


  DELETED_EXTERNALLY


  UNDEFINED
}


enum MarketingActivityHierarchyLevel {

  AD


  AD_GROUP


  CAMPAIGN
}


enum MarketingActivitySortKeys {

  TITLE


  CREATED_AT


  ID


  RELEVANCE
}


enum MarketingActivityStatus {

  ACTIVE


  DELETED


  DELETED_EXTERNALLY


  DISCONNECTED


  DRAFT


  FAILED


  INACTIVE


  PAUSED


  PENDING


  SCHEDULED


  UNDEFINED
}


enum MarketingActivityStatusBadgeType {

  DEFAULT


  SUCCESS


  ATTENTION


  WARNING


  INFO
}


input MarketingActivityUpdateExternalInput {

  title: String


  budget: MarketingActivityBudgetInput


  adSpend: MoneyInput


  remoteUrl: URL


  remotePreviewImageUrl: URL


  tactic: MarketingTactic


  marketingChannelType: MarketingChannel


  referringDomain: String


  scheduledStart: DateTime


  scheduledEnd: DateTime


  start: DateTime


  end: DateTime


  status: MarketingActivityExternalStatus
}


type MarketingActivityUpdateExternalPayload {

  marketingActivity: MarketingActivity


  userErrors: [MarketingActivityUserError!]!
}


input MarketingActivityUpdateInput {

  id: ID!


  marketingRecommendationId: ID


  title: String


  budget: MarketingActivityBudgetInput


  status: MarketingActivityStatus


  targetStatus: MarketingActivityStatus


  formData: String


  utm: UTMInput


  marketedResources: [ID!]


  errors: JSON
}


type MarketingActivityUpdatePayload {

  marketingActivity: MarketingActivity


  redirectPath: String


  userErrors: [UserError!]!
}


input MarketingActivityUpsertExternalInput {

  title: String!


  utm: UTMInput


  budget: MarketingActivityBudgetInput


  adSpend: MoneyInput


  remoteId: String!


  status: MarketingActivityExternalStatus!


  remoteUrl: URL!


  remotePreviewImageUrl: URL


  tactic: MarketingTactic!


  marketingChannelType: MarketingChannel!


  referringDomain: String


  channelHandle: String


  scheduledStart: DateTime


  scheduledEnd: DateTime


  start: DateTime


  end: DateTime


  urlParameterValue: String


  parentRemoteId: String


  hierarchyLevel: MarketingActivityHierarchyLevel
}


type MarketingActivityUpsertExternalPayload {

  marketingActivity: MarketingActivity


  userErrors: [MarketingActivityUserError!]!
}


type MarketingActivityUserError implements DisplayableError {

  code: MarketingActivityUserErrorCode


  field: [String!]


  message: String!
}


enum MarketingActivityUserErrorCode {

  INVALID


  TAKEN


  MARKETING_ACTIVITY_DOES_NOT_EXIST


  MARKETING_EVENT_DOES_NOT_EXIST


  CURRENCY_CODE_MISMATCH_INPUT


  MARKETING_ACTIVITY_CURRENCY_CODE_MISMATCH


  DELETE_JOB_FAILED_TO_ENQUEUE


  NON_HIERARCHIAL_REQUIRES_UTM_URL_PARAMETER


  DELETE_JOB_ENQUEUED


  ACTIVITY_NOT_EXTERNAL


  IMMUTABLE_CHANNEL_HANDLE


  IMMUTABLE_URL_PARAMETER


  IMMUTABLE_UTM_PARAMETERS


  IMMUTABLE_PARENT_ID


  IMMUTABLE_HIERARCHY_LEVEL


  INVALID_REMOTE_ID


  INVALID_CHANNEL_HANDLE


  INVALID_DELETE_ACTIVITY_EXTERNAL_ARGUMENTS


  INVALID_DELETE_ENGAGEMENTS_ARGUMENTS


  INVALID_MARKETING_ACTIVITY_EXTERNAL_ARGUMENTS


  INVALID_MARKETING_ENGAGEMENT_ARGUMENTS


  INVALID_MARKETING_ENGAGEMENT_ARGUMENT_MISSING


  CANNOT_DELETE_ACTIVITY_WITH_CHILD_EVENTS


  CANNOT_UPDATE_TACTIC_TO_STOREFRONT_APP


  CANNOT_UPDATE_TACTIC_IF_ORIGINALLY_STOREFRONT_APP
}


type MarketingBudget {

  budgetType: MarketingBudgetBudgetType!


  total: MoneyV2!
}


enum MarketingBudgetBudgetType {

  DAILY


  LIFETIME
}


enum MarketingChannel {

  SEARCH


  DISPLAY


  SOCIAL


  EMAIL


  REFERRAL
}


type MarketingEngagement {

  adSpend: MoneyV2


  channelHandle: String


  clicksCount: Int


  commentsCount: Int


  complaintsCount: Int


  failsCount: Int


  favoritesCount: Int


  firstTimeCustomers: Decimal


  impressionsCount: Int


  isCumulative: Boolean!


  marketingActivity: MarketingActivity


  occurredOn: Date!


  orders: Decimal


  returningCustomers: Decimal


  sales: MoneyV2


  sendsCount: Int


  sessionsCount: Int


  sharesCount: Int


  uniqueClicksCount: Int


  uniqueViewsCount: Int


  unsubscribesCount: Int


  utcOffset: UtcOffset!


  viewsCount: Int
}


type MarketingEngagementCreatePayload {

  marketingEngagement: MarketingEngagement


  userErrors: [UserError!]!
}


input MarketingEngagementInput {

  occurredOn: Date!


  impressionsCount: Int


  viewsCount: Int


  clicksCount: Int


  sharesCount: Int


  favoritesCount: Int


  commentsCount: Int


  unsubscribesCount: Int


  complaintsCount: Int


  failsCount: Int


  sendsCount: Int


  uniqueViewsCount: Int


  uniqueClicksCount: Int


  adSpend: MoneyInput


  isCumulative: Boolean!


  utcOffset: UtcOffset!


  sales: MoneyInput


  sessionsCount: Int


  orders: Decimal


  firstTimeCustomers: Decimal


  returningCustomers: Decimal
}


type MarketingEngagementsDeletePayload {

  result: String


  userErrors: [MarketingActivityUserError!]!
}


type MarketingEvent implements LegacyInteroperability & Node {

  app: App!


  channel: MarketingChannel @deprecated(reason: "Use `marketingChannelType` instead.")


  channelHandle: String


  description: String


  endedAt: DateTime


  id: ID!


  legacyResourceId: UnsignedInt64!


  manageUrl: URL


  marketingChannelType: MarketingChannel


  previewUrl: URL


  remoteId: String


  scheduledToEndAt: DateTime


  sourceAndMedium: String!


  startedAt: DateTime!


  targetTypeDisplayText: String! @deprecated(reason: "Use `sourceAndMedium` instead.")


  type: MarketingTactic!


  utmCampaign: String


  utmMedium: String


  utmSource: String
}


type MarketingEventConnection {

  edges: [MarketingEventEdge!]!


  nodes: [MarketingEvent!]!


  pageInfo: PageInfo!
}


type MarketingEventEdge {

  cursor: String!


  node: MarketingEvent!
}


enum MarketingEventSortKeys {

  STARTED_AT


  ID


  RELEVANCE
}


enum MarketingTactic {

  ABANDONED_CART


  AD


  AFFILIATE


  LINK


  LOYALTY


  MESSAGE


  NEWSLETTER


  NOTIFICATION


  POST


  RETARGETING


  TRANSACTIONAL


  STOREFRONT_APP


  SEO


  DIRECT @deprecated(reason: "`DIRECT` is deprecated. Use `LINK` instead.")


  DISPLAY @deprecated(reason: "`DISPLAY` is deprecated. Use `AD` instead.")


  SEARCH @deprecated(reason: "`SEARCH` is deprecated. Use `AD` instead.")


  FOLLOW_UP @deprecated(reason: "'FOLLOW_UP' is deprecated. Use 'TRANSACTIONAL' instead.")


  RECEIPT @deprecated(reason: "'RECEIPT' is deprecated. Use 'TRANSACTIONAL' instead.")
}


type MarketLocalizableContent {

  digest: String


  key: String!


  value: String
}


type MarketLocalizableResource {

  marketLocalizableContent: [MarketLocalizableContent!]!


  marketLocalizations(

    marketId: ID!
  ): [MarketLocalization!]!


  resourceId: ID!
}


type MarketLocalizableResourceConnection {

  edges: [MarketLocalizableResourceEdge!]!


  nodes: [MarketLocalizableResource!]!


  pageInfo: PageInfo!
}


type MarketLocalizableResourceEdge {

  cursor: String!


  node: MarketLocalizableResource!
}


enum MarketLocalizableResourceType {

  METAFIELD


  METAOBJECT
}


type MarketLocalization {

  key: String!


  market: Market!


  outdated: Boolean!


  updatedAt: DateTime


  value: String
}


input MarketLocalizationRegisterInput {

  marketId: ID!


  key: String!


  value: String!


  marketLocalizableContentDigest: String!
}


type MarketLocalizationsRegisterPayload {

  marketLocalizations: [MarketLocalization!]


  userErrors: [TranslationUserError!]!
}


type MarketLocalizationsRemovePayload {

  marketLocalizations: [MarketLocalization!]


  userErrors: [TranslationUserError!]!
}


interface MarketRegion {

  id: ID!


  name: String!
}


type MarketRegionConnection {

  edges: [MarketRegionEdge!]!


  nodes: [MarketRegion!]!


  pageInfo: PageInfo!
}


type MarketRegionCountry implements MarketRegion & Node {

  code: CountryCode!


  currency: CurrencySetting!


  id: ID!


  name: String!
}


input MarketRegionCreateInput {

  countryCode: CountryCode!
}


type MarketRegionDeletePayload {

  deletedId: ID


  market: Market


  userErrors: [MarketUserError!]!
}


type MarketRegionEdge {

  cursor: String!


  node: MarketRegion!
}


type MarketRegionsCreatePayload {

  market: Market


  userErrors: [MarketUserError!]!
}


type MarketRegionsDeletePayload {

  deletedIds: [ID!]


  userErrors: [MarketUserError!]!
}


input MarketUpdateInput {

  name: String


  handle: String


  enabled: Boolean
}


type MarketUpdatePayload {

  market: Market


  userErrors: [MarketUserError!]!
}


type MarketUserError implements DisplayableError {

  code: MarketUserErrorCode


  field: [String!]


  message: String!
}


enum MarketUserErrorCode {

  INVALID


  TAKEN


  TOO_LONG


  TOO_SHORT


  BLANK


  MARKET_NOT_FOUND


  REGION_NOT_FOUND


  WEB_PRESENCE_NOT_FOUND


  CANNOT_ADD_REGIONS_TO_PRIMARY_MARKET


  CANNOT_DELETE_ONLY_REGION


  REQUIRES_EXACTLY_ONE_OPTION


  CANNOT_DELETE_PRIMARY_MARKET


  DOMAIN_NOT_FOUND


  SUBFOLDER_SUFFIX_MUST_CONTAIN_ONLY_LETTERS


  SUBFOLDER_SUFFIX_CANNOT_BE_SCRIPT_CODE


  NO_LANGUAGES


  DUPLICATE_LANGUAGES


  REGION_SPECIFIC_LANGUAGE


  CANNOT_HAVE_SUBFOLDER_AND_DOMAIN


  CANNOT_ADD_WEB_PRESENCE_TO_PRIMARY_MARKET


  MARKET_REACHED_WEB_PRESENCE_LIMIT


  CANNOT_HAVE_MULTIPLE_SUBFOLDERS_PER_MARKET


  CANNOT_HAVE_BOTH_SUBFOLDER_AND_DOMAIN_WEB_PRESENCES


  REQUIRES_DOMAIN_OR_SUBFOLDER


  PRIMARY_MARKET_MUST_USE_PRIMARY_DOMAIN


  CANNOT_DELETE_PRIMARY_MARKET_WEB_PRESENCE


  SHOP_REACHED_MARKETS_LIMIT


  CANNOT_DISABLE_PRIMARY_MARKET


  UNPUBLISHED_LANGUAGE


  DISABLED_LANGUAGE


  CANNOT_SET_DEFAULT_LOCALE_TO_NULL


  UNSUPPORTED_COUNTRY_REGION


  CANNOT_ADD_CUSTOMER_DOMAIN
}


type MarketWebPresence implements Node {

  alternateLocales: [String!]!


  defaultLocale: String!


  domain: Domain


  id: ID!


  market: Market!


  rootUrls: [MarketWebPresenceRootUrl!]!


  subfolderSuffix: String
}


type MarketWebPresenceConnection {

  edges: [MarketWebPresenceEdge!]!


  nodes: [MarketWebPresence!]!


  pageInfo: PageInfo!
}


input MarketWebPresenceCreateInput {

  domainId: ID


  defaultLocale: String!


  alternateLocales: [String!]


  subfolderSuffix: String
}


type MarketWebPresenceCreatePayload {

  market: Market


  userErrors: [MarketUserError!]!
}


type MarketWebPresenceDeletePayload {

  deletedId: ID


  market: Market


  userErrors: [MarketUserError!]!
}


type MarketWebPresenceEdge {

  cursor: String!


  node: MarketWebPresence!
}


type MarketWebPresenceRootUrl {

  locale: String!


  url: URL!
}


input MarketWebPresenceUpdateInput {

  domainId: ID


  defaultLocale: String


  alternateLocales: [String!]


  subfolderSuffix: String
}


type MarketWebPresenceUpdatePayload {

  market: Market


  userErrors: [MarketUserError!]!
}


interface Media {

  alt: String


  id: ID!


  mediaContentType: MediaContentType!


  mediaErrors: [MediaError!]!


  mediaWarnings: [MediaWarning!]!


  preview: MediaPreviewImage


  status: MediaStatus!
}


type MediaConnection {

  edges: [MediaEdge!]!


  nodes: [Media!]!


  pageInfo: PageInfo!
}


enum MediaContentType {

  VIDEO


  EXTERNAL_VIDEO


  MODEL_3D


  IMAGE
}


type MediaEdge {

  cursor: String!


  node: Media!
}


type MediaError {

  code: MediaErrorCode!


  details: String


  message: String!
}


enum MediaErrorCode {

  UNKNOWN


  INVALID_SIGNED_URL


  IMAGE_DOWNLOAD_FAILURE


  IMAGE_PROCESSING_FAILURE


  MEDIA_TIMEOUT_ERROR


  EXTERNAL_VIDEO_NOT_FOUND


  EXTERNAL_VIDEO_UNLISTED


  EXTERNAL_VIDEO_INVALID_ASPECT_RATIO


  EXTERNAL_VIDEO_EMBED_DISABLED


  EXTERNAL_VIDEO_EMBED_NOT_FOUND_OR_TRANSCODING


  GENERIC_FILE_DOWNLOAD_FAILURE


  GENERIC_FILE_INVALID_SIZE


  VIDEO_METADATA_READ_ERROR


  VIDEO_INVALID_FILETYPE_ERROR


  VIDEO_MIN_WIDTH_ERROR


  VIDEO_MAX_WIDTH_ERROR


  VIDEO_MIN_HEIGHT_ERROR


  VIDEO_MAX_HEIGHT_ERROR


  VIDEO_MIN_DURATION_ERROR


  VIDEO_MAX_DURATION_ERROR


  VIDEO_VALIDATION_ERROR


  MODEL3D_VALIDATION_ERROR


  MODEL3D_THUMBNAIL_GENERATION_ERROR


  MODEL3D_THUMBNAIL_REGENERATION_ERROR


  MODEL3D_GLB_TO_USDZ_CONVERSION_ERROR


  MODEL3D_GLB_OUTPUT_CREATION_ERROR


  MODEL3D_PROCESSING_FAILURE


  UNSUPPORTED_IMAGE_FILE_TYPE


  INVALID_IMAGE_FILE_SIZE


  INVALID_IMAGE_ASPECT_RATIO


  INVALID_IMAGE_RESOLUTION


  FILE_STORAGE_LIMIT_EXCEEDED


  DUPLICATE_FILENAME_ERROR
}


enum MediaHost {

  YOUTUBE


  VIMEO
}


type MediaImage implements File & HasMetafields & Media & Node {

  alt: String


  createdAt: DateTime!


  fileErrors: [FileError!]!


  fileStatus: FileStatus!


  id: ID!


  image: Image


  mediaContentType: MediaContentType!


  mediaErrors: [MediaError!]!


  mediaWarnings: [MediaWarning!]!


  metafield(

    namespace: String


    key: String!
  ): Metafield


  metafields(

    namespace: String


    keys: [String!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  mimeType: String


  originalSource: MediaImageOriginalSource


  preview: MediaPreviewImage


  privateMetafield(

    namespace: String!


    key: String!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  status: MediaStatus!


  updatedAt: DateTime!
}


type MediaImageOriginalSource {

  fileSize: Int


  url: URL
}


type MediaPreviewImage {

  image: Image


  status: MediaPreviewImageStatus!
}


enum MediaPreviewImageStatus {

  UPLOADED


  PROCESSING


  READY


  FAILED
}


enum MediaStatus {

  UPLOADED


  PROCESSING


  READY


  FAILED
}


type MediaUserError implements DisplayableError {

  code: MediaUserErrorCode


  field: [String!]


  message: String!
}


enum MediaUserErrorCode {

  INVALID


  BLANK


  VIDEO_VALIDATION_ERROR


  MODEL3D_VALIDATION_ERROR


  VIDEO_THROTTLE_EXCEEDED


  MODEL3D_THROTTLE_EXCEEDED


  PRODUCT_MEDIA_LIMIT_EXCEEDED


  SHOP_MEDIA_LIMIT_EXCEEDED


  PRODUCT_DOES_NOT_EXIST


  MEDIA_DOES_NOT_EXIST


  MEDIA_DOES_NOT_EXIST_ON_PRODUCT


  TOO_MANY_MEDIA_PER_INPUT_PAIR


  MAXIMUM_VARIANT_MEDIA_PAIRS_EXCEEDED


  INVALID_MEDIA_TYPE


  PRODUCT_VARIANT_SPECIFIED_MULTIPLE_TIMES


  PRODUCT_VARIANT_DOES_NOT_EXIST_ON_PRODUCT


  NON_READY_MEDIA


  PRODUCT_VARIANT_ALREADY_HAS_MEDIA


  MEDIA_IS_NOT_ATTACHED_TO_VARIANT


  MEDIA_CANNOT_BE_MODIFIED
}


type MediaWarning {

  code: MediaWarningCode!


  message: String
}


enum MediaWarningCode {

  MODEL_SMALL_PHYSICAL_SIZE


  MODEL_LARGE_PHYSICAL_SIZE
}


enum MerchandiseDiscountClass {

  PRODUCT


  ORDER
}


type MerchantApprovalSignals {

  identityVerified: Boolean!


  verifiedByShopify: Boolean!


  verifiedByShopifyTier: String!
}


type Metafield implements LegacyInteroperability & Node {

  createdAt: DateTime!


  definition: MetafieldDefinition


  description: String


  id: ID!


  key: String!


  legacyResourceId: UnsignedInt64!


  namespace: String!


  owner: HasMetafields!


  ownerType: MetafieldOwnerType!


  reference: MetafieldReference


  references(

    first: Int


    after: String


    last: Int


    before: String
  ): MetafieldReferenceConnection


  type: String!


  updatedAt: DateTime!


  value: String!
}


type MetafieldAccess {

  admin: MetafieldAdminAccess


  grants: [MetafieldAccessGrant!]!


  storefront: MetafieldStorefrontAccess
}


type MetafieldAccessGrant {

  access: MetafieldGrantAccessLevel!


  grantee: String!
}


input MetafieldAccessGrantDeleteInput {

  grantee: String!
}


input MetafieldAccessGrantInput {

  grantee: String!


  access: MetafieldGrantAccessLevel!
}


input MetafieldAccessGrantOperationInput {

  create: MetafieldAccessGrantInput


  update: MetafieldAccessGrantInput


  delete: MetafieldAccessGrantDeleteInput
}


input MetafieldAccessInput {

  admin: MetafieldAdminAccess!


  storefront: MetafieldStorefrontAccess


  grants: [MetafieldAccessGrantInput!]
}


input MetafieldAccessUpdateInput {

  admin: MetafieldAdminAccess!


  storefront: MetafieldStorefrontAccess


  grants: [MetafieldAccessGrantOperationInput!]
}


enum MetafieldAdminAccess {

  PRIVATE


  PUBLIC_READ


  MERCHANT_READ


  MERCHANT_READ_WRITE
}


type MetafieldConnection {

  edges: [MetafieldEdge!]!


  nodes: [Metafield!]!


  pageInfo: PageInfo!
}


type MetafieldDefinition implements Node {

  access: MetafieldAccess!


  description: String


  id: ID!


  key: String!


  metafields(

    validationStatus: MetafieldValidationStatus = ANY


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  metafieldsCount(

    validationStatus: MetafieldValidationStatus
  ): Int!


  name: String!


  namespace: String!


  ownerType: MetafieldOwnerType!


  pinnedPosition: Int


  standardTemplate: StandardMetafieldDefinitionTemplate


  type: MetafieldDefinitionType!


  useAsCollectionCondition: Boolean!


  validationStatus: MetafieldDefinitionValidationStatus!


  validations: [MetafieldDefinitionValidation!]!


  visibleToStorefrontApi: Boolean! @deprecated(reason: "Use `access.storefront` instead.")
}


type MetafieldDefinitionConnection {

  edges: [MetafieldDefinitionEdge!]!


  nodes: [MetafieldDefinition!]!


  pageInfo: PageInfo!
}


type MetafieldDefinitionCreatePayload {

  createdDefinition: MetafieldDefinition


  userErrors: [MetafieldDefinitionCreateUserError!]!
}


type MetafieldDefinitionCreateUserError implements DisplayableError {

  code: MetafieldDefinitionCreateUserErrorCode


  field: [String!]


  message: String!
}


enum MetafieldDefinitionCreateUserErrorCode {

  INVALID


  INCLUSION


  PRESENT


  TAKEN


  TOO_LONG


  TOO_SHORT


  RESOURCE_TYPE_LIMIT_EXCEEDED


  LIMIT_EXCEEDED


  INVALID_OPTION


  DUPLICATE_OPTION


  RESERVED_NAMESPACE_KEY


  PINNED_LIMIT_REACHED


  UNSTRUCTURED_ALREADY_EXISTS


  INVALID_CHARACTER


  TYPE_NOT_ALLOWED_FOR_CONDITIONS


  OWNER_TYPE_LIMIT_EXCEEDED_FOR_AUTOMATED_COLLECTIONS


  GRANT_LIMIT_EXCEEDED


  INVALID_INPUT_COMBINATION
}


type MetafieldDefinitionDeletePayload {

  deletedDefinitionId: ID


  userErrors: [MetafieldDefinitionDeleteUserError!]!
}


type MetafieldDefinitionDeleteUserError implements DisplayableError {

  code: MetafieldDefinitionDeleteUserErrorCode


  field: [String!]


  message: String!
}


enum MetafieldDefinitionDeleteUserErrorCode {

  PRESENT


  NOT_FOUND


  INTERNAL_ERROR


  REFERENCE_TYPE_DELETION_ERROR


  METAFIELD_DEFINITION_IN_USE


  DISALLOWED_OWNER_TYPE
}


type MetafieldDefinitionEdge {

  cursor: String!


  node: MetafieldDefinition!
}


input MetafieldDefinitionInput {

  namespace: String


  key: String!


  name: String!


  description: String


  ownerType: MetafieldOwnerType!


  type: String!


  validations: [MetafieldDefinitionValidationInput!]


  useAsCollectionCondition: Boolean = false


  pin: Boolean = false


  access: MetafieldAccessInput
}


enum MetafieldDefinitionPinnedStatus {

  ANY


  PINNED


  UNPINNED
}


type MetafieldDefinitionPinPayload {

  pinnedDefinition: MetafieldDefinition


  userErrors: [MetafieldDefinitionPinUserError!]!
}


type MetafieldDefinitionPinUserError implements DisplayableError {

  code: MetafieldDefinitionPinUserErrorCode


  field: [String!]


  message: String!
}


enum MetafieldDefinitionPinUserErrorCode {

  NOT_FOUND


  PINNED_LIMIT_REACHED


  ALREADY_PINNED


  INTERNAL_ERROR


  DISALLOWED_OWNER_TYPE
}


enum MetafieldDefinitionSortKeys {

  ID


  NAME


  PINNED_POSITION


  RELEVANCE
}


type MetafieldDefinitionSupportedValidation {

  name: String!


  type: String!
}


type MetafieldDefinitionType {

  category: String!


  name: String!


  supportedValidations: [MetafieldDefinitionSupportedValidation!]!


  supportsDefinitionMigrations: Boolean!


  valueType: MetafieldValueType! @deprecated(reason: "`valueType` is deprecated and `name` should be used for type information.")
}


type MetafieldDefinitionUnpinPayload {

  unpinnedDefinition: MetafieldDefinition


  userErrors: [MetafieldDefinitionUnpinUserError!]!
}


type MetafieldDefinitionUnpinUserError implements DisplayableError {

  code: MetafieldDefinitionUnpinUserErrorCode


  field: [String!]


  message: String!
}


enum MetafieldDefinitionUnpinUserErrorCode {

  NOT_FOUND


  NOT_PINNED


  INTERNAL_ERROR


  DISALLOWED_OWNER_TYPE
}


input MetafieldDefinitionUpdateInput {

  namespace: String


  key: String!


  name: String


  description: String


  ownerType: MetafieldOwnerType!


  validations: [MetafieldDefinitionValidationInput!]


  pin: Boolean


  useAsCollectionCondition: Boolean = false


  access: MetafieldAccessUpdateInput
}


type MetafieldDefinitionUpdatePayload {

  updatedDefinition: MetafieldDefinition


  userErrors: [MetafieldDefinitionUpdateUserError!]!


  validationJob: Job
}


type MetafieldDefinitionUpdateUserError implements DisplayableError {

  code: MetafieldDefinitionUpdateUserErrorCode


  field: [String!]


  message: String!
}


enum MetafieldDefinitionUpdateUserErrorCode {

  PRESENT


  TOO_LONG


  NOT_FOUND


  INVALID_INPUT


  PINNED_LIMIT_REACHED


  INTERNAL_ERROR


  TYPE_NOT_ALLOWED_FOR_CONDITIONS


  METAFIELD_DEFINITION_IN_USE


  OWNER_TYPE_LIMIT_EXCEEDED_FOR_AUTOMATED_COLLECTIONS


  METAOBJECT_DEFINITION_CHANGED


  GRANT_LIMIT_EXCEEDED


  INVALID_INPUT_COMBINATION
}


type MetafieldDefinitionValidation {

  name: String!


  type: String!


  value: String
}


input MetafieldDefinitionValidationInput {

  name: String!


  value: String!
}


enum MetafieldDefinitionValidationStatus {

  ALL_VALID


  IN_PROGRESS


  SOME_INVALID
}


input MetafieldDeleteInput {

  id: ID!
}


type MetafieldDeletePayload {

  deletedId: ID


  userErrors: [UserError!]!
}


type MetafieldEdge {

  cursor: String!


  node: Metafield!
}


enum MetafieldGrantAccessLevel {

  READ


  READ_WRITE
}


input MetafieldInput {

  id: ID


  namespace: String


  key: String


  value: String


  type: String
}


enum MetafieldOwnerType {

  API_PERMISSION


  COMPANY


  COMPANY_LOCATION


  PAYMENT_CUSTOMIZATION


  VALIDATION


  CUSTOMER


  DELIVERY_CUSTOMIZATION


  DRAFTORDER


  MARKET


  CARTTRANSFORM


  COLLECTION


  MEDIA_IMAGE


  PRODUCTIMAGE @deprecated(reason: "`PRODUCTIMAGE` is deprecated. Use `MEDIA_IMAGE` instead.")


  PRODUCT


  PRODUCTVARIANT


  ARTICLE


  BLOG


  PAGE


  FULFILLMENT_CONSTRAINT_RULE


  ORDER_ROUTING_LOCATION_RULE


  DISCOUNT


  ORDER


  LOCATION


  SHOP
}


union MetafieldReference = Collection | GenericFile | MediaImage | Metaobject | OnlineStorePage | Product | ProductVariant | Video


type MetafieldReferenceConnection {

  edges: [MetafieldReferenceEdge!]!


  nodes: [MetafieldReference]!


  pageInfo: PageInfo!
}


type MetafieldReferenceEdge {

  cursor: String!


  node: MetafieldReference
}


union MetafieldReferencer = AppInstallation | Collection | Company | CompanyLocation | Customer | DeliveryCustomization | DiscountAutomaticNode | DiscountCodeNode | DiscountNode | DraftOrder | FulfillmentOrder | Location | Market | Metaobject | OnlineStoreArticle | OnlineStoreBlog | OnlineStorePage | Order | PaymentCustomization | Product | ProductVariant | Shop


type MetafieldRelation {

  key: String!


  name: String!


  namespace: String!


  referencer: MetafieldReferencer!


  target: MetafieldReference!
}


type MetafieldRelationConnection {

  edges: [MetafieldRelationEdge!]!


  nodes: [MetafieldRelation!]!


  pageInfo: PageInfo!
}


type MetafieldRelationEdge {

  cursor: String!


  node: MetafieldRelation!
}


input MetafieldsSetInput {

  ownerId: ID!


  namespace: String


  key: String!


  value: String!


  type: String
}


type MetafieldsSetPayload {

  metafields: [Metafield!]


  userErrors: [MetafieldsSetUserError!]!
}


type MetafieldsSetUserError implements DisplayableError {

  code: MetafieldsSetUserErrorCode


  elementIndex: Int


  field: [String!]


  message: String!
}


enum MetafieldsSetUserErrorCode {

  BLANK


  INCLUSION


  LESS_THAN_OR_EQUAL_TO


  PRESENT


  TOO_SHORT


  TOO_LONG


  INVALID_VALUE


  INVALID_TYPE


  APP_NOT_AUTHORIZED


  CAPABILITY_VIOLATION
}


enum MetafieldStorefrontAccess {

  PUBLIC_READ


  NONE
}


type MetafieldStorefrontVisibility implements LegacyInteroperability & Node {

  createdAt: DateTime!


  id: ID!


  key: String!


  legacyResourceId: UnsignedInt64!


  namespace: String!


  ownerType: MetafieldOwnerType!


  updatedAt: DateTime!
}


type MetafieldStorefrontVisibilityConnection {

  edges: [MetafieldStorefrontVisibilityEdge!]!


  nodes: [MetafieldStorefrontVisibility!]!


  pageInfo: PageInfo!
}


type MetafieldStorefrontVisibilityCreatePayload {

  metafieldStorefrontVisibility: MetafieldStorefrontVisibility


  userErrors: [UserError!]!
}


type MetafieldStorefrontVisibilityDeletePayload {

  deletedMetafieldStorefrontVisibilityId: ID


  userErrors: [UserError!]!
}


type MetafieldStorefrontVisibilityEdge {

  cursor: String!


  node: MetafieldStorefrontVisibility!
}


input MetafieldStorefrontVisibilityInput {

  namespace: String


  key: String!


  ownerType: MetafieldOwnerType!
}


enum MetafieldValidationStatus {

  ANY


  VALID


  INVALID
}


enum MetafieldValueType {

  STRING


  INTEGER


  JSON_STRING


  BOOLEAN
}


type Metaobject implements Node {

  capabilities: MetaobjectCapabilityData!


  createdBy: App!


  createdByApp: App!


  createdByStaff: StaffMember


  definition: MetaobjectDefinition!


  displayName: String!


  field(

    key: String!
  ): MetaobjectField


  fields: [MetaobjectField!]!


  handle: String!


  id: ID!


  referencedBy(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldRelationConnection!


  staffMember: StaffMember @deprecated(reason: "Use `createdByStaff` instead.")


  thumbnailField: MetaobjectField


  type: String!


  updatedAt: DateTime!
}


type MetaobjectAccess {

  admin: MetaobjectAdminAccess!


  storefront: MetaobjectStorefrontAccess!
}


input MetaobjectAccessInput {

  admin: MetaobjectAdminAccess


  storefront: MetaobjectStorefrontAccess
}


enum MetaobjectAdminAccess {

  PRIVATE


  MERCHANT_READ


  MERCHANT_READ_WRITE


  PUBLIC_READ


  PUBLIC_READ_WRITE
}


type MetaobjectBulkDeletePayload {

  job: Job


  userErrors: [MetaobjectUserError!]!
}


input MetaobjectBulkDeleteWhereCondition {

  type: String


  ids: [ID!]
}


type MetaobjectCapabilities {

  onlineStore: MetaobjectCapabilitiesOnlineStore


  publishable: MetaobjectCapabilitiesPublishable!


  renderable: MetaobjectCapabilitiesRenderable


  translatable: MetaobjectCapabilitiesTranslatable!
}


type MetaobjectCapabilitiesOnlineStore {

  data: MetaobjectCapabilityDefinitionDataOnlineStore


  enabled: Boolean!
}


type MetaobjectCapabilitiesPublishable {

  enabled: Boolean!
}


type MetaobjectCapabilitiesRenderable {

  data: MetaobjectCapabilityDefinitionDataRenderable


  enabled: Boolean!
}


type MetaobjectCapabilitiesTranslatable {

  enabled: Boolean!
}


input MetaobjectCapabilityCreateInput {

  publishable: MetaobjectCapabilityPublishableInput


  translatable: MetaobjectCapabilityTranslatableInput


  renderable: MetaobjectCapabilityRenderableInput


  onlineStore: MetaobjectCapabilityOnlineStoreInput
}


type MetaobjectCapabilityData {

  onlineStore: MetaobjectCapabilityDataOnlineStore


  publishable: MetaobjectCapabilityDataPublishable
}


input MetaobjectCapabilityDataInput {

  publishable: MetaobjectCapabilityDataPublishableInput


  onlineStore: MetaobjectCapabilityDataOnlineStoreInput
}


type MetaobjectCapabilityDataOnlineStore {

  templateSuffix: String
}


input MetaobjectCapabilityDataOnlineStoreInput {

  templateSuffix: String
}


type MetaobjectCapabilityDataPublishable {

  status: MetaobjectStatus!
}


input MetaobjectCapabilityDataPublishableInput {

  status: MetaobjectStatus!
}


type MetaobjectCapabilityDefinitionDataOnlineStore {

  canCreateRedirects: Boolean!


  urlHandle: String!
}


input MetaobjectCapabilityDefinitionDataOnlineStoreInput {

  urlHandle: String!


  createRedirects: Boolean = false
}


type MetaobjectCapabilityDefinitionDataRenderable {

  metaDescriptionKey: String


  metaTitleKey: String
}


input MetaobjectCapabilityDefinitionDataRenderableInput {

  metaTitleKey: String


  metaDescriptionKey: String
}


input MetaobjectCapabilityOnlineStoreInput {

  enabled: Boolean!


  data: MetaobjectCapabilityDefinitionDataOnlineStoreInput
}


input MetaobjectCapabilityPublishableInput {

  enabled: Boolean!
}


input MetaobjectCapabilityRenderableInput {

  enabled: Boolean!


  data: MetaobjectCapabilityDefinitionDataRenderableInput
}


input MetaobjectCapabilityTranslatableInput {

  enabled: Boolean!
}


input MetaobjectCapabilityUpdateInput {

  publishable: MetaobjectCapabilityPublishableInput


  translatable: MetaobjectCapabilityTranslatableInput


  renderable: MetaobjectCapabilityRenderableInput


  onlineStore: MetaobjectCapabilityOnlineStoreInput
}


type MetaobjectConnection {

  edges: [MetaobjectEdge!]!


  nodes: [Metaobject!]!


  pageInfo: PageInfo!
}


input MetaobjectCreateInput {

  type: String!


  handle: String


  fields: [MetaobjectFieldInput!]


  capabilities: MetaobjectCapabilityDataInput
}


type MetaobjectCreatePayload {

  metaobject: Metaobject


  userErrors: [MetaobjectUserError!]!
}


type MetaobjectDefinition implements Node {

  access: MetaobjectAccess!


  capabilities: MetaobjectCapabilities!


  createdByApp: App!


  createdByStaff: StaffMember


  description: String


  displayNameKey: String


  fieldDefinitions: [MetaobjectFieldDefinition!]!


  hasThumbnailField: Boolean!


  id: ID!


  metaobjects(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetaobjectConnection!


  metaobjectsCount: Int!


  name: String!


  type: String!
}


type MetaobjectDefinitionConnection {

  edges: [MetaobjectDefinitionEdge!]!


  nodes: [MetaobjectDefinition!]!


  pageInfo: PageInfo!
}


input MetaobjectDefinitionCreateInput {

  name: String


  description: String


  type: String!


  fieldDefinitions: [MetaobjectFieldDefinitionCreateInput!]!


  access: MetaobjectAccessInput


  displayNameKey: String


  capabilities: MetaobjectCapabilityCreateInput
}


type MetaobjectDefinitionCreatePayload {

  metaobjectDefinition: MetaobjectDefinition


  userErrors: [MetaobjectUserError!]!
}


type MetaobjectDefinitionDeletePayload {

  deletedId: ID


  userErrors: [MetaobjectUserError!]!
}


type MetaobjectDefinitionEdge {

  cursor: String!


  node: MetaobjectDefinition!
}


input MetaobjectDefinitionUpdateInput {

  name: String


  description: String


  fieldDefinitions: [MetaobjectFieldDefinitionOperationInput!]


  access: MetaobjectAccessInput


  displayNameKey: String


  resetFieldOrder: Boolean = false


  capabilities: MetaobjectCapabilityUpdateInput
}


type MetaobjectDefinitionUpdatePayload {

  metaobjectDefinition: MetaobjectDefinition


  userErrors: [MetaobjectUserError!]!
}


type MetaobjectDeletePayload {

  deletedId: ID


  userErrors: [MetaobjectUserError!]!
}


type MetaobjectEdge {

  cursor: String!


  node: Metaobject!
}


type MetaobjectField {

  definition: MetaobjectFieldDefinition!


  key: String!


  reference: MetafieldReference


  references(

    first: Int


    after: String


    last: Int


    before: String
  ): MetafieldReferenceConnection


  thumbnail: MetaobjectThumbnail


  type: String!


  value: String
}


type MetaobjectFieldDefinition {

  description: String


  key: String!


  name: String!


  required: Boolean!


  type: MetafieldDefinitionType!


  validations: [MetafieldDefinitionValidation!]!
}


input MetaobjectFieldDefinitionCreateInput {

  key: String!


  type: String!


  name: String


  description: String


  required: Boolean = false


  validations: [MetafieldDefinitionValidationInput!]
}


input MetaobjectFieldDefinitionDeleteInput {

  key: String!
}


input MetaobjectFieldDefinitionOperationInput {

  create: MetaobjectFieldDefinitionCreateInput


  update: MetaobjectFieldDefinitionUpdateInput


  delete: MetaobjectFieldDefinitionDeleteInput
}


input MetaobjectFieldDefinitionUpdateInput {

  key: String!


  name: String


  description: String


  required: Boolean


  validations: [MetafieldDefinitionValidationInput!]
}


input MetaobjectFieldInput {

  key: String!


  value: String!
}


input MetaobjectHandleInput {

  type: String!


  handle: String!
}


enum MetaobjectStatus {

  DRAFT


  ACTIVE
}


enum MetaobjectStorefrontAccess {

  NONE


  PUBLIC_READ
}


type MetaobjectThumbnail {

  file: File


  hex: String
}


input MetaobjectUpdateInput {

  handle: String


  fields: [MetaobjectFieldInput!]


  capabilities: MetaobjectCapabilityDataInput


  redirectNewHandle: Boolean = false
}


type MetaobjectUpdatePayload {

  metaobject: Metaobject


  userErrors: [MetaobjectUserError!]!
}


input MetaobjectUpsertInput {

  handle: String


  fields: [MetaobjectFieldInput!]


  capabilities: MetaobjectCapabilityDataInput
}


type MetaobjectUpsertPayload {

  metaobject: Metaobject


  userErrors: [MetaobjectUserError!]!
}


type MetaobjectUserError implements DisplayableError {

  code: MetaobjectUserErrorCode


  elementIndex: Int


  elementKey: String


  field: [String!]


  message: String!
}


enum MetaobjectUserErrorCode {

  INVALID


  INCLUSION


  TAKEN


  TOO_LONG


  TOO_SHORT


  PRESENT


  BLANK


  INVALID_TYPE


  INVALID_VALUE


  INVALID_OPTION


  DUPLICATE_FIELD_INPUT


  UNDEFINED_OBJECT_TYPE


  UNDEFINED_OBJECT_FIELD


  OBJECT_FIELD_TAKEN


  OBJECT_FIELD_REQUIRED


  RECORD_NOT_FOUND


  INTERNAL_ERROR


  MAX_DEFINITIONS_EXCEEDED


  MAX_OBJECTS_EXCEEDED


  IMMUTABLE


  NOT_AUTHORIZED


  RESERVED_NAME


  CAPABILITY_NOT_ENABLED


  URL_HANDLE_TAKEN


  URL_HANDLE_INVALID


  URL_HANDLE_BLANK


  FIELD_TYPE_INVALID


  MISSING_REQUIRED_KEYS
}


enum MethodDefinitionSortKeys {

  RATE_PROVIDER_TYPE


  ID


  RELEVANCE
}


type Model3d implements Media & Node {

  alt: String


  boundingBox: Model3dBoundingBox


  filename: String!


  id: ID!


  mediaContentType: MediaContentType!


  mediaErrors: [MediaError!]!


  mediaWarnings: [MediaWarning!]!


  originalSource: Model3dSource


  preview: MediaPreviewImage


  sources: [Model3dSource!]!


  status: MediaStatus!
}


type Model3dBoundingBox {

  size: Vector3!
}


type Model3dSource {

  filesize: Int!


  format: String!


  mimeType: String!


  url: String!
}


scalar Money


type MoneyBag {

  presentmentMoney: MoneyV2!


  shopMoney: MoneyV2!
}


input MoneyInput {

  amount: Decimal!


  currencyCode: CurrencyCode!
}


type MoneyV2 {

  amount: Decimal!


  currencyCode: CurrencyCode!
}


input MoveInput {

  id: ID!


  newPosition: UnsignedInt64!
}


type Mutation {

  abandonmentEmailStateUpdate(

    id: ID!


    emailState: AbandonmentEmailState!


    emailSentAt: DateTime


    emailStateChangeReason: String
  ): AbandonmentEmailStateUpdatePayload @deprecated(reason: "Use `abandonmentUpdateActivitiesDeliveryStatuses` instead.")


  abandonmentUpdateActivitiesDeliveryStatuses(

    abandonmentId: ID!


    marketingActivityId: ID!


    deliveryStatus: AbandonmentDeliveryState!


    deliveredAt: DateTime


    deliveryStatusChangeReason: String
  ): AbandonmentUpdateActivitiesDeliveryStatusesPayload


  appPurchaseOneTimeCreate(

    name: String!


    price: MoneyInput!


    returnUrl: URL!


    test: Boolean = false
  ): AppPurchaseOneTimeCreatePayload


  appSubscriptionCancel(

    id: ID!


    prorate: Boolean = false
  ): AppSubscriptionCancelPayload


  appSubscriptionCreate(

    name: String!


    lineItems: [AppSubscriptionLineItemInput!]!


    test: Boolean = false


    trialDays: Int


    returnUrl: URL!


    replacementBehavior: AppSubscriptionReplacementBehavior = STANDARD
  ): AppSubscriptionCreatePayload


  appSubscriptionLineItemUpdate(

    id: ID!


    cappedAmount: MoneyInput!
  ): AppSubscriptionLineItemUpdatePayload


  appSubscriptionTrialExtend(

    id: ID!


    days: Int!
  ): AppSubscriptionTrialExtendPayload


  appUsageRecordCreate(

    subscriptionLineItemId: ID!


    price: MoneyInput!


    description: String!


    idempotencyKey: String
  ): AppUsageRecordCreatePayload


  bulkOperationCancel(

    id: ID!
  ): BulkOperationCancelPayload


  bulkOperationRunMutation(

    mutation: String!


    stagedUploadPath: String!


    clientIdentifier: String
  ): BulkOperationRunMutationPayload


  bulkOperationRunQuery(

    query: String!
  ): BulkOperationRunQueryPayload


  bulkProductResourceFeedbackCreate(

    feedbackInput: [ProductResourceFeedbackInput!]!
  ): BulkProductResourceFeedbackCreatePayload


  cartTransformCreate(

    functionId: String!


    blockOnFailure: Boolean = false
  ): CartTransformCreatePayload


  cartTransformDelete(

    id: ID!
  ): CartTransformDeletePayload


  catalogContextUpdate(

    catalogId: ID!


    contextsToAdd: CatalogContextInput


    contextsToRemove: CatalogContextInput
  ): CatalogContextUpdatePayload


  catalogCreate(

    input: CatalogCreateInput!
  ): CatalogCreatePayload


  catalogDelete(

    id: ID!


    deleteDependentResources: Boolean = false
  ): CatalogDeletePayload


  catalogUpdate(

    id: ID!


    input: CatalogUpdateInput!
  ): CatalogUpdatePayload


  checkoutBrandingUpsert(

    checkoutProfileId: ID!


    checkoutBrandingInput: CheckoutBrandingInput
  ): CheckoutBrandingUpsertPayload


  collectionAddProducts(

    id: ID!


    productIds: [ID!]!
  ): CollectionAddProductsPayload


  collectionAddProductsV2(

    id: ID!


    productIds: [ID!]!
  ): CollectionAddProductsV2Payload


  collectionCreate(

    input: CollectionInput!
  ): CollectionCreatePayload


  collectionDelete(

    input: CollectionDeleteInput!
  ): CollectionDeletePayload


  collectionPublish(

    input: CollectionPublishInput!
  ): CollectionPublishPayload @deprecated(reason: "Use `publishablePublish` instead.")


  collectionRemoveProducts(

    id: ID!


    productIds: [ID!]!
  ): CollectionRemoveProductsPayload


  collectionReorderProducts(

    id: ID!


    moves: [MoveInput!]!
  ): CollectionReorderProductsPayload


  collectionUnpublish(

    input: CollectionUnpublishInput!
  ): CollectionUnpublishPayload @deprecated(reason: "Use `publishableUnpublish` instead.")


  collectionUpdate(

    input: CollectionInput!
  ): CollectionUpdatePayload


  companiesDelete(

    companyIds: [ID!]!
  ): CompaniesDeletePayload


  companyAddressDelete(

    addressId: ID!
  ): CompanyAddressDeletePayload


  companyAssignCustomerAsContact(

    companyId: ID!


    customerId: ID!
  ): CompanyAssignCustomerAsContactPayload


  companyAssignMainContact(

    companyId: ID!


    companyContactId: ID!
  ): CompanyAssignMainContactPayload


  companyContactAssignRole(

    companyContactId: ID!


    companyContactRoleId: ID!


    companyLocationId: ID!
  ): CompanyContactAssignRolePayload


  companyContactAssignRoles(

    companyContactId: ID!


    rolesToAssign: [CompanyContactRoleAssign!]!
  ): CompanyContactAssignRolesPayload


  companyContactCreate(

    companyId: ID!


    input: CompanyContactInput!
  ): CompanyContactCreatePayload


  companyContactDelete(

    companyContactId: ID!
  ): CompanyContactDeletePayload


  companyContactRemoveFromCompany(

    companyContactId: ID!
  ): CompanyContactRemoveFromCompanyPayload


  companyContactRevokeRole(

    companyContactId: ID!


    companyContactRoleAssignmentId: ID!
  ): CompanyContactRevokeRolePayload


  companyContactRevokeRoles(

    companyContactId: ID!


    roleAssignmentIds: [ID!]


    revokeAll: Boolean = false
  ): CompanyContactRevokeRolesPayload


  companyContactSendWelcomeEmail(

    companyContactId: ID!


    email: EmailInput
  ): CompanyContactSendWelcomeEmailPayload


  companyContactUpdate(

    companyContactId: ID!


    input: CompanyContactInput!
  ): CompanyContactUpdatePayload


  companyContactsDelete(

    companyContactIds: [ID!]!
  ): CompanyContactsDeletePayload


  companyCreate(

    input: CompanyCreateInput!
  ): CompanyCreatePayload


  companyDelete(

    id: ID!
  ): CompanyDeletePayload


  companyLocationAssignAddress(

    locationId: ID!


    address: CompanyAddressInput!


    addressTypes: [CompanyAddressType!]!
  ): CompanyLocationAssignAddressPayload


  companyLocationAssignRoles(

    companyLocationId: ID!


    rolesToAssign: [CompanyLocationRoleAssign!]!
  ): CompanyLocationAssignRolesPayload


  companyLocationAssignTaxExemptions(

    companyLocationId: ID!


    taxExemptions: [TaxExemption!]!
  ): CompanyLocationAssignTaxExemptionsPayload


  companyLocationCreate(

    companyId: ID!


    input: CompanyLocationInput!
  ): CompanyLocationCreatePayload


  companyLocationCreateTaxRegistration(

    locationId: ID!


    taxId: String!
  ): CompanyLocationCreateTaxRegistrationPayload


  companyLocationDelete(

    companyLocationId: ID!
  ): CompanyLocationDeletePayload


  companyLocationRevokeRoles(

    companyLocationId: ID!


    rolesToRevoke: [ID!]!
  ): CompanyLocationRevokeRolesPayload


  companyLocationRevokeTaxExemptions(

    companyLocationId: ID!


    taxExemptions: [TaxExemption!]!
  ): CompanyLocationRevokeTaxExemptionsPayload


  companyLocationRevokeTaxRegistration(

    companyLocationId: ID!
  ): CompanyLocationRevokeTaxRegistrationPayload


  companyLocationUpdate(

    companyLocationId: ID!


    input: CompanyLocationUpdateInput!
  ): CompanyLocationUpdatePayload


  companyLocationsDelete(

    companyLocationIds: [ID!]!
  ): CompanyLocationsDeletePayload


  companyRevokeMainContact(

    companyId: ID!
  ): CompanyRevokeMainContactPayload


  companyUpdate(

    companyId: ID!


    input: CompanyInput!
  ): CompanyUpdatePayload


  customerAddTaxExemptions(

    customerId: ID!


    taxExemptions: [TaxExemption!]!
  ): CustomerAddTaxExemptionsPayload


  customerCancelDataErasure(

    customerId: ID!
  ): CustomerCancelDataErasurePayload


  customerCreate(

    input: CustomerInput!
  ): CustomerCreatePayload


  customerDelete(

    input: CustomerDeleteInput!
  ): CustomerDeletePayload


  customerEmailMarketingConsentUpdate(

    input: CustomerEmailMarketingConsentUpdateInput!
  ): CustomerEmailMarketingConsentUpdatePayload


  customerGenerateAccountActivationUrl(

    customerId: ID!
  ): CustomerGenerateAccountActivationUrlPayload


  customerMerge(

    customerOneId: ID!


    customerTwoId: ID!


    overrideFields: CustomerMergeOverrideFields
  ): CustomerMergePayload


  customerPaymentMethodCreateFromDuplicationData(

    customerId: ID!


    billingAddress: MailingAddressInput!


    encryptedDuplicationData: String!
  ): CustomerPaymentMethodCreateFromDuplicationDataPayload


  customerPaymentMethodCreditCardCreate(

    customerId: ID!


    billingAddress: MailingAddressInput!


    sessionId: String!
  ): CustomerPaymentMethodCreditCardCreatePayload


  customerPaymentMethodCreditCardUpdate(

    id: ID!


    billingAddress: MailingAddressInput!


    sessionId: String!
  ): CustomerPaymentMethodCreditCardUpdatePayload


  customerPaymentMethodGetDuplicationData(

    customerPaymentMethodId: ID!


    targetShopId: ID!


    targetCustomerId: ID!
  ): CustomerPaymentMethodGetDuplicationDataPayload


  customerPaymentMethodGetUpdateUrl(

    customerPaymentMethodId: ID!
  ): CustomerPaymentMethodGetUpdateUrlPayload


  customerPaymentMethodPaypalBillingAgreementCreate(

    customerId: ID!


    billingAddress: MailingAddressInput


    billingAgreementId: String!


    inactive: Boolean = false
  ): CustomerPaymentMethodPaypalBillingAgreementCreatePayload


  customerPaymentMethodPaypalBillingAgreementUpdate(

    id: ID!


    billingAddress: MailingAddressInput!
  ): CustomerPaymentMethodPaypalBillingAgreementUpdatePayload


  customerPaymentMethodRemoteCreate(

    customerId: ID!


    remoteReference: CustomerPaymentMethodRemoteInput!
  ): CustomerPaymentMethodRemoteCreatePayload


  customerPaymentMethodRemoteCreditCardCreate(

    customerId: ID!


    stripeCustomerId: String!


    stripePaymentMethodId: String
  ): CustomerPaymentMethodRemoteCreditCardCreatePayload @deprecated(reason: "Use `customerPaymentMethodRemoteCreate` instead.")


  customerPaymentMethodRevoke(

    customerPaymentMethodId: ID!
  ): CustomerPaymentMethodRevokePayload


  customerPaymentMethodSendUpdateEmail(

    customerPaymentMethodId: ID!


    email: EmailInput
  ): CustomerPaymentMethodSendUpdateEmailPayload


  customerRemoveTaxExemptions(

    customerId: ID!


    taxExemptions: [TaxExemption!]!
  ): CustomerRemoveTaxExemptionsPayload


  customerReplaceTaxExemptions(

    customerId: ID!


    taxExemptions: [TaxExemption!]!
  ): CustomerReplaceTaxExemptionsPayload


  customerRequestDataErasure(

    customerId: ID!
  ): CustomerRequestDataErasurePayload


  customerSegmentMembersQueryCreate(

    input: CustomerSegmentMembersQueryInput!
  ): CustomerSegmentMembersQueryCreatePayload


  customerSmsMarketingConsentUpdate(

    input: CustomerSmsMarketingConsentUpdateInput!
  ): CustomerSmsMarketingConsentUpdatePayload


  customerUpdate(

    input: CustomerInput!
  ): CustomerUpdatePayload


  customerUpdateDefaultAddress(

    customerId: ID!


    addressId: ID!
  ): CustomerUpdateDefaultAddressPayload


  delegateAccessTokenCreate(

    input: DelegateAccessTokenInput!
  ): DelegateAccessTokenCreatePayload


  delegateAccessTokenDestroy(

    accessToken: String!
  ): DelegateAccessTokenDestroyPayload


  deliveryCustomizationActivation(

    ids: [ID!]!


    enabled: Boolean!
  ): DeliveryCustomizationActivationPayload


  deliveryCustomizationCreate(

    deliveryCustomization: DeliveryCustomizationInput!
  ): DeliveryCustomizationCreatePayload


  deliveryCustomizationDelete(

    id: ID!
  ): DeliveryCustomizationDeletePayload


  deliveryCustomizationUpdate(

    id: ID!


    deliveryCustomization: DeliveryCustomizationInput!
  ): DeliveryCustomizationUpdatePayload


  deliveryProfileCreate(

    profile: DeliveryProfileInput!
  ): deliveryProfileCreatePayload


  deliveryProfileRemove(

    id: ID!
  ): deliveryProfileRemovePayload


  deliveryProfileUpdate(

    id: ID!


    profile: DeliveryProfileInput!


    leaveLegacyModeProfiles: Boolean
  ): deliveryProfileUpdatePayload


  deliverySettingUpdate(

    setting: DeliverySettingInput!
  ): DeliverySettingUpdatePayload


  deliveryShippingOriginAssign(

    locationId: ID!
  ): DeliveryShippingOriginAssignPayload


  discountAutomaticActivate(

    id: ID!
  ): DiscountAutomaticActivatePayload


  discountAutomaticAppCreate(

    automaticAppDiscount: DiscountAutomaticAppInput!
  ): DiscountAutomaticAppCreatePayload


  discountAutomaticAppUpdate(

    id: ID!


    automaticAppDiscount: DiscountAutomaticAppInput!
  ): DiscountAutomaticAppUpdatePayload


  discountAutomaticBasicCreate(

    automaticBasicDiscount: DiscountAutomaticBasicInput!
  ): DiscountAutomaticBasicCreatePayload


  discountAutomaticBasicUpdate(

    id: ID!


    automaticBasicDiscount: DiscountAutomaticBasicInput!
  ): DiscountAutomaticBasicUpdatePayload


  discountAutomaticBulkDelete(

    search: String


    savedSearchId: ID


    ids: [ID!]
  ): DiscountAutomaticBulkDeletePayload


  discountAutomaticBxgyCreate(

    automaticBxgyDiscount: DiscountAutomaticBxgyInput!
  ): DiscountAutomaticBxgyCreatePayload


  discountAutomaticBxgyUpdate(

    id: ID!


    automaticBxgyDiscount: DiscountAutomaticBxgyInput!
  ): DiscountAutomaticBxgyUpdatePayload


  discountAutomaticDeactivate(

    id: ID!
  ): DiscountAutomaticDeactivatePayload


  discountAutomaticDelete(

    id: ID!
  ): DiscountAutomaticDeletePayload


  discountAutomaticFreeShippingCreate(

    freeShippingAutomaticDiscount: DiscountAutomaticFreeShippingInput!
  ): DiscountAutomaticFreeShippingCreatePayload


  discountAutomaticFreeShippingUpdate(

    id: ID!


    freeShippingAutomaticDiscount: DiscountAutomaticFreeShippingInput!
  ): DiscountAutomaticFreeShippingUpdatePayload


  discountCodeActivate(

    id: ID!
  ): DiscountCodeActivatePayload


  discountCodeAppCreate(

    codeAppDiscount: DiscountCodeAppInput!
  ): DiscountCodeAppCreatePayload


  discountCodeAppUpdate(

    id: ID!


    codeAppDiscount: DiscountCodeAppInput!
  ): DiscountCodeAppUpdatePayload


  discountCodeBasicCreate(

    basicCodeDiscount: DiscountCodeBasicInput!
  ): DiscountCodeBasicCreatePayload


  discountCodeBasicUpdate(

    id: ID!


    basicCodeDiscount: DiscountCodeBasicInput!
  ): DiscountCodeBasicUpdatePayload


  discountCodeBulkActivate(

    search: String


    savedSearchId: ID


    ids: [ID!]
  ): DiscountCodeBulkActivatePayload


  discountCodeBulkDeactivate(

    search: String


    savedSearchId: ID


    ids: [ID!]
  ): DiscountCodeBulkDeactivatePayload


  discountCodeBulkDelete(

    search: String


    savedSearchId: ID


    ids: [ID!]
  ): DiscountCodeBulkDeletePayload


  discountCodeBxgyCreate(

    bxgyCodeDiscount: DiscountCodeBxgyInput!
  ): DiscountCodeBxgyCreatePayload


  discountCodeBxgyUpdate(

    id: ID!


    bxgyCodeDiscount: DiscountCodeBxgyInput!
  ): DiscountCodeBxgyUpdatePayload


  discountCodeDeactivate(

    id: ID!
  ): DiscountCodeDeactivatePayload


  discountCodeDelete(

    id: ID!
  ): DiscountCodeDeletePayload


  discountCodeFreeShippingCreate(

    freeShippingCodeDiscount: DiscountCodeFreeShippingInput!
  ): DiscountCodeFreeShippingCreatePayload


  discountCodeFreeShippingUpdate(

    id: ID!


    freeShippingCodeDiscount: DiscountCodeFreeShippingInput!
  ): DiscountCodeFreeShippingUpdatePayload


  discountCodeRedeemCodeBulkDelete(

    discountId: ID!


    search: String


    savedSearchId: ID


    ids: [ID!]
  ): DiscountCodeRedeemCodeBulkDeletePayload


  discountRedeemCodeBulkAdd(

    discountId: ID!


    codes: [DiscountRedeemCodeInput!]!
  ): DiscountRedeemCodeBulkAddPayload


  disputeEvidenceUpdate(

    id: ID!


    input: ShopifyPaymentsDisputeEvidenceUpdateInput!
  ): DisputeEvidenceUpdatePayload


  draftOrderBulkAddTags(

    search: String


    savedSearchId: ID


    ids: [ID!]


    tags: [String!]!
  ): DraftOrderBulkAddTagsPayload


  draftOrderBulkDelete(

    search: String


    savedSearchId: ID


    ids: [ID!]
  ): DraftOrderBulkDeletePayload


  draftOrderBulkRemoveTags(

    search: String


    savedSearchId: ID


    ids: [ID!]


    tags: [String!]!
  ): DraftOrderBulkRemoveTagsPayload


  draftOrderCalculate(

    input: DraftOrderInput!
  ): DraftOrderCalculatePayload


  draftOrderComplete(

    id: ID!


    paymentPending: Boolean = false


    paymentGatewayId: ID


    sourceName: String
  ): DraftOrderCompletePayload


  draftOrderCreate(

    input: DraftOrderInput!
  ): DraftOrderCreatePayload


  draftOrderCreateFromOrder(

    orderId: ID!
  ): DraftOrderCreateFromOrderPayload


  draftOrderCreateMerchantCheckout(

    id: ID!
  ): DraftOrderCreateMerchantCheckoutPayload


  draftOrderDelete(

    input: DraftOrderDeleteInput!
  ): DraftOrderDeletePayload


  draftOrderDuplicate(

    id: ID
  ): DraftOrderDuplicatePayload


  draftOrderInvoicePreview(

    id: ID!


    email: EmailInput
  ): DraftOrderInvoicePreviewPayload


  draftOrderInvoiceSend(

    id: ID!


    email: EmailInput
  ): DraftOrderInvoiceSendPayload


  draftOrderUpdate(

    id: ID!


    input: DraftOrderInput!
  ): DraftOrderUpdatePayload


  eventBridgeServerPixelUpdate(

    arn: ARN!
  ): EventBridgeServerPixelUpdatePayload


  eventBridgeWebhookSubscriptionCreate(

    topic: WebhookSubscriptionTopic!


    subTopic: String


    webhookSubscription: EventBridgeWebhookSubscriptionInput!
  ): EventBridgeWebhookSubscriptionCreatePayload


  eventBridgeWebhookSubscriptionUpdate(

    id: ID!


    webhookSubscription: EventBridgeWebhookSubscriptionInput!
  ): EventBridgeWebhookSubscriptionUpdatePayload


  fileAcknowledgeUpdateFailed(

    fileIds: [ID!]!
  ): FileAcknowledgeUpdateFailedPayload


  fileCreate(

    files: [FileCreateInput!]!
  ): FileCreatePayload


  fileDelete(

    fileIds: [ID!]!
  ): FileDeletePayload


  fileUpdate(

    files: [FileUpdateInput!]!
  ): FileUpdatePayload


  flowGenerateSignature(

    id: ID!


    payload: String!
  ): FlowGenerateSignaturePayload


  flowTriggerReceive(

    handle: String


    payload: JSON
  ): FlowTriggerReceivePayload


  fulfillmentCancel(

    id: ID!
  ): FulfillmentCancelPayload


  fulfillmentConstraintRuleCreate(

    functionId: String!


    metafields: [MetafieldInput!] = []
  ): FulfillmentConstraintRuleCreatePayload


  fulfillmentConstraintRuleDelete(

    id: ID!
  ): FulfillmentConstraintRuleDeletePayload


  fulfillmentCreateV2(

    fulfillment: FulfillmentV2Input!


    message: String
  ): FulfillmentCreateV2Payload


  fulfillmentEventCreate(

    fulfillmentEvent: FulfillmentEventInput!
  ): FulfillmentEventCreatePayload


  fulfillmentOrderAcceptCancellationRequest(

    id: ID!


    message: String
  ): FulfillmentOrderAcceptCancellationRequestPayload


  fulfillmentOrderAcceptFulfillmentRequest(

    id: ID!


    message: String
  ): FulfillmentOrderAcceptFulfillmentRequestPayload


  fulfillmentOrderCancel(

    id: ID!
  ): FulfillmentOrderCancelPayload


  fulfillmentOrderClose(

    id: ID!


    message: String
  ): FulfillmentOrderClosePayload


  fulfillmentOrderHold(

    id: ID!


    fulfillmentHold: FulfillmentOrderHoldInput!
  ): FulfillmentOrderHoldPayload


  fulfillmentOrderLineItemsPreparedForPickup(

    input: FulfillmentOrderLineItemsPreparedForPickupInput!
  ): FulfillmentOrderLineItemsPreparedForPickupPayload


  fulfillmentOrderMerge(

    fulfillmentOrderMergeInputs: [FulfillmentOrderMergeInput!]!
  ): FulfillmentOrderMergePayload


  fulfillmentOrderMove(

    id: ID!


    newLocationId: ID!


    fulfillmentOrderLineItems: [FulfillmentOrderLineItemInput!]
  ): FulfillmentOrderMovePayload


  fulfillmentOrderOpen(

    id: ID!
  ): FulfillmentOrderOpenPayload


  fulfillmentOrderRejectCancellationRequest(

    id: ID!


    message: String
  ): FulfillmentOrderRejectCancellationRequestPayload


  fulfillmentOrderRejectFulfillmentRequest(

    id: ID!


    reason: FulfillmentOrderRejectionReason


    message: String


    lineItems: [IncomingRequestLineItemInput!]
  ): FulfillmentOrderRejectFulfillmentRequestPayload


  fulfillmentOrderReleaseHold(

    id: ID!


    externalId: String
  ): FulfillmentOrderReleaseHoldPayload


  fulfillmentOrderReschedule(

    id: ID!


    fulfillAt: DateTime!
  ): FulfillmentOrderReschedulePayload


  fulfillmentOrderSplit(

    fulfillmentOrderSplits: [FulfillmentOrderSplitInput!]!
  ): FulfillmentOrderSplitPayload


  fulfillmentOrderSubmitCancellationRequest(

    id: ID!


    message: String
  ): FulfillmentOrderSubmitCancellationRequestPayload


  fulfillmentOrderSubmitFulfillmentRequest(

    id: ID!


    message: String


    notifyCustomer: Boolean


    fulfillmentOrderLineItems: [FulfillmentOrderLineItemInput!]
  ): FulfillmentOrderSubmitFulfillmentRequestPayload


  fulfillmentOrdersReleaseHolds(

    ids: [ID!]!


    externalId: String
  ): FulfillmentOrdersReleaseHoldsPayload


  fulfillmentOrdersSetFulfillmentDeadline(

    fulfillmentOrderIds: [ID!]!


    fulfillmentDeadline: DateTime!
  ): FulfillmentOrdersSetFulfillmentDeadlinePayload


  fulfillmentServiceCreate(

    name: String!


    callbackUrl: URL!


    trackingSupport: Boolean = false


    fulfillmentOrdersOptIn: Boolean!


    permitsSkuSharing: Boolean = false


    inventoryManagement: Boolean = false
  ): FulfillmentServiceCreatePayload


  fulfillmentServiceDelete(

    id: ID!


    destinationLocationId: ID
  ): FulfillmentServiceDeletePayload


  fulfillmentServiceUpdate(

    id: ID!


    name: String


    callbackUrl: URL


    trackingSupport: Boolean


    permitsSkuSharing: Boolean
  ): FulfillmentServiceUpdatePayload


  fulfillmentTrackingInfoUpdateV2(

    fulfillmentId: ID!


    trackingInfoInput: FulfillmentTrackingInput!


    notifyCustomer: Boolean
  ): FulfillmentTrackingInfoUpdateV2Payload


  giftCardCreate(

    input: GiftCardCreateInput!
  ): GiftCardCreatePayload


  giftCardDisable(

    id: ID!
  ): GiftCardDisablePayload


  giftCardUpdate(

    id: ID!


    input: GiftCardUpdateInput!
  ): GiftCardUpdatePayload


  inventoryActivate(

    inventoryItemId: ID!


    locationId: ID!


    available: Int


    onHand: Int
  ): InventoryActivatePayload


  inventoryAdjustQuantities(

    input: InventoryAdjustQuantitiesInput!
  ): InventoryAdjustQuantitiesPayload


  inventoryAdjustQuantity(

    input: InventoryAdjustQuantityInput!
  ): InventoryAdjustQuantityPayload @deprecated(reason: "Use `inventoryAdjustQuantities` instead.")


  inventoryBulkAdjustQuantityAtLocation(

    inventoryItemAdjustments: [InventoryAdjustItemInput!]!


    locationId: ID!
  ): InventoryBulkAdjustQuantityAtLocationPayload @deprecated(reason: "Use `inventoryAdjustQuantities` instead.")


  inventoryBulkToggleActivation(

    inventoryItemId: ID!


    inventoryItemUpdates: [InventoryBulkToggleActivationInput!]!
  ): InventoryBulkToggleActivationPayload


  inventoryDeactivate(

    inventoryLevelId: ID!
  ): InventoryDeactivatePayload


  inventoryItemUpdate(

    id: ID!


    input: InventoryItemUpdateInput!
  ): InventoryItemUpdatePayload


  inventoryMoveQuantities(

    input: InventoryMoveQuantitiesInput!
  ): InventoryMoveQuantitiesPayload


  inventorySetOnHandQuantities(

    input: InventorySetOnHandQuantitiesInput!
  ): InventorySetOnHandQuantitiesPayload


  inventorySetScheduledChanges(

    input: InventorySetScheduledChangesInput!
  ): InventorySetScheduledChangesPayload


  locationActivate(

    locationId: ID!
  ): LocationActivatePayload


  locationAdd(

    input: LocationAddInput!
  ): LocationAddPayload


  locationDeactivate(

    locationId: ID!


    destinationLocationId: ID
  ): LocationDeactivatePayload


  locationDelete(

    locationId: ID!
  ): LocationDeletePayload


  locationEdit(

    id: ID!


    input: LocationEditInput!
  ): LocationEditPayload


  locationLocalPickupDisable(

    locationId: ID!
  ): LocationLocalPickupDisablePayload


  locationLocalPickupEnable(

    localPickupSettings: DeliveryLocationLocalPickupEnableInput!
  ): LocationLocalPickupEnablePayload


  marketCreate(

    input: MarketCreateInput!
  ): MarketCreatePayload


  marketCurrencySettingsUpdate(

    marketId: ID!


    input: MarketCurrencySettingsUpdateInput!
  ): MarketCurrencySettingsUpdatePayload


  marketDelete(

    id: ID!
  ): MarketDeletePayload


  marketLocalizationsRegister(

    resourceId: ID!


    marketLocalizations: [MarketLocalizationRegisterInput!]!
  ): MarketLocalizationsRegisterPayload


  marketLocalizationsRemove(

    resourceId: ID!


    marketLocalizationKeys: [String!]!


    marketIds: [ID!]!
  ): MarketLocalizationsRemovePayload


  marketRegionDelete(

    id: ID!
  ): MarketRegionDeletePayload


  marketRegionsCreate(

    marketId: ID!


    regions: [MarketRegionCreateInput!]!
  ): MarketRegionsCreatePayload


  marketRegionsDelete(

    ids: [ID!]!
  ): MarketRegionsDeletePayload


  marketUpdate(

    id: ID!


    input: MarketUpdateInput!
  ): MarketUpdatePayload


  marketWebPresenceCreate(

    marketId: ID!


    webPresence: MarketWebPresenceCreateInput!
  ): MarketWebPresenceCreatePayload


  marketWebPresenceDelete(

    webPresenceId: ID!
  ): MarketWebPresenceDeletePayload


  marketWebPresenceUpdate(

    webPresenceId: ID!


    webPresence: MarketWebPresenceUpdateInput!
  ): MarketWebPresenceUpdatePayload


  marketingActivitiesDeleteAllExternal: MarketingActivitiesDeleteAllExternalPayload


  marketingActivityCreate(

    input: MarketingActivityCreateInput!
  ): MarketingActivityCreatePayload


  marketingActivityCreateExternal(

    input: MarketingActivityCreateExternalInput!
  ): MarketingActivityCreateExternalPayload


  marketingActivityDeleteExternal(

    marketingActivityId: ID


    remoteId: String
  ): MarketingActivityDeleteExternalPayload


  marketingActivityUpdate(

    input: MarketingActivityUpdateInput!
  ): MarketingActivityUpdatePayload


  marketingActivityUpdateExternal(

    input: MarketingActivityUpdateExternalInput!


    marketingActivityId: ID


    remoteId: String


    utm: UTMInput
  ): MarketingActivityUpdateExternalPayload


  marketingActivityUpsertExternal(

    input: MarketingActivityUpsertExternalInput!
  ): MarketingActivityUpsertExternalPayload


  marketingEngagementCreate(

    marketingActivityId: ID


    remoteId: String


    channelHandle: String


    marketingEngagement: MarketingEngagementInput!
  ): MarketingEngagementCreatePayload


  marketingEngagementsDelete(

    channelHandle: String


    deleteEngagementsForAllChannels: Boolean = false
  ): MarketingEngagementsDeletePayload


  metafieldDefinitionCreate(

    definition: MetafieldDefinitionInput!
  ): MetafieldDefinitionCreatePayload


  metafieldDefinitionDelete(

    id: ID!


    deleteAllAssociatedMetafields: Boolean = false
  ): MetafieldDefinitionDeletePayload


  metafieldDefinitionPin(

    definitionId: ID!
  ): MetafieldDefinitionPinPayload


  metafieldDefinitionUnpin(

    definitionId: ID!
  ): MetafieldDefinitionUnpinPayload


  metafieldDefinitionUpdate(

    definition: MetafieldDefinitionUpdateInput!
  ): MetafieldDefinitionUpdatePayload


  metafieldDelete(input: MetafieldDeleteInput!): MetafieldDeletePayload


  metafieldStorefrontVisibilityCreate(

    input: MetafieldStorefrontVisibilityInput!
  ): MetafieldStorefrontVisibilityCreatePayload @deprecated(reason: "This mutation will be removed in a future version. Use the `metafieldDefinitionCreate` or `metafieldDefinitionUpdate` mutations with `access.storefront` set instead.\n")


  metafieldStorefrontVisibilityDelete(

    id: ID!
  ): MetafieldStorefrontVisibilityDeletePayload @deprecated(reason: "This mutation will be removed in a future version. Use the `metafieldDefinitionUpdate` mutation with `access.storefront` set instead.\n")


  metafieldsSet(

    metafields: [MetafieldsSetInput!]!
  ): MetafieldsSetPayload


  metaobjectBulkDelete(

    where: MetaobjectBulkDeleteWhereCondition!
  ): MetaobjectBulkDeletePayload


  metaobjectCreate(

    metaobject: MetaobjectCreateInput!
  ): MetaobjectCreatePayload


  metaobjectDefinitionCreate(

    definition: MetaobjectDefinitionCreateInput!
  ): MetaobjectDefinitionCreatePayload


  metaobjectDefinitionDelete(

    id: ID!
  ): MetaobjectDefinitionDeletePayload


  metaobjectDefinitionUpdate(

    id: ID!


    definition: MetaobjectDefinitionUpdateInput!
  ): MetaobjectDefinitionUpdatePayload


  metaobjectDelete(

    id: ID!
  ): MetaobjectDeletePayload


  metaobjectUpdate(

    id: ID!


    metaobject: MetaobjectUpdateInput!
  ): MetaobjectUpdatePayload


  metaobjectUpsert(

    handle: MetaobjectHandleInput!


    metaobject: MetaobjectUpsertInput!
  ): MetaobjectUpsertPayload


  orderCancel(

    orderId: ID!


    refund: Boolean!


    restock: Boolean!


    reason: OrderCancelReason!


    notifyCustomer: Boolean = false


    staffNote: String 
  ): OrderCancelPayload


  orderCapture(

    input: OrderCaptureInput!
  ): OrderCapturePayload


  orderClose(

    input: OrderCloseInput!
  ): OrderClosePayload


  orderCreateMandatePayment(

    id: ID!


    paymentScheduleId: ID


    idempotencyKey: String!


    mandateId: ID!


    autoCapture: Boolean = true
  ): OrderCreateMandatePaymentPayload


  orderEditAddCustomItem(

    id: ID!


    title: String!


    locationId: ID


    price: MoneyInput!


    quantity: Int!


    taxable: Boolean


    requiresShipping: Boolean
  ): OrderEditAddCustomItemPayload


  orderEditAddLineItemDiscount(

    id: ID!


    lineItemId: ID!


    discount: OrderEditAppliedDiscountInput!
  ): OrderEditAddLineItemDiscountPayload


  orderEditAddVariant(

    id: ID!


    variantId: ID!


    locationId: ID


    quantity: Int!


    allowDuplicates: Boolean = false
  ): OrderEditAddVariantPayload


  orderEditBegin(

    id: ID!
  ): OrderEditBeginPayload


  orderEditCommit(

    id: ID!


    notifyCustomer: Boolean


    staffNote: String
  ): OrderEditCommitPayload


  orderEditRemoveDiscount(

    id: ID!


    discountApplicationId: ID!
  ): OrderEditRemoveDiscountPayload


  orderEditRemoveLineItemDiscount(

    id: ID!


    discountApplicationId: ID!
  ): OrderEditRemoveLineItemDiscountPayload @deprecated(reason: "Use generic OrderEditRemoveDiscount mutation instead.")


  orderEditSetQuantity(

    id: ID!


    lineItemId: ID!


    quantity: Int!


    restock: Boolean
  ): OrderEditSetQuantityPayload


  orderEditUpdateDiscount(

    id: ID!


    discount: OrderEditAppliedDiscountInput!


    discountApplicationId: ID!
  ): OrderEditUpdateDiscountPayload


  orderInvoiceSend(

    id: ID!


    email: EmailInput
  ): OrderInvoiceSendPayload


  orderMarkAsPaid(

    input: OrderMarkAsPaidInput!
  ): OrderMarkAsPaidPayload


  orderOpen(

    input: OrderOpenInput!
  ): OrderOpenPayload


  orderUpdate(

    input: OrderInput!
  ): OrderUpdatePayload


  paymentCustomizationActivation(

    ids: [ID!]!


    enabled: Boolean!
  ): PaymentCustomizationActivationPayload


  paymentCustomizationCreate(

    paymentCustomization: PaymentCustomizationInput!
  ): PaymentCustomizationCreatePayload


  paymentCustomizationDelete(

    id: ID!
  ): PaymentCustomizationDeletePayload


  paymentCustomizationUpdate(

    id: ID!


    paymentCustomization: PaymentCustomizationInput!
  ): PaymentCustomizationUpdatePayload


  paymentReminderSend(

    paymentScheduleId: ID!
  ): PaymentReminderSendPayload


  paymentTermsCreate(

    referenceId: ID!


    paymentTermsAttributes: PaymentTermsCreateInput!
  ): PaymentTermsCreatePayload


  paymentTermsDelete(

    input: PaymentTermsDeleteInput!
  ): PaymentTermsDeletePayload


  paymentTermsUpdate(

    input: PaymentTermsUpdateInput!
  ): PaymentTermsUpdatePayload


  priceListCreate(

    input: PriceListCreateInput!
  ): PriceListCreatePayload


  priceListDelete(

    id: ID!
  ): PriceListDeletePayload


  priceListFixedPricesAdd(

    priceListId: ID!


    prices: [PriceListPriceInput!]!
  ): PriceListFixedPricesAddPayload


  priceListFixedPricesByProductUpdate(

    pricesToAdd: [PriceListProductPriceInput!]


    pricesToDeleteByProductIds: [ID!]


    priceListId: ID!
  ): PriceListFixedPricesByProductUpdatePayload


  priceListFixedPricesDelete(

    priceListId: ID!


    variantIds: [ID!]!
  ): PriceListFixedPricesDeletePayload


  priceListFixedPricesUpdate(

    priceListId: ID!


    pricesToAdd: [PriceListPriceInput!]!


    variantIdsToDelete: [ID!]!
  ): PriceListFixedPricesUpdatePayload


  priceListUpdate(

    id: ID!


    input: PriceListUpdateInput!
  ): PriceListUpdatePayload


  priceRuleActivate(

    id: ID!
  ): PriceRuleActivatePayload @deprecated(reason: "Use `discountCodeActivate` instead.")


  priceRuleCreate(

    priceRule: PriceRuleInput!


    priceRuleDiscountCode: PriceRuleDiscountCodeInput
  ): PriceRuleCreatePayload @deprecated(reason: "Use `discountCodeBasicCreate` instead.")


  priceRuleDeactivate(

    id: ID!
  ): PriceRuleDeactivatePayload @deprecated(reason: "Use `discountCodeDeactivate` instead.")


  priceRuleDelete(

    id: ID!
  ): PriceRuleDeletePayload @deprecated(reason: "Use `discountCodeDelete` instead.")


  priceRuleDiscountCodeCreate(

    priceRuleId: ID!


    code: String!
  ): PriceRuleDiscountCodeCreatePayload @deprecated(reason: "Use `discountRedeemCodeBulkAdd` instead.")


  priceRuleDiscountCodeUpdate(

    priceRuleId: ID!


    code: String!
  ): PriceRuleDiscountCodeUpdatePayload @deprecated(reason: "Use `discountCodeBasicUpdate` instead.")


  priceRuleUpdate(

    id: ID!


    priceRule: PriceRuleInput!


    priceRuleDiscountCode: PriceRuleDiscountCodeInput
  ): PriceRuleUpdatePayload @deprecated(reason: "Use `discountCodeBasicUpdate` instead.")


  privateMetafieldDelete(

    input: PrivateMetafieldDeleteInput!
  ): PrivateMetafieldDeletePayload @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafieldUpsert(

    input: PrivateMetafieldInput!
  ): PrivateMetafieldUpsertPayload @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  productAppendImages(

    input: ProductAppendImagesInput!
  ): ProductAppendImagesPayload @deprecated(reason: "Use `productCreateMedia` instead.")


  productChangeStatus(

    productId: ID!


    status: ProductStatus!
  ): ProductChangeStatusPayload


  productCreate(

    input: ProductInput!


    media: [CreateMediaInput!]
  ): ProductCreatePayload


  productCreateMedia(

    productId: ID!


    media: [CreateMediaInput!]!
  ): ProductCreateMediaPayload


  productDelete(

    input: ProductDeleteInput!
  ): ProductDeletePayload


  productDeleteAsync(

    productId: ID!
  ): ProductDeleteAsyncPayload


  productDeleteImages(

    id: ID!


    imageIds: [ID!]!
  ): ProductDeleteImagesPayload @deprecated(reason: "Use `productDeleteMedia` instead.")


  productDeleteMedia(

    productId: ID!


    mediaIds: [ID!]!
  ): ProductDeleteMediaPayload


  productDuplicate(

    productId: ID!


    newTitle: String!


    newStatus: ProductStatus


    includeImages: Boolean = false


    includeTranslations: Boolean = false
  ): ProductDuplicatePayload


  productDuplicateAsync(

    input: ProductDuplicateAsyncInput!
  ): ProductDuplicateAsyncPayload @deprecated(reason: "Use `productDuplicateAsyncV2` instead.")


  productDuplicateAsyncV2(

    input: ProductDuplicateAsyncInput!
  ): ProductDuplicateAsyncV2Payload


  productFeedCreate(

    input: ProductFeedInput
  ): ProductFeedCreatePayload


  productFeedDelete(

    id: ID!
  ): ProductFeedDeletePayload


  productFullSync(

    beforeUpdatedAt: DateTime


    id: ID!


    updatedAtSince: DateTime
  ): ProductFullSyncPayload


  productImageUpdate(

    productId: ID!


    image: ImageInput!
  ): ProductImageUpdatePayload @deprecated(reason: "Use `productUpdateMedia` instead.")


  productJoinSellingPlanGroups(

    id: ID!


    sellingPlanGroupIds: [ID!]!
  ): ProductJoinSellingPlanGroupsPayload


  productLeaveSellingPlanGroups(

    id: ID!


    sellingPlanGroupIds: [ID!]!
  ): ProductLeaveSellingPlanGroupsPayload


  productPublish(

    input: ProductPublishInput!
  ): ProductPublishPayload @deprecated(reason: "Use `publishablePublish` instead.")


  productReorderImages(

    id: ID!


    moves: [MoveInput!]!
  ): ProductReorderImagesPayload @deprecated(reason: "Use `productReorderMedia` instead.")


  productReorderMedia(

    id: ID!


    moves: [MoveInput!]!
  ): ProductReorderMediaPayload


  productUnpublish(

    input: ProductUnpublishInput!
  ): ProductUnpublishPayload @deprecated(reason: "Use `publishableUnpublish` instead.")


  productUpdate(

    input: ProductInput!


    media: [CreateMediaInput!]
  ): ProductUpdatePayload


  productUpdateMedia(

    productId: ID!


    media: [UpdateMediaInput!]!
  ): ProductUpdateMediaPayload


  productVariantAppendMedia(

    productId: ID!


    variantMedia: [ProductVariantAppendMediaInput!]!
  ): ProductVariantAppendMediaPayload


  productVariantCreate(

    input: ProductVariantInput!
  ): ProductVariantCreatePayload


  productVariantDelete(

    id: ID!
  ): ProductVariantDeletePayload


  productVariantDetachMedia(

    productId: ID!


    variantMedia: [ProductVariantDetachMediaInput!]!
  ): ProductVariantDetachMediaPayload


  productVariantJoinSellingPlanGroups(

    id: ID!


    sellingPlanGroupIds: [ID!]!
  ): ProductVariantJoinSellingPlanGroupsPayload


  productVariantLeaveSellingPlanGroups(

    id: ID!


    sellingPlanGroupIds: [ID!]!
  ): ProductVariantLeaveSellingPlanGroupsPayload


  productVariantRelationshipBulkUpdate(

    input: [ProductVariantRelationshipUpdateInput!]!
  ): ProductVariantRelationshipBulkUpdatePayload


  productVariantUpdate(

    input: ProductVariantInput!
  ): ProductVariantUpdatePayload


  productVariantsBulkCreate(

    variants: [ProductVariantsBulkInput!]!


    productId: ID!


    media: [CreateMediaInput!]
  ): ProductVariantsBulkCreatePayload


  productVariantsBulkDelete(

    variantsIds: [ID!]!


    productId: ID!
  ): ProductVariantsBulkDeletePayload


  productVariantsBulkReorder(

    productId: ID!


    positions: [ProductVariantPositionInput!]!
  ): ProductVariantsBulkReorderPayload


  productVariantsBulkUpdate(

    variants: [ProductVariantsBulkInput!]!


    productId: ID!


    media: [CreateMediaInput!]


    allowPartialUpdates: Boolean = false
  ): ProductVariantsBulkUpdatePayload


  pubSubServerPixelUpdate(

    pubSubProject: String!


    pubSubTopic: String!
  ): PubSubServerPixelUpdatePayload


  pubSubWebhookSubscriptionCreate(

    topic: WebhookSubscriptionTopic!


    subTopic: String


    webhookSubscription: PubSubWebhookSubscriptionInput!
  ): PubSubWebhookSubscriptionCreatePayload


  pubSubWebhookSubscriptionUpdate(

    id: ID!


    webhookSubscription: PubSubWebhookSubscriptionInput
  ): PubSubWebhookSubscriptionUpdatePayload


  publicationCreate(

    input: PublicationCreateInput!
  ): PublicationCreatePayload


  publicationDelete(

    id: ID!
  ): PublicationDeletePayload


  publicationUpdate(

    id: ID!


    input: PublicationUpdateInput!
  ): PublicationUpdatePayload


  publishablePublish(

    id: ID!


    input: [PublicationInput!]!
  ): PublishablePublishPayload


  publishablePublishToCurrentChannel(

    id: ID!
  ): PublishablePublishToCurrentChannelPayload


  publishableUnpublish(

    id: ID!


    input: [PublicationInput!]!
  ): PublishableUnpublishPayload


  publishableUnpublishToCurrentChannel(

    id: ID!
  ): PublishableUnpublishToCurrentChannelPayload


  quantityPricingByVariantUpdate(

    priceListId: ID!


    input: QuantityPricingByVariantUpdateInput!
  ): QuantityPricingByVariantUpdatePayload


  quantityRulesAdd(

    priceListId: ID!


    quantityRules: [QuantityRuleInput!]!
  ): QuantityRulesAddPayload


  quantityRulesDelete(

    priceListId: ID!


    variantIds: [ID!]!
  ): QuantityRulesDeletePayload


  refundCreate(

    input: RefundInput!
  ): RefundCreatePayload


  returnApproveRequest(

    input: ReturnApproveRequestInput!
  ): ReturnApproveRequestPayload


  returnCancel(

    id: ID!


    notifyCustomer: Boolean = false
  ): ReturnCancelPayload


  returnClose(

    id: ID!
  ): ReturnClosePayload


  returnCreate(

    returnInput: ReturnInput!
  ): ReturnCreatePayload


  returnDeclineRequest(

    input: ReturnDeclineRequestInput!
  ): ReturnDeclineRequestPayload


  returnRefund(

    returnRefundInput: ReturnRefundInput!
  ): ReturnRefundPayload


  returnReopen(

    id: ID!
  ): ReturnReopenPayload


  returnRequest(

    input: ReturnRequestInput!
  ): ReturnRequestPayload


  reverseDeliveryCreateWithShipping(

    reverseFulfillmentOrderId: ID!


    reverseDeliveryLineItems: [ReverseDeliveryLineItemInput!]!


    trackingInput: ReverseDeliveryTrackingInput 


    labelInput: ReverseDeliveryLabelInput 


    notifyCustomer: Boolean = true
  ): ReverseDeliveryCreateWithShippingPayload


  reverseDeliveryDispose(

    dispositionInputs: [ReverseDeliveryDisposeInput!]!
  ): ReverseDeliveryDisposePayload @deprecated(reason: "`reverseDeliveryDispose` will be removed in API version 2025-01. Use `reverseFulfillmentOrderDispose` instead.")


  reverseDeliveryShippingUpdate(

    reverseDeliveryId: ID!


    trackingInput: ReverseDeliveryTrackingInput 


    labelInput: ReverseDeliveryLabelInput 


    notifyCustomer: Boolean = true
  ): ReverseDeliveryShippingUpdatePayload


  reverseFulfillmentOrderDispose(

    dispositionInputs: [ReverseFulfillmentOrderDisposeInput!]!
  ): ReverseFulfillmentOrderDisposePayload


  savedSearchCreate(

    input: SavedSearchCreateInput!
  ): SavedSearchCreatePayload


  savedSearchDelete(

    input: SavedSearchDeleteInput!
  ): SavedSearchDeletePayload


  savedSearchUpdate(

    input: SavedSearchUpdateInput!
  ): SavedSearchUpdatePayload


  scriptTagCreate(

    input: ScriptTagInput!
  ): ScriptTagCreatePayload


  scriptTagDelete(

    id: ID!
  ): ScriptTagDeletePayload


  scriptTagUpdate(

    id: ID!


    input: ScriptTagInput!
  ): ScriptTagUpdatePayload


  segmentCreate(

    name: String!


    query: String!
  ): SegmentCreatePayload


  segmentDelete(

    id: ID!
  ): SegmentDeletePayload


  segmentUpdate(

    id: ID!


    name: String


    query: String
  ): SegmentUpdatePayload


  sellingPlanGroupAddProductVariants(

    id: ID!


    productVariantIds: [ID!]!
  ): SellingPlanGroupAddProductVariantsPayload


  sellingPlanGroupAddProducts(

    id: ID!


    productIds: [ID!]!
  ): SellingPlanGroupAddProductsPayload


  sellingPlanGroupCreate(

    input: SellingPlanGroupInput!


    resources: SellingPlanGroupResourceInput
  ): SellingPlanGroupCreatePayload


  sellingPlanGroupDelete(

    id: ID!
  ): SellingPlanGroupDeletePayload


  sellingPlanGroupRemoveProductVariants(

    id: ID!


    productVariantIds: [ID!]!
  ): SellingPlanGroupRemoveProductVariantsPayload


  sellingPlanGroupRemoveProducts(

    id: ID!


    productIds: [ID!]!
  ): SellingPlanGroupRemoveProductsPayload


  sellingPlanGroupUpdate(

    id: ID!


    input: SellingPlanGroupInput!
  ): SellingPlanGroupUpdatePayload


  serverPixelCreate: ServerPixelCreatePayload


  serverPixelDelete: ServerPixelDeletePayload


  shippingPackageDelete(

    id: ID!
  ): ShippingPackageDeletePayload


  shippingPackageMakeDefault(

    id: ID!
  ): ShippingPackageMakeDefaultPayload


  shippingPackageUpdate(

    id: ID!


    shippingPackage: CustomShippingPackageInput!
  ): ShippingPackageUpdatePayload


  shopLocaleDisable(

    locale: String!
  ): ShopLocaleDisablePayload


  shopLocaleEnable(

    locale: String!


    marketWebPresenceIds: [ID!]
  ): ShopLocaleEnablePayload


  shopLocaleUpdate(

    locale: String!


    shopLocale: ShopLocaleInput!
  ): ShopLocaleUpdatePayload


  shopPolicyUpdate(

    shopPolicy: ShopPolicyInput!
  ): ShopPolicyUpdatePayload


  shopResourceFeedbackCreate(

    input: ResourceFeedbackCreateInput!
  ): ShopResourceFeedbackCreatePayload


  stagedUploadTargetGenerate(

    input: StagedUploadTargetGenerateInput!
  ): StagedUploadTargetGeneratePayload @deprecated(reason: "Use `stagedUploadsCreate` instead.")


  stagedUploadTargetsGenerate(

    input: [StageImageInput!]!
  ): StagedUploadTargetsGeneratePayload @deprecated(reason: "Use `stagedUploadsCreate` instead.")


  stagedUploadsCreate(

    input: [StagedUploadInput!]!
  ): StagedUploadsCreatePayload


  standardMetafieldDefinitionEnable(

    ownerType: MetafieldOwnerType!


    id: ID


    namespace: String


    key: String


    pin: Boolean! = false


    visibleToStorefrontApi: Boolean 


    useAsCollectionCondition: Boolean = false
  ): StandardMetafieldDefinitionEnablePayload


  standardMetaobjectDefinitionEnable(

    type: String!
  ): StandardMetaobjectDefinitionEnablePayload


  storefrontAccessTokenCreate(

    input: StorefrontAccessTokenInput!
  ): StorefrontAccessTokenCreatePayload


  storefrontAccessTokenDelete(

    input: StorefrontAccessTokenDeleteInput!
  ): StorefrontAccessTokenDeletePayload


  subscriptionBillingAttemptCreate(

    subscriptionContractId: ID!


    subscriptionBillingAttemptInput: SubscriptionBillingAttemptInput!
  ): SubscriptionBillingAttemptCreatePayload


  subscriptionBillingCycleContractDraftCommit(

    draftId: ID!
  ): SubscriptionBillingCycleContractDraftCommitPayload


  subscriptionBillingCycleContractDraftConcatenate(

    draftId: ID!


    concatenatedBillingCycleContracts: [SubscriptionBillingCycleInput!]!
  ): SubscriptionBillingCycleContractDraftConcatenatePayload


  subscriptionBillingCycleContractEdit(

    billingCycleInput: SubscriptionBillingCycleInput!
  ): SubscriptionBillingCycleContractEditPayload


  subscriptionBillingCycleEditDelete(

    billingCycleInput: SubscriptionBillingCycleInput!
  ): SubscriptionBillingCycleEditDeletePayload


  subscriptionBillingCycleEditsDelete(

    contractId: ID!


    targetSelection: SubscriptionBillingCyclesTargetSelection!
  ): SubscriptionBillingCycleEditsDeletePayload


  subscriptionBillingCycleScheduleEdit(

    billingCycleInput: SubscriptionBillingCycleInput!


    input: SubscriptionBillingCycleScheduleEditInput!
  ): SubscriptionBillingCycleScheduleEditPayload


  subscriptionBillingCycleSkip(

    billingCycleInput: SubscriptionBillingCycleInput!
  ): SubscriptionBillingCycleSkipPayload


  subscriptionBillingCycleUnskip(

    billingCycleInput: SubscriptionBillingCycleInput!
  ): SubscriptionBillingCycleUnskipPayload


  subscriptionContractActivate(

    subscriptionContractId: ID!
  ): SubscriptionContractActivatePayload


  subscriptionContractAtomicCreate(

    input: SubscriptionContractAtomicCreateInput!
  ): SubscriptionContractAtomicCreatePayload


  subscriptionContractCancel(

    subscriptionContractId: ID!
  ): SubscriptionContractCancelPayload


  subscriptionContractCreate(

    input: SubscriptionContractCreateInput!
  ): SubscriptionContractCreatePayload


  subscriptionContractExpire(

    subscriptionContractId: ID!
  ): SubscriptionContractExpirePayload


  subscriptionContractFail(

    subscriptionContractId: ID!
  ): SubscriptionContractFailPayload


  subscriptionContractPause(

    subscriptionContractId: ID!
  ): SubscriptionContractPausePayload


  subscriptionContractProductChange(

    subscriptionContractId: ID!


    lineId: ID!


    input: SubscriptionContractProductChangeInput!
  ): SubscriptionContractProductChangePayload


  subscriptionContractSetNextBillingDate(

    contractId: ID!


    date: DateTime!
  ): SubscriptionContractSetNextBillingDatePayload


  subscriptionContractUpdate(

    contractId: ID!
  ): SubscriptionContractUpdatePayload


  subscriptionDraftCommit(

    draftId: ID!
  ): SubscriptionDraftCommitPayload


  subscriptionDraftDiscountAdd(

    draftId: ID!


    input: SubscriptionManualDiscountInput!
  ): SubscriptionDraftDiscountAddPayload


  subscriptionDraftDiscountCodeApply(

    draftId: ID!


    redeemCode: String!
  ): SubscriptionDraftDiscountCodeApplyPayload


  subscriptionDraftDiscountRemove(

    draftId: ID!


    discountId: ID!
  ): SubscriptionDraftDiscountRemovePayload


  subscriptionDraftDiscountUpdate(

    draftId: ID!


    discountId: ID!


    input: SubscriptionManualDiscountInput!
  ): SubscriptionDraftDiscountUpdatePayload


  subscriptionDraftFreeShippingDiscountAdd(

    draftId: ID!


    input: SubscriptionFreeShippingDiscountInput!
  ): SubscriptionDraftFreeShippingDiscountAddPayload


  subscriptionDraftFreeShippingDiscountUpdate(

    draftId: ID!


    discountId: ID!


    input: SubscriptionFreeShippingDiscountInput!
  ): SubscriptionDraftFreeShippingDiscountUpdatePayload


  subscriptionDraftLineAdd(

    draftId: ID!


    input: SubscriptionLineInput!
  ): SubscriptionDraftLineAddPayload


  subscriptionDraftLineRemove(

    draftId: ID!


    lineId: ID!
  ): SubscriptionDraftLineRemovePayload


  subscriptionDraftLineUpdate(

    draftId: ID!


    lineId: ID!


    input: SubscriptionLineUpdateInput!
  ): SubscriptionDraftLineUpdatePayload


  subscriptionDraftUpdate(

    draftId: ID!


    input: SubscriptionDraftInput!
  ): SubscriptionDraftUpdatePayload


  tagsAdd(

    id: ID!


    tags: [String!]!
  ): TagsAddPayload


  tagsRemove(

    id: ID!


    tags: [String!]!
  ): TagsRemovePayload


  taxAppConfigure(

    ready: Boolean!
  ): TaxAppConfigurePayload


  translationsRegister(

    resourceId: ID!


    translations: [TranslationInput!]!
  ): TranslationsRegisterPayload


  translationsRemove(

    resourceId: ID!


    translationKeys: [String!]!


    locales: [String!]!


    marketIds: [ID!]
  ): TranslationsRemovePayload


  urlRedirectBulkDeleteAll: UrlRedirectBulkDeleteAllPayload


  urlRedirectBulkDeleteByIds(

    ids: [ID!]!
  ): UrlRedirectBulkDeleteByIdsPayload


  urlRedirectBulkDeleteBySavedSearch(

    savedSearchId: ID!
  ): UrlRedirectBulkDeleteBySavedSearchPayload


  urlRedirectBulkDeleteBySearch(

    search: String!
  ): UrlRedirectBulkDeleteBySearchPayload


  urlRedirectCreate(

    urlRedirect: UrlRedirectInput!
  ): UrlRedirectCreatePayload


  urlRedirectDelete(

    id: ID!
  ): UrlRedirectDeletePayload


  urlRedirectImportCreate(

    url: URL!
  ): UrlRedirectImportCreatePayload


  urlRedirectImportSubmit(

    id: ID!
  ): UrlRedirectImportSubmitPayload


  urlRedirectUpdate(

    id: ID!


    urlRedirect: UrlRedirectInput!
  ): UrlRedirectUpdatePayload


  validationCreate(

    validation: ValidationCreateInput!
  ): ValidationCreatePayload


  validationDelete(

    id: ID!
  ): ValidationDeletePayload


  validationUpdate(

    validation: ValidationUpdateInput!


    id: ID!
  ): ValidationUpdatePayload


  webPixelCreate(

    webPixel: WebPixelInput!
  ): WebPixelCreatePayload


  webPixelDelete(

    id: ID!
  ): WebPixelDeletePayload


  webPixelUpdate(

    id: ID!


    webPixel: WebPixelInput!
  ): WebPixelUpdatePayload


  webhookSubscriptionCreate(

    topic: WebhookSubscriptionTopic!


    subTopic: String


    webhookSubscription: WebhookSubscriptionInput!
  ): WebhookSubscriptionCreatePayload


  webhookSubscriptionDelete(

    id: ID!
  ): WebhookSubscriptionDeletePayload


  webhookSubscriptionUpdate(

    id: ID!


    webhookSubscription: WebhookSubscriptionInput!
  ): WebhookSubscriptionUpdatePayload
}


type MutationsStagedUploadTargetGenerateUploadParameter {

  name: String!


  value: String!
}


interface Navigable {

  defaultCursor: String!
}


type NavigationItem {

  id: String!


  title: String!


  url: URL!
}


interface Node {

  id: ID!
}


input ObjectDimensionsInput {

  length: Float!


  width: Float!


  height: Float!


  unit: LengthUnit!
}


type OnlineStoreArticle implements HasPublishedTranslations & Navigable & Node {

  defaultCursor: String!


  id: ID!


  translations(

    locale: String!


    marketId: ID
  ): [Translation!]!
}


type OnlineStoreBlog implements HasPublishedTranslations & Node {

  id: ID!


  translations(

    locale: String!


    marketId: ID
  ): [Translation!]!
}


type OnlineStorePage implements HasPublishedTranslations & Navigable & Node {

  defaultCursor: String!


  id: ID!


  translations(

    locale: String!


    marketId: ID
  ): [Translation!]!
}


interface OnlineStorePreviewable {

  onlineStorePreviewUrl: URL
}


type Order implements CommentEventSubject & HasEvents & HasLocalizationExtensions & HasMetafieldDefinitions & HasMetafields & LegacyInteroperability & Node {

  additionalFees: [AdditionalFee!]!


  agreements(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    query: String
  ): SalesAgreementConnection!


  alerts: [ResourceAlert!]!


  app: OrderApp


  billingAddress: MailingAddress


  billingAddressMatchesShippingAddress: Boolean!


  canMarkAsPaid: Boolean!


  canNotifyCustomer: Boolean!


  cancelReason: OrderCancelReason


  cancellation: OrderCancellation


  cancelledAt: DateTime


  capturable: Boolean!


  cartDiscountAmount: Money @deprecated(reason: "Use `cartDiscountAmountSet` instead.")


  cartDiscountAmountSet: MoneyBag


  channel: Channel @deprecated(reason: "Use `publication` instead.")


  channelInformation: ChannelInformation


  clientIp: String


  closed: Boolean!


  closedAt: DateTime


  confirmationNumber: String


  confirmed: Boolean!


  createdAt: DateTime!


  currencyCode: CurrencyCode!


  currentCartDiscountAmountSet: MoneyBag!


  currentSubtotalLineItemsQuantity: Int!


  currentSubtotalPriceSet: MoneyBag!


  currentTaxLines: [TaxLine!]!


  currentTotalAdditionalFeesSet: MoneyBag


  currentTotalDiscountsSet: MoneyBag!


  currentTotalDutiesSet: MoneyBag


  currentTotalPriceSet: MoneyBag!


  currentTotalTaxSet: MoneyBag!


  currentTotalWeight: UnsignedInt64!


  customAttributes: [Attribute!]!


  customer: Customer


  customerAcceptsMarketing: Boolean!


  customerJourney: CustomerJourney @deprecated(reason: "Use `customerJourneySummary` instead.")


  customerJourneySummary: CustomerJourneySummary


  customerLocale: String


  discountApplications(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): DiscountApplicationConnection!


  discountCode: String


  discountCodes: [String!]!


  displayAddress: MailingAddress


  displayFinancialStatus: OrderDisplayFinancialStatus


  displayFulfillmentStatus: OrderDisplayFulfillmentStatus!


  disputes: [OrderDisputeSummary!]!


  edited: Boolean!


  email: String


  estimatedTaxes: Boolean!


  events(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: EventSortKeys = ID


    query: String
  ): EventConnection!


  exchangeV2s(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    query: String
  ): ExchangeV2Connection!


  fulfillable: Boolean!


  fulfillmentOrders(

    displayable: Boolean = false


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    query: String
  ): FulfillmentOrderConnection!


  fulfillments(

    first: Int
  ): [Fulfillment!]!


  fullyPaid: Boolean!


  hasTimelineComment: Boolean!


  id: ID!


  landingPageDisplayText: String @deprecated(reason: "Use `customerJourneySummary.lastVisit.landingPageHtml` instead")


  landingPageUrl: URL @deprecated(reason: "Use `customerJourneySummary.lastVisit.landingPage` instead")


  legacyResourceId: UnsignedInt64!


  lineItems(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): LineItemConnection!


  lineItemsMutable(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): LineItemMutableConnection! @deprecated(reason: "Use `lineItems` instead.")


  localizationExtensions(

    countryCodes: [CountryCode!]


    purposes: [LocalizationExtensionPurpose!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): LocalizationExtensionConnection!


  location: String @deprecated(reason: "Use `physicalLocation` instead.")


  merchantEditable: Boolean!


  merchantEditableErrors: [String!]!


  merchantOfRecordApp: OrderApp


  metafield(

    namespace: String


    key: String!
  ): Metafield


  metafieldDefinitions(

    namespace: String


    pinnedStatus: MetafieldDefinitionPinnedStatus = ANY


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: MetafieldDefinitionSortKeys = ID


    query: String
  ): MetafieldDefinitionConnection!


  metafields(

    namespace: String


    keys: [String!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  name: String!


  netPayment: Money! @deprecated(reason: "Use `netPaymentSet` instead.")


  netPaymentSet: MoneyBag!


  nonFulfillableLineItems(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): LineItemConnection!


  note: String


  originalTotalAdditionalFeesSet: MoneyBag


  originalTotalDutiesSet: MoneyBag


  originalTotalPriceSet: MoneyBag!


  paymentCollectionDetails: OrderPaymentCollectionDetails!


  paymentGatewayNames: [String!]!


  paymentTerms: PaymentTerms


  phone: String


  physicalLocation: Location @deprecated(reason: "Use `fulfillmentOrders` to get the fulfillment location for the order")


  poNumber: String


  presentmentCurrencyCode: CurrencyCode!


  privateMetafield(

    namespace: String!


    key: String!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  processedAt: DateTime!


  publication: Publication


  purchasingEntity: PurchasingEntity


  referralCode: String @deprecated(reason: "Use `customerJourneySummary.lastVisit.referralCode` instead")


  referrerDisplayText: String @deprecated(reason: "Use `customerJourneySummary.lastVisit.referralInfoHtml` instead")


  referrerUrl: URL @deprecated(reason: "Use `customerJourneySummary.lastVisit.referrerUrl` instead")


  refundDiscrepancySet: MoneyBag!


  refundable: Boolean!


  refunds(

    first: Int
  ): [Refund!]!


  registeredSourceUrl: URL


  requiresShipping: Boolean!


  restockable: Boolean!


  returnStatus: OrderReturnStatus!


  returns(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    query: String
  ): ReturnConnection!


  riskLevel: OrderRiskLevel! @deprecated(reason: "This field is deprecated in version 2024-04. Please use OrderRiskAssessment.riskLevel")


  risks(

    first: Int
  ): [OrderRisk!]! @deprecated(reason: "This field is deprecated in version 2024-04. Please use OrderRiskAssessment")


  shippingAddress: MailingAddress


  shippingLine: ShippingLine


  shippingLines(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ShippingLineConnection!


  shopifyProtect: ShopifyProtectOrderSummary


  sourceIdentifier: String


  subtotalLineItemsQuantity: Int!


  subtotalPrice: Money @deprecated(reason: "Use `subtotalPriceSet` instead.")


  subtotalPriceSet: MoneyBag


  suggestedRefund(

    shippingAmount: Money


    refundShipping: Boolean


    refundLineItems: [RefundLineItemInput!]


    refundDuties: [RefundDutyInput!]


    suggestFullRefund: Boolean = false
  ): SuggestedRefund


  tags: [String!]!


  taxExempt: Boolean!


  taxLines: [TaxLine!]!


  taxesIncluded: Boolean!


  test: Boolean!


  totalCapturable: Money! @deprecated(reason: "Use `totalCapturableSet` instead.")


  totalCapturableSet: MoneyBag!


  totalDiscounts: Money @deprecated(reason: "Use `totalDiscountsSet` instead.")


  totalDiscountsSet: MoneyBag


  totalOutstandingSet: MoneyBag!


  totalPrice: Money! @deprecated(reason: "Use `totalPriceSet` instead.")


  totalPriceSet: MoneyBag!


  totalReceived: Money! @deprecated(reason: "Use `totalReceivedSet` instead.")


  totalReceivedSet: MoneyBag!


  totalRefunded: Money! @deprecated(reason: "Use `totalRefundedSet` instead.")


  totalRefundedSet: MoneyBag!


  totalRefundedShippingSet: MoneyBag!


  totalShippingPrice: Money! @deprecated(reason: "Use `totalShippingPriceSet` instead.")


  totalShippingPriceSet: MoneyBag!


  totalTax: Money @deprecated(reason: "Use `totalTaxSet` instead.")


  totalTaxSet: MoneyBag


  totalTipReceived: MoneyV2! @deprecated(reason: "Use `totalTipReceivedSet` instead.")


  totalTipReceivedSet: MoneyBag!


  totalWeight: UnsignedInt64


  transactions(

    first: Int


    capturable: Boolean


    manuallyResolvable: Boolean
  ): [OrderTransaction!]!


  unpaid: Boolean!


  updatedAt: DateTime!
}


enum OrderActionType {

  ORDER


  ORDER_EDIT


  REFUND


  UNKNOWN
}


type OrderAgreement implements SalesAgreement {

  app: App


  happenedAt: DateTime!


  id: ID!


  order: Order!


  reason: OrderActionType!


  sales(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SaleConnection!


  user: StaffMember
}


type OrderApp {

  icon: Image!


  id: ID!


  name: String!
}


type OrderCancellation {

  staffNote: String
}


type OrderCancelPayload {

  job: Job


  orderCancelUserErrors: [OrderCancelUserError!]!


  userErrors: [UserError!]! @deprecated(reason: "Use `orderCancelUserErrors` instead.")
}


enum OrderCancelReason {

  CUSTOMER


  DECLINED


  FRAUD


  INVENTORY


  STAFF


  OTHER
}


type OrderCancelUserError implements DisplayableError {

  code: OrderCancelUserErrorCode


  field: [String!]


  message: String!
}


enum OrderCancelUserErrorCode {

  NO_REFUND_PERMISSION


  NOT_FOUND


  INVALID
}


input OrderCaptureInput {

  id: ID!


  parentTransactionId: ID!


  amount: Money!


  currency: CurrencyCode
}


type OrderCapturePayload {

  transaction: OrderTransaction


  userErrors: [UserError!]!
}


input OrderCloseInput {

  id: ID!
}


type OrderClosePayload {

  order: Order


  userErrors: [UserError!]!
}


type OrderConnection {

  edges: [OrderEdge!]!


  nodes: [Order!]!


  pageInfo: PageInfo!
}


type OrderCreateMandatePaymentPayload {

  job: Job


  paymentReferenceId: String


  userErrors: [OrderCreateMandatePaymentUserError!]!
}


type OrderCreateMandatePaymentUserError implements DisplayableError {

  code: OrderCreateMandatePaymentUserErrorCode


  field: [String!]


  message: String!
}


enum OrderCreateMandatePaymentUserErrorCode {

  ORDER_MANDATE_PAYMENT_ERROR_CODE
}


enum OrderDisplayFinancialStatus {

  PENDING


  AUTHORIZED


  PARTIALLY_PAID


  PARTIALLY_REFUNDED


  VOIDED


  PAID


  REFUNDED


  EXPIRED
}


enum OrderDisplayFulfillmentStatus {

  UNFULFILLED


  PARTIALLY_FULFILLED


  FULFILLED


  RESTOCKED


  PENDING_FULFILLMENT


  OPEN


  IN_PROGRESS


  ON_HOLD


  SCHEDULED
}


type OrderDisputeSummary implements Node {

  id: ID!


  initiatedAs: DisputeType!


  status: DisputeStatus!
}


type OrderEdge {

  cursor: String!


  node: Order!
}


type OrderEditAddCustomItemPayload {

  calculatedLineItem: CalculatedLineItem


  calculatedOrder: CalculatedOrder


  userErrors: [UserError!]!
}


type OrderEditAddLineItemDiscountPayload {

  addedDiscountStagedChange: OrderStagedChangeAddLineItemDiscount


  calculatedLineItem: CalculatedLineItem


  calculatedOrder: CalculatedOrder


  userErrors: [UserError!]!
}


type OrderEditAddVariantPayload {

  calculatedLineItem: CalculatedLineItem


  calculatedOrder: CalculatedOrder


  userErrors: [UserError!]!
}


type OrderEditAgreement implements SalesAgreement {

  app: App


  happenedAt: DateTime!


  id: ID!


  reason: OrderActionType!


  sales(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SaleConnection!


  user: StaffMember
}


input OrderEditAppliedDiscountInput {

  description: String


  fixedValue: MoneyInput


  percentValue: Float
}


type OrderEditBeginPayload {

  calculatedOrder: CalculatedOrder


  userErrors: [UserError!]!
}


type OrderEditCommitPayload {

  order: Order


  userErrors: [UserError!]!
}


type OrderEditRemoveDiscountPayload {

  calculatedOrder: CalculatedOrder


  userErrors: [OrderEditRemoveDiscountUserError!]!
}


type OrderEditRemoveDiscountUserError implements DisplayableError {

  code: OrderEditRemoveDiscountUserErrorCode


  field: [String!]


  message: String!
}


enum OrderEditRemoveDiscountUserErrorCode {

  INVALID
}


type OrderEditRemoveLineItemDiscountPayload {

  calculatedLineItem: CalculatedLineItem


  calculatedOrder: CalculatedOrder


  userErrors: [UserError!]!
}


type OrderEditSetQuantityPayload {

  calculatedLineItem: CalculatedLineItem


  calculatedOrder: CalculatedOrder


  userErrors: [UserError!]!
}


type OrderEditUpdateDiscountPayload {

  calculatedOrder: CalculatedOrder


  userErrors: [OrderEditUpdateDiscountUserError!]!
}


type OrderEditUpdateDiscountUserError implements DisplayableError {

  code: OrderEditUpdateDiscountUserErrorCode


  field: [String!]


  message: String!
}


enum OrderEditUpdateDiscountUserErrorCode {

  INVALID
}


input OrderInput {

  id: ID!


  email: String


  note: String


  tags: [String!]


  shippingAddress: MailingAddressInput


  customAttributes: [AttributeInput!]


  metafields: [MetafieldInput!]


  localizationExtensions: [LocalizationExtensionInput!]


  poNumber: String
}


type OrderInvoiceSendPayload {

  order: Order


  userErrors: [OrderInvoiceSendUserError!]!
}


type OrderInvoiceSendUserError implements DisplayableError {

  code: OrderInvoiceSendUserErrorCode


  field: [String!]


  message: String!
}


enum OrderInvoiceSendUserErrorCode {

  ORDER_INVOICE_SEND_UNSUCCESSFUL
}


input OrderMarkAsPaidInput {

  id: ID!
}


type OrderMarkAsPaidPayload {

  order: Order


  userErrors: [UserError!]!
}


input OrderOpenInput {

  id: ID!
}


type OrderOpenPayload {

  order: Order


  userErrors: [UserError!]!
}


type OrderPaymentCollectionDetails {

  additionalPaymentCollectionUrl: URL


  vaultedPaymentMethods: [PaymentMandate!]
}


type OrderPaymentStatus {

  errorMessage: String


  paymentReferenceId: String!


  status: OrderPaymentStatusResult!


  translatedErrorMessage: String
}


enum OrderPaymentStatusResult {

  SUCCESS


  AUTHORIZED


  VOIDED


  REFUNDED


  CAPTURED


  PURCHASED


  ERROR


  PROCESSING


  REDIRECT_REQUIRED


  RETRYABLE


  UNKNOWN


  INITIATED


  PENDING
}


enum OrderReturnStatus {

  IN_PROGRESS


  INSPECTION_COMPLETE


  NO_RETURN


  RETURNED


  RETURN_FAILED


  RETURN_REQUESTED
}


type OrderRisk {

  display: Boolean! @deprecated(reason: "This field is deprecated in version 2024-04")


  level: OrderRiskLevel @deprecated(reason: "This field is deprecated in version 2024-04. Please use OrderRiskAssessment.riskLevel")


  message: String @deprecated(reason: "This field is deprecated in version 2024-04")
}


enum OrderRiskLevel {

  LOW


  MEDIUM


  HIGH
}


enum OrderSortKeys {

  CREATED_AT


  CUSTOMER_NAME


  DESTINATION


  FINANCIAL_STATUS


  FULFILLMENT_STATUS


  ORDER_NUMBER


  PROCESSED_AT


  TOTAL_ITEMS_QUANTITY


  TOTAL_PRICE


  UPDATED_AT


  PO_NUMBER


  ID


  RELEVANCE
}


union OrderStagedChange = OrderStagedChangeAddCustomItem | OrderStagedChangeAddLineItemDiscount | OrderStagedChangeAddShippingLine | OrderStagedChangeAddVariant | OrderStagedChangeDecrementItem | OrderStagedChangeIncrementItem


type OrderStagedChangeAddCustomItem {

  originalUnitPrice: MoneyV2!


  quantity: Int!


  title: String!
}


type OrderStagedChangeAddLineItemDiscount {

  description: String!


  id: ID!


  value: PricingValue!
}


type OrderStagedChangeAddShippingLine {

  phone: String


  presentmentTitle: String


  price: MoneyV2!


  title: String
}


type OrderStagedChangeAddVariant {

  quantity: Int!


  variant: ProductVariant!
}


type OrderStagedChangeConnection {

  edges: [OrderStagedChangeEdge!]!


  nodes: [OrderStagedChange!]!


  pageInfo: PageInfo!
}


type OrderStagedChangeDecrementItem {

  delta: Int!


  lineItem: LineItem!


  restock: Boolean!
}


type OrderStagedChangeEdge {

  cursor: String!


  node: OrderStagedChange!
}


type OrderStagedChangeIncrementItem {

  delta: Int!


  lineItem: LineItem!
}


type OrderTransaction implements Node {

  accountNumber: String


  amount: Money! @deprecated(reason: "Use `amountSet` instead.")


  amountSet: MoneyBag!


  amountV2: MoneyV2! @deprecated(reason: "Use `amountSet` instead.")


  authorizationCode: String


  authorizationExpiresAt: DateTime


  createdAt: DateTime!


  errorCode: OrderTransactionErrorCode


  fees: [TransactionFee!]!


  formattedGateway: String


  gateway: String


  id: ID!


  kind: OrderTransactionKind!


  manuallyCapturable: Boolean!


  maximumRefundable: Money @deprecated(reason: "Use `maximumRefundableV2` instead.")


  maximumRefundableV2: MoneyV2


  multiCapturable: Boolean!


  order: Order


  parentTransaction: OrderTransaction


  paymentDetails: PaymentDetails


  paymentIcon: Image


  paymentId: String


  paymentMethod: PaymentMethods @deprecated(reason: "Use `paymentIcon` instead.")


  processedAt: DateTime


  receipt: String @deprecated(reason: "Use `receiptJson` instead.")


  receiptJson: JSON


  settlementCurrency: CurrencyCode


  settlementCurrencyRate: Decimal


  shopifyPaymentsSet: ShopifyPaymentsTransactionSet


  status: OrderTransactionStatus!


  test: Boolean!


  totalUnsettled: Money @deprecated(reason: "Use `totalUnsettledSet` instead.")


  totalUnsettledSet: MoneyBag


  totalUnsettledV2: MoneyV2 @deprecated(reason: "Use `totalUnsettledSet` instead.")


  user: StaffMember
}


type OrderTransactionConnection {

  edges: [OrderTransactionEdge!]!


  nodes: [OrderTransaction!]!


  pageInfo: PageInfo!
}


type OrderTransactionEdge {

  cursor: String!


  node: OrderTransaction!
}


enum OrderTransactionErrorCode {

  INCORRECT_NUMBER


  INVALID_NUMBER


  INVALID_EXPIRY_DATE


  INVALID_CVC


  EXPIRED_CARD


  INCORRECT_CVC


  INCORRECT_ZIP


  INCORRECT_ADDRESS


  INCORRECT_PIN


  CARD_DECLINED


  PROCESSING_ERROR


  CALL_ISSUER


  PICK_UP_CARD


  CONFIG_ERROR


  TEST_MODE_LIVE_CARD


  UNSUPPORTED_FEATURE


  GENERIC_ERROR


  INVALID_COUNTRY


  INVALID_AMOUNT


  PAYMENT_METHOD_UNAVAILABLE


  AMAZON_PAYMENTS_INVALID_PAYMENT_METHOD


  AMAZON_PAYMENTS_MAX_AMOUNT_CHARGED


  AMAZON_PAYMENTS_MAX_AMOUNT_REFUNDED


  AMAZON_PAYMENTS_MAX_AUTHORIZATIONS_CAPTURED


  AMAZON_PAYMENTS_MAX_REFUNDS_PROCESSED


  AMAZON_PAYMENTS_ORDER_REFERENCE_CANCELED


  AMAZON_PAYMENTS_STALE
}


input OrderTransactionInput {

  amount: Money!


  gateway: String!


  kind: OrderTransactionKind!


  orderId: ID!


  parentId: ID
}


enum OrderTransactionKind {

  SALE


  CAPTURE


  AUTHORIZATION


  VOID


  REFUND


  CHANGE


  EMV_AUTHORIZATION


  SUGGESTED_REFUND
}


enum OrderTransactionStatus {

  SUCCESS


  FAILURE


  PENDING


  ERROR


  AWAITING_RESPONSE


  UNKNOWN
}


type OrderUpdatePayload {

  order: Order


  userErrors: [UserError!]!
}


type PageInfo {

  endCursor: String


  hasNextPage: Boolean!


  hasPreviousPage: Boolean!


  startCursor: String
}


type ParseError {

  code: ParseErrorCode!


  message: String!


  range: ParseErrorRange
}


enum ParseErrorCode {

  SYNTAX_NOT_RECOGNIZED


  SEMANTICALLY_INVALID


  TABLE_NOT_FOUND


  COLUMN_NOT_FOUND


  VALUE_NOT_PARSABLE


  DATE_NOT_PARSABLE


  DATE_TIME_NOT_PARSABLE


  DATE_INTERVAL_NOT_FOUND


  NAMED_DATE_NOT_FOUND


  SORT_FIELD_NOT_FOUND


  LIMIT_INVALID


  VISUALIZE_CHART_TYPE_NOT_FOUND


  FUNCTION_MODIFIER_NOT_FOUND


  FUNCTION_ARGUMENTS_NOT_FOUND


  FUNCTION_EXCESS_ARGUMENTS


  FROM_NOT_FOUND


  PRESENTMENT_NOT_FOUND


  EXCESS_PRESENTMENTS


  FUNCTION_INCOMPATIBLE_TYPES


  VISUALIZE_EXCESS_PROJECTIONS


  UNKNOWN


  OPERATOR_INCOMPATIBLE_TYPES


  VISUALIZE_INCOMPATIBLE_TYPES


  VISUALIZE_GROUP_BY_NOT_FOUND


  VISUALIZE_GROUP_BY_MIXED_BACKFILL


  MIXED_AGGREGATE_AND_NON_AGGREGATE


  FUNCTION_NESTED_AGGREGATE


  TIME_FUNCTION_NOT_FOUND


  LIST_MIXED_ARGUMENT_TYPES


  EXCESS_PERIODS


  SYNTAX_INVALID_TOKEN


  SYNTAX_NO_VIABLE_ALTERNATIVE


  COMPARE_TO_INVALID_PERIOD


  COMPARE_TO_INCOMPATIBLE_PERIOD


  UNBACKFILLED_TIME_GROUP_BY_COMPARISON


  COMPARISON_WITH_NON_AGGREGATE_FIELDS


  REQUIRED_GROUP_BY_NOT_FOUND


  SYNTAX_INPUT_MISMATCH


  SYNTAX_UNWANTED_TOKEN


  SYNTAX_MISSING_TOKEN


  FUNCTION_NOT_FOUND


  INVALID_DATE_RANGE


  EXCESS_BACKFILL_DIMENSIONS


  BACKFILL_DATE_RANGE_NOT_FOUND


  COMPARE_TO_MISSING_PERIOD


  EXCESS_DIMENSIONS


  SYNTAX_FAILED_PREDICATE
}


type ParseErrorRange {

  end: ErrorPosition!


  start: ErrorPosition!
}


type PaymentCustomization implements HasMetafieldDefinitions & HasMetafields & Node {

  enabled: Boolean!


  errorHistory: FunctionsErrorHistory


  functionId: String!


  id: ID!


  metafield(

    namespace: String


    key: String!
  ): Metafield


  metafieldDefinitions(

    namespace: String


    pinnedStatus: MetafieldDefinitionPinnedStatus = ANY


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: MetafieldDefinitionSortKeys = ID


    query: String
  ): MetafieldDefinitionConnection!


  metafields(

    namespace: String


    keys: [String!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  privateMetafield(

    namespace: String!


    key: String!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  shopifyFunction: ShopifyFunction!


  title: String!
}


type PaymentCustomizationActivationPayload {

  ids: [String!]


  userErrors: [PaymentCustomizationError!]!
}


type PaymentCustomizationConnection {

  edges: [PaymentCustomizationEdge!]!


  nodes: [PaymentCustomization!]!


  pageInfo: PageInfo!
}


type PaymentCustomizationCreatePayload {

  paymentCustomization: PaymentCustomization


  userErrors: [PaymentCustomizationError!]!
}


type PaymentCustomizationDeletePayload {

  deletedId: ID


  userErrors: [PaymentCustomizationError!]!
}


type PaymentCustomizationEdge {

  cursor: String!


  node: PaymentCustomization!
}


type PaymentCustomizationError implements DisplayableError {

  code: PaymentCustomizationErrorCode


  field: [String!]


  message: String!
}


enum PaymentCustomizationErrorCode {

  CUSTOM_APP_FUNCTION_NOT_ELIGIBLE


  FUNCTION_DOES_NOT_IMPLEMENT


  FUNCTION_NOT_FOUND


  FUNCTION_PENDING_DELETION


  INVALID


  PAYMENT_CUSTOMIZATION_NOT_FOUND


  PAYMENT_CUSTOMIZATION_FUNCTION_NOT_ELIGIBLE


  MAXIMUM_ACTIVE_PAYMENT_CUSTOMIZATIONS


  REQUIRED_INPUT_FIELD


  INVALID_METAFIELDS


  FUNCTION_ID_CANNOT_BE_CHANGED
}


input PaymentCustomizationInput {

  functionId: String


  title: String


  enabled: Boolean


  metafields: [MetafieldInput!] = []
}


type PaymentCustomizationUpdatePayload {

  paymentCustomization: PaymentCustomization


  userErrors: [PaymentCustomizationError!]!
}


union PaymentDetails = CardPaymentDetails | ShopPayInstallmentsPaymentDetails


union PaymentInstrument = VaultCreditCard | VaultPaypalBillingAgreement


type PaymentMandate implements Node {

  id: ID!


  paymentInstrument: PaymentInstrument!
}


enum PaymentMethods {
  VISA
  MASTERCARD
  DISCOVER
  AMERICAN_EXPRESS
  DINERS_CLUB
  JCB


  UNIONPAY


  ELO
  DANKORT
  MAESTRO
  FORBRUGSFORENINGEN
  PAYPAL
  BOGUS
  BITCOIN
  LITECOIN
  DOGECOIN


  INTERAC


  EFTPOS
}


type PaymentReminderSendPayload {

  success: Boolean


  userErrors: [PaymentReminderSendUserError!]!
}


type PaymentReminderSendUserError implements DisplayableError {

  code: PaymentReminderSendUserErrorCode


  field: [String!]


  message: String!
}


enum PaymentReminderSendUserErrorCode {

  PAYMENT_REMINDER_SEND_UNSUCCESSFUL
}


type PaymentSchedule implements Node {

  amount: MoneyV2!


  completedAt: DateTime


  dueAt: DateTime


  id: ID!


  issuedAt: DateTime


  paymentTerms: PaymentTerms!
}


type PaymentScheduleConnection {

  edges: [PaymentScheduleEdge!]!


  nodes: [PaymentSchedule!]!


  pageInfo: PageInfo!
}


type PaymentScheduleEdge {

  cursor: String!


  node: PaymentSchedule!
}


input PaymentScheduleInput {

  issuedAt: DateTime


  dueAt: DateTime
}


type PaymentSettings {

  supportedDigitalWallets: [DigitalWallet!]!
}


type PaymentTerms implements Node {

  draftOrder: DraftOrder


  dueInDays: Int


  id: ID!


  order: Order


  overdue: Boolean!


  paymentSchedules(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PaymentScheduleConnection!


  paymentTermsName: String!


  paymentTermsType: PaymentTermsType!


  translatedName: String!
}


input PaymentTermsCreateInput {

  paymentTermsTemplateId: ID!


  paymentSchedules: [PaymentScheduleInput!]
}


type PaymentTermsCreatePayload {

  paymentTerms: PaymentTerms


  userErrors: [PaymentTermsCreateUserError!]!
}


type PaymentTermsCreateUserError implements DisplayableError {

  code: PaymentTermsCreateUserErrorCode


  field: [String!]


  message: String!
}


enum PaymentTermsCreateUserErrorCode {

  PAYMENT_TERMS_CREATION_UNSUCCESSFUL
}


input PaymentTermsDeleteInput {

  paymentTermsId: ID!
}


type PaymentTermsDeletePayload {

  deletedId: ID


  userErrors: [PaymentTermsDeleteUserError!]!
}


type PaymentTermsDeleteUserError implements DisplayableError {

  code: PaymentTermsDeleteUserErrorCode


  field: [String!]


  message: String!
}


enum PaymentTermsDeleteUserErrorCode {

  PAYMENT_TERMS_DELETE_UNSUCCESSFUL
}


input PaymentTermsInput {

  paymentTermsTemplateId: ID


  paymentSchedules: [PaymentScheduleInput!]
}


type PaymentTermsTemplate implements Node {

  description: String!


  dueInDays: Int


  id: ID!


  name: String!


  paymentTermsType: PaymentTermsType!


  translatedName: String!
}


enum PaymentTermsType {

  RECEIPT


  NET


  FIXED


  FULFILLMENT


  UNKNOWN
}


input PaymentTermsUpdateInput {

  paymentTermsId: ID!


  paymentTermsAttributes: PaymentTermsInput!
}


type PaymentTermsUpdatePayload {

  paymentTerms: PaymentTerms


  userErrors: [PaymentTermsUpdateUserError!]!
}


type PaymentTermsUpdateUserError implements DisplayableError {

  code: PaymentTermsUpdateUserErrorCode


  field: [String!]


  message: String!
}


enum PaymentTermsUpdateUserErrorCode {

  PAYMENT_TERMS_UPDATE_UNSUCCESSFUL
}


enum PaypalExpressSubscriptionsGatewayStatus {

  ENABLED


  DISABLED


  PENDING
}


type PolarisVizDataPoint {

  key: String!


  value: String
}


type PolarisVizDataSeries {

  data: [PolarisVizDataPoint!]!


  isComparison: Boolean!


  name: String!
}


type PolarisVizResponse implements ShopifyqlResponse {

  data: [PolarisVizDataSeries!]!


  parseErrors: [ParseError!]


  tableData: TableData


  vizType: VisualizationType!
}


input PreparedFulfillmentOrderLineItemsInput {

  fulfillmentOrderId: ID!
}


enum PriceCalculationType {

  COMPONENTS_SUM


  FIXED


  NONE
}


input PriceInput {

  calculation: PriceCalculationType


  price: Money
}


type PriceList implements Node {

  catalog: Catalog


  currency: CurrencyCode!


  fixedPricesCount: Int!


  id: ID!


  name: String!


  parent: PriceListParent


  prices(

    originType: PriceListPriceOriginType


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    query: String
  ): PriceListPriceConnection!


  quantityRules(

    originType: QuantityRuleOriginType


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): QuantityRuleConnection!
}


type PriceListAdjustment {

  type: PriceListAdjustmentType!


  value: Float!
}


input PriceListAdjustmentInput {

  value: Float!


  type: PriceListAdjustmentType!
}


type PriceListAdjustmentSettings {

  compareAtMode: PriceListCompareAtMode!
}


input PriceListAdjustmentSettingsInput {

  compareAtMode: PriceListCompareAtMode! = ADJUSTED
}


enum PriceListAdjustmentType {

  PERCENTAGE_DECREASE


  PERCENTAGE_INCREASE
}


enum PriceListCompareAtMode {

  ADJUSTED


  NULLIFY
}


type PriceListConnection {

  edges: [PriceListEdge!]!


  nodes: [PriceList!]!


  pageInfo: PageInfo!
}


input PriceListCreateInput {

  name: String!


  currency: CurrencyCode!


  parent: PriceListParentCreateInput!


  catalogId: ID
}


type PriceListCreatePayload {

  priceList: PriceList


  userErrors: [PriceListUserError!]!
}


type PriceListDeletePayload {

  deletedId: ID


  userErrors: [PriceListUserError!]!
}


type PriceListEdge {

  cursor: String!


  node: PriceList!
}


type PriceListFixedPricesAddPayload {

  prices: [PriceListPrice!]


  userErrors: [PriceListPriceUserError!]!
}


type PriceListFixedPricesByProductBulkUpdateUserError implements DisplayableError {

  code: PriceListFixedPricesByProductBulkUpdateUserErrorCode


  field: [String!]


  message: String!
}


enum PriceListFixedPricesByProductBulkUpdateUserErrorCode {

  NO_UPDATE_OPERATIONS_SPECIFIED


  PRICES_TO_ADD_CURRENCY_MISMATCH


  PRICE_LIST_DOES_NOT_EXIST


  DUPLICATE_ID_IN_INPUT


  ID_MUST_BE_MUTUALLY_EXCLUSIVE


  PRODUCT_DOES_NOT_EXIST


  PRICE_LIMIT_EXCEEDED
}


type PriceListFixedPricesByProductUpdatePayload {

  priceList: PriceList


  pricesToAddProducts: [Product!]


  pricesToDeleteProducts: [Product!]


  userErrors: [PriceListFixedPricesByProductBulkUpdateUserError!]!
}


type PriceListFixedPricesDeletePayload {

  deletedFixedPriceVariantIds: [ID!]


  userErrors: [PriceListPriceUserError!]!
}


type PriceListFixedPricesUpdatePayload {

  deletedFixedPriceVariantIds: [ID!]


  priceList: PriceList


  pricesAdded: [PriceListPrice!]


  userErrors: [PriceListPriceUserError!]!
}


type PriceListParent {

  adjustment: PriceListAdjustment!


  settings: PriceListAdjustmentSettings!
}


input PriceListParentCreateInput {

  adjustment: PriceListAdjustmentInput!


  settings: PriceListAdjustmentSettingsInput
}


input PriceListParentUpdateInput {

  adjustment: PriceListAdjustmentInput!


  settings: PriceListAdjustmentSettingsInput
}


type PriceListPrice {

  compareAtPrice: MoneyV2


  originType: PriceListPriceOriginType!


  price: MoneyV2!


  quantityPriceBreaks(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: QuantityPriceBreakSortKeys = MINIMUM_QUANTITY
  ): QuantityPriceBreakConnection!


  variant: ProductVariant!
}


type PriceListPriceConnection {

  edges: [PriceListPriceEdge!]!


  nodes: [PriceListPrice!]!


  pageInfo: PageInfo!
}


type PriceListPriceEdge {

  cursor: String!


  node: PriceListPrice!
}


input PriceListPriceInput {

  variantId: ID!


  price: MoneyInput!


  compareAtPrice: MoneyInput
}


enum PriceListPriceOriginType {

  FIXED


  RELATIVE
}


type PriceListPriceUserError implements DisplayableError {

  code: PriceListPriceUserErrorCode


  field: [String!]


  message: String!
}


enum PriceListPriceUserErrorCode {

  BLANK


  PRICE_LIST_NOT_FOUND


  PRICE_LIST_CURRENCY_MISMATCH


  VARIANT_NOT_FOUND


  PRICE_NOT_FIXED
}


input PriceListProductPriceInput {

  productId: ID!


  price: MoneyInput!
}


enum PriceListSortKeys {

  NAME


  ID


  RELEVANCE
}


input PriceListUpdateInput {

  name: String


  currency: CurrencyCode


  parent: PriceListParentUpdateInput


  catalogId: ID
}


type PriceListUpdatePayload {

  priceList: PriceList


  userErrors: [PriceListUserError!]!
}


type PriceListUserError implements DisplayableError {

  code: PriceListUserErrorCode


  field: [String!]


  message: String!
}


enum PriceListUserErrorCode {

  TAKEN


  BLANK


  INCLUSION


  TOO_LONG


  PRICE_LIST_NOT_FOUND


  PRICE_LIST_LOCKED


  CONTEXT_RULE_LIMIT_REACHED @deprecated(reason: "The limit is removed.")


  CONTEXT_RULE_COUNTRIES_LIMIT


  CURRENCY_COUNTRY_MISMATCH


  COUNTRY_CURRENCY_MISMATCH


  CURRENCY_MARKET_MISMATCH


  MARKET_CURRENCY_MISMATCH


  INVALID_ADJUSTMENT_VALUE


  INVALID_ADJUSTMENT_MIN_VALUE


  INVALID_ADJUSTMENT_MAX_VALUE


  CONTEXT_RULE_COUNTRY_TAKEN


  CATALOG_CONTEXT_DOES_NOT_SUPPORT_QUANTITY_RULES


  CATALOG_CONTEXT_DOES_NOT_SUPPORT_QUANTITY_PRICE_BREAKS


  CONTEXT_RULE_LIMIT_ONE_OPTION


  CONTEXT_RULE_MARKET_NOT_FOUND


  CONTEXT_RULE_MARKET_TAKEN


  CURRENCY_NOT_SUPPORTED


  PRICE_LIST_NOT_ALLOWED_FOR_PRIMARY_MARKET


  CATALOG_ASSIGNMENT_NOT_ALLOWED


  CATALOG_DOES_NOT_EXIST


  CATALOG_CANNOT_CHANGE_CONTEXT_TYPE


  CATALOG_MARKET_AND_PRICE_LIST_CURRENCY_MISMATCH


  CATALOG_TAKEN


  COUNTRY_PRICE_LIST_ASSIGNMENT


  APP_CATALOG_PRICE_LIST_ASSIGNMENT


  GENERIC_ERROR
}


type PriceRule implements CommentEventSubject & HasEvents & LegacyInteroperability & Node {

  allocationLimit: Int


  allocationMethod: PriceRuleAllocationMethod!


  app: App


  combinesWith: DiscountCombinesWith!


  createdAt: DateTime!


  customerSelection: PriceRuleCustomerSelection!


  discountClass: DiscountClass!


  discountCodes(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: DiscountCodeSortKeys = ID


    query: String


    savedSearchId: ID
  ): PriceRuleDiscountCodeConnection!


  discountCodesCount: Int!


  endsAt: DateTime


  entitlementToPrerequisiteQuantityRatio: PriceRuleEntitlementToPrerequisiteQuantityRatio @deprecated(reason: "Use `prerequisiteToEntitlementQuantityRatio` instead.")


  events(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: EventSortKeys = ID


    query: String
  ): EventConnection!


  features: [PriceRuleFeature!]!


  hasTimelineComment: Boolean!


  id: ID!


  itemEntitlements: PriceRuleItemEntitlements!


  itemPrerequisites: PriceRuleLineItemPrerequisites!


  legacyResourceId: UnsignedInt64!


  oncePerCustomer: Boolean!


  prerequisiteQuantityRange: PriceRuleQuantityRange


  prerequisiteShippingPriceRange: PriceRuleMoneyRange


  prerequisiteSubtotalRange: PriceRuleMoneyRange


  prerequisiteToEntitlementQuantityRatio: PriceRulePrerequisiteToEntitlementQuantityRatio


  shareableUrls: [PriceRuleShareableUrl!]!


  shippingEntitlements: PriceRuleShippingLineEntitlements!


  startsAt: DateTime!


  status: PriceRuleStatus!


  summary: String


  target: PriceRuleTarget!


  title: String!


  totalSales: MoneyV2


  traits: [PriceRuleTrait!]! @deprecated(reason: "Use `features` instead.")


  usageCount: Int!


  usageLimit: Int


  validityPeriod: PriceRuleValidityPeriod!


  value: PriceRuleValue! @deprecated(reason: "Use `valueV2` instead.")


  valueV2: PricingValue!
}


type PriceRuleActivatePayload {

  priceRule: PriceRule


  priceRuleUserErrors: [PriceRuleUserError!]!


  userErrors: [UserError!]! @deprecated(reason: "Use `priceRuleUserErrors` instead.")
}


enum PriceRuleAllocationMethod {

  EACH


  ACROSS
}


type PriceRuleConnection {

  edges: [PriceRuleEdge!]!


  nodes: [PriceRule!]!


  pageInfo: PageInfo!
}


type PriceRuleCreatePayload {

  priceRule: PriceRule


  priceRuleDiscountCode: PriceRuleDiscountCode


  priceRuleUserErrors: [PriceRuleUserError!]!


  userErrors: [UserError!]! @deprecated(reason: "Use `priceRuleUserErrors` instead.")
}


type PriceRuleCustomerSelection {

  customers(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: CustomerSortKeys = ID


    query: String


    savedSearchId: ID
  ): CustomerConnection!


  forAllCustomers: Boolean!


  segments: [Segment!]!
}


input PriceRuleCustomerSelectionInput {

  forAllCustomers: Boolean = false


  segmentIds: [ID!]


  customerIdsToAdd: [ID!]


  customerIdsToRemove: [ID!]
}


type PriceRuleDeactivatePayload {

  priceRule: PriceRule


  priceRuleUserErrors: [PriceRuleUserError!]!


  userErrors: [UserError!]! @deprecated(reason: "Use `priceRuleUserErrors` instead.")
}


type PriceRuleDeletePayload {

  deletedPriceRuleId: ID


  priceRuleUserErrors: [PriceRuleUserError!]!


  shop: Shop!


  userErrors: [UserError!]! @deprecated(reason: "Use `priceRuleUserErrors` instead.")
}


type PriceRuleDiscountCode implements Node {

  app: App


  code: String!


  id: ID!


  usageCount: Int!
}


type PriceRuleDiscountCodeConnection {

  edges: [PriceRuleDiscountCodeEdge!]!


  nodes: [PriceRuleDiscountCode!]!


  pageInfo: PageInfo!
}


type PriceRuleDiscountCodeCreatePayload {

  priceRule: PriceRule


  priceRuleDiscountCode: PriceRuleDiscountCode


  priceRuleUserErrors: [PriceRuleUserError!]!


  userErrors: [UserError!]! @deprecated(reason: "Use `priceRuleUserErrors` instead.")
}


type PriceRuleDiscountCodeEdge {

  cursor: String!


  node: PriceRuleDiscountCode!
}


input PriceRuleDiscountCodeInput {

  code: String
}


type PriceRuleDiscountCodeUpdatePayload {

  priceRule: PriceRule


  priceRuleDiscountCode: PriceRuleDiscountCode


  priceRuleUserErrors: [PriceRuleUserError!]!


  userErrors: [UserError!]! @deprecated(reason: "Use `priceRuleUserErrors` instead.")
}


type PriceRuleEdge {

  cursor: String!


  node: PriceRule!
}


type PriceRuleEntitlementToPrerequisiteQuantityRatio {

  entitlementQuantity: Int!


  prerequisiteQuantity: Int!
}


input PriceRuleEntitlementToPrerequisiteQuantityRatioInput {

  entitlementQuantity: Int


  prerequisiteQuantity: Int
}


enum PriceRuleErrorCode {

  BLANK


  EQUAL_TO


  GREATER_THAN


  GREATER_THAN_OR_EQUAL_TO


  INVALID


  LESS_THAN


  LESS_THAN_OR_EQUAL_TO


  TAKEN


  TOO_LONG


  TOO_SHORT


  INTERNAL_ERROR


  TOO_MANY_ARGUMENTS


  MISSING_ARGUMENT


  EXCEEDED_MAX


  PRICE_RULE_ALLOCATION_LIMIT_ON_NON_BOGO


  PRICE_RULE_ALLOCATION_LIMIT_IS_ZERO


  PRICE_RULE_EXCEEDED_MAX_DISCOUNT_CODE


  SHOP_EXCEEDED_MAX_PRICE_RULES


  END_DATE_BEFORE_START_DATE


  PRICE_RULE_PERCENTAGE_VALUE_OUTSIDE_RANGE


  PREREQUISITE_SUBTOTAL_AND_QUANTITY_RANGE_BOTH_PRESENT


  ALLOCATION_METHOD_MUST_BE_ACROSS_FOR_GIVEN_TARGET_SELECTION


  APPLIES_ON_NOTHING


  MULTIPLE_RECURRING_CYCLE_LIMIT_FOR_NON_SUBSCRIPTION_ITEMS


  BOGO_INVALID_TARGET_SELECTION


  BOGO_INVALID_TARGET_TYPE


  BOGO_INVALID_VALUE_TYPE


  DISCOUNT_CODE_DUPLICATE


  BOTH_CUSTOMER_AND_SAVED_SEARCH_PREREQUISITES_SELECTED


  CUSTOMER_SAVED_SEARCH_DUPLICATE


  CUSTOMER_SAVED_SEARCH_EXCEEDED_MAX


  CUSTOMER_SAVED_SEARCH_INVALID


  CUSTOMER_PREREQUISITES_EXCEEDED_MAX


  CUSTOMER_PREREQUISITES_INVALID_SELECTION


  CUSTOMER_PREREQUISITE_DUPLICATE


  CUSTOMER_PREREQUISITES_MISSING


  BOTH_CUSTOMER_AND_SEGMENT_PREREQUISITES_SELECTED


  BOTH_SAVED_SEARCH_AND_SEGMENT_PREREQUISITES_SELECTED


  CUSTOMER_SEGMENT_EXCEEDED_MAX


  CUSTOMER_SEGMENT_INVALID


  CUSTOMER_SEGMENT_PREREQUISITE_DUPLICATE


  CANNOT_PREREQUISITE_COLLECTION_WITH_PRODUCT_OR_VARIANTS


  ITEM_PREREQUISITES_DUPLICATE_COLLECTION


  ITEM_PREREQUISITES_DUPLICATE_PRODUCT


  ITEM_PREREQUISITES_DUPLICATE_VARIANT


  ITEM_PREREQUISITES_EXCEEDED_MAX


  ITEM_PREREQUISITES_INVALID_COLLECTION


  ITEM_PREREQUISITES_INVALID_TYPE


  ITEM_PREREQUISITES_INVALID_PRODUCT


  ITEM_PREREQUISITES_INVALID_VARIANT


  ITEM_PREREQUISITES_MUST_BE_EMPTY


  ITEM_PREREQUISITES_MISSING


  CANNOT_ENTITLE_COLLECTIONS_WITH_PRODUCTS_OR_VARIANTS


  ITEM_ENTITLEMENTS_DUPLICATE_COLLECTION


  ITEM_ENTITLEMENTS_DUPLICATE_PRODUCT


  ITEM_ENTITLEMENTS_DUPLICATE_VARIANT


  ITEM_ENTITLEMENTS_EXCEEDED_MAX_COLLECTION


  ITEM_ENTITLEMENTS_EXCEEDED_MAX_PRODUCT


  ITEM_ENTITLEMENTS_EXCEEDED_MAX_VARIANT


  ITEM_ENTITLEMENT_INVALID_TYPE


  ITEM_ENTITLEMENTS_INVALID_COLLECTION


  ITEM_ENTITLEMENTS_INVALID_PRODUCT


  ITEM_ENTITLEMENTS_INVALID_VARIANT


  ITEM_ENTITLEMENTS_INVALID_TARGET_TYPE_OR_SELECTION


  ITEM_ENTITLEMENTS_MISSING


  VARIANT_ALREADY_ENTITLED_THROUGH_PRODUCT


  SHIPPING_ENTITLEMENTS_DUPLICATE_COUNTRY


  SHIPPING_ENTITLEMENTS_EXCEEDED_MAX


  SHIPPING_ENTITLEMENTS_INVALID_COUNTRY


  SHIPPING_ENTITLEMENTS_INVALID_TARGET_TYPE_OR_SELECTION


  SHIPPING_ENTITLEMENTS_MISSING


  SHIPPING_ENTITLEMENTS_UNSUPPORTED_DESTINATION_TYPE


  INVALID_TARGET_TYPE_PREREQUISITE_SHIPPING_PRICE_RANGE


  INVALID_COMBINES_WITH_FOR_DISCOUNT_CLASS


  INVALID_DISCOUNT_CLASS_FOR_PRICE_RULE
}


enum PriceRuleFeature {

  BUY_ONE_GET_ONE


  BUY_ONE_GET_ONE_WITH_ALLOCATION_LIMIT


  BULK


  SPECIFIC_CUSTOMERS


  QUANTITY_DISCOUNTS
}


type PriceRuleFixedAmountValue {

  amount: Money!
}


input PriceRuleInput {

  combinesWith: DiscountCombinesWithInput


  validityPeriod: PriceRuleValidityPeriodInput


  oncePerCustomer: Boolean = false


  customerSelection: PriceRuleCustomerSelectionInput


  usageLimit: Int


  title: String


  allocationLimit: Int


  allocationMethod: PriceRuleAllocationMethod


  value: PriceRuleValueInput


  target: PriceRuleTarget


  prerequisiteSubtotalRange: PriceRuleMoneyRangeInput


  prerequisiteQuantityRange: PriceRuleQuantityRangeInput


  prerequisiteShippingPriceRange: PriceRuleMoneyRangeInput


  itemEntitlements: PriceRuleItemEntitlementsInput


  itemPrerequisites: PriceRuleItemPrerequisitesInput


  shippingEntitlements: PriceRuleShippingEntitlementsInput


  prerequisiteToEntitlementQuantityRatio: PriceRulePrerequisiteToEntitlementQuantityRatioInput
}


type PriceRuleItemEntitlements {

  collections(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): CollectionConnection!


  productVariants(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ProductVariantConnection!


  products(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ProductConnection!


  targetAllLineItems: Boolean!
}


input PriceRuleItemEntitlementsInput {

  targetAllLineItems: Boolean = false


  productIds: [ID!]


  productVariantIds: [ID!]


  collectionIds: [ID!]
}


input PriceRuleItemPrerequisitesInput {

  productIds: [ID!]


  productVariantIds: [ID!]


  collectionIds: [ID!]
}


type PriceRuleLineItemPrerequisites {

  collections(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): CollectionConnection!


  productVariants(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ProductVariantConnection!


  products(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ProductConnection!
}


type PriceRuleMoneyRange {

  greaterThan: Money


  greaterThanOrEqualTo: Money


  lessThan: Money


  lessThanOrEqualTo: Money
}


input PriceRuleMoneyRangeInput {

  lessThan: Money


  lessThanOrEqualTo: Money


  greaterThan: Money


  greaterThanOrEqualTo: Money
}


type PriceRulePercentValue {

  percentage: Float!
}


type PriceRulePrerequisiteToEntitlementQuantityRatio {

  entitlementQuantity: Int!


  prerequisiteQuantity: Int!
}


input PriceRulePrerequisiteToEntitlementQuantityRatioInput {

  entitlementQuantity: Int


  prerequisiteQuantity: Int
}


type PriceRuleQuantityRange {

  greaterThan: Int


  greaterThanOrEqualTo: Int


  lessThan: Int


  lessThanOrEqualTo: Int
}


input PriceRuleQuantityRangeInput {

  lessThan: Int


  lessThanOrEqualTo: Int


  greaterThan: Int


  greaterThanOrEqualTo: Int
}


type PriceRuleShareableUrl {

  targetItemImage: Image


  targetType: PriceRuleShareableUrlTargetType!


  title: String!


  url: URL!
}


enum PriceRuleShareableUrlTargetType {

  HOME


  PRODUCT


  COLLECTION
}


input PriceRuleShippingEntitlementsInput {

  targetAllShippingLines: Boolean = false


  countryCodes: [CountryCode!]


  includeRestOfWorld: Boolean = false
}


type PriceRuleShippingLineEntitlements {

  countryCodes: [CountryCode!]!


  includeRestOfWorld: Boolean!


  targetAllShippingLines: Boolean!
}


enum PriceRuleSortKeys {

  STARTS_AT


  ENDS_AT


  TITLE


  CREATED_AT


  UPDATED_AT


  ID


  RELEVANCE
}


enum PriceRuleStatus {

  ACTIVE


  EXPIRED


  SCHEDULED
}


enum PriceRuleTarget {

  LINE_ITEM


  SHIPPING_LINE
}


enum PriceRuleTrait {

  BUY_ONE_GET_ONE


  BUY_ONE_GET_ONE_WITH_ALLOCATION_LIMIT


  BULK


  SPECIFIC_CUSTOMERS


  QUANTITY_DISCOUNTS
}


type PriceRuleUpdatePayload {

  priceRule: PriceRule


  priceRuleDiscountCode: PriceRuleDiscountCode


  priceRuleUserErrors: [PriceRuleUserError!]!


  userErrors: [UserError!]! @deprecated(reason: "Use `priceRuleUserErrors` instead.")
}


type PriceRuleUserError implements DisplayableError {

  code: PriceRuleErrorCode


  field: [String!]


  message: String!
}


type PriceRuleValidityPeriod {

  end: DateTime


  start: DateTime!
}


input PriceRuleValidityPeriodInput {

  start: DateTime!


  end: DateTime
}


union PriceRuleValue = PriceRuleFixedAmountValue | PriceRulePercentValue


input PriceRuleValueInput {

  percentageValue: Float


  fixedAmountValue: Money
}


type PricingPercentageValue {

  percentage: Float!
}


union PricingValue = MoneyV2 | PricingPercentageValue


type PrivateMetafield implements Node {

  createdAt: DateTime!


  id: ID!


  key: String!


  namespace: String!


  updatedAt: DateTime!


  value: String!


  valueType: PrivateMetafieldValueType!
}


type PrivateMetafieldConnection {

  edges: [PrivateMetafieldEdge!]!


  nodes: [PrivateMetafield!]!


  pageInfo: PageInfo!
}


input PrivateMetafieldDeleteInput {

  owner: ID


  namespace: String!


  key: String!
}


type PrivateMetafieldDeletePayload {

  deletedPrivateMetafieldId: ID


  userErrors: [UserError!]!
}


type PrivateMetafieldEdge {

  cursor: String!


  node: PrivateMetafield!
}


input PrivateMetafieldInput {

  owner: ID


  namespace: String!


  key: String!


  valueInput: PrivateMetafieldValueInput!
}


type PrivateMetafieldUpsertPayload {

  privateMetafield: PrivateMetafield


  userErrors: [UserError!]!
}


input PrivateMetafieldValueInput {

  value: String!


  valueType: PrivateMetafieldValueType!
}


enum PrivateMetafieldValueType {

  STRING


  INTEGER


  JSON_STRING
}


type Product implements HasMetafieldDefinitions & HasMetafields & HasPublishedTranslations & LegacyInteroperability & Navigable & Node & OnlineStorePreviewable & Publishable {

  availablePublicationCount: Int!


  bodyHtml: String @deprecated(reason: "Use `descriptionHtml` instead.")


  collections(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: CollectionSortKeys = ID


    query: String
  ): CollectionConnection!


  compareAtPriceRange: ProductCompareAtPriceRange


  contextualPricing(

    context: ContextualPricingContext!
  ): ProductContextualPricing!


  createdAt: DateTime!


  customProductType: String @deprecated(reason: "Deprecated in API version 2022-10. Use `productType` instead.")


  defaultCursor: String!


  description(

    truncateAt: Int
  ): String!


  descriptionHtml: HTML!


  descriptionPlainSummary: String! @deprecated(reason: "Use `description` instead.")


  featuredImage: Image


  featuredMedia: Media


  feedback: ResourceFeedback


  giftCardTemplateSuffix: String


  handle: String!


  hasOnlyDefaultVariant: Boolean!


  hasOutOfStockVariants: Boolean!


  hasVariantsThatRequiresComponents: Boolean!


  id: ID!


  images(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: ProductImageSortKeys = POSITION
  ): ImageConnection!


  inCollection(

    id: ID!
  ): Boolean!


  isGiftCard: Boolean!


  legacyResourceId: UnsignedInt64!


  media(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: ProductMediaSortKeys = POSITION
  ): MediaConnection!


  mediaCount: Int!


  metafield(

    namespace: String


    key: String!
  ): Metafield


  metafieldDefinitions(

    namespace: String


    pinnedStatus: MetafieldDefinitionPinnedStatus = ANY


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: MetafieldDefinitionSortKeys = ID


    query: String
  ): MetafieldDefinitionConnection!


  metafields(

    namespace: String


    keys: [String!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  onlineStorePreviewUrl: URL


  onlineStoreUrl: URL


  options(

    first: Int
  ): [ProductOption!]!


  priceRange: ProductPriceRange! @deprecated(reason: "Deprecated in API version 2020-10. Use `priceRangeV2` instead.")


  priceRangeV2: ProductPriceRangeV2!


  privateMetafield(

    namespace: String!


    key: String!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  productCategory: ProductCategory @deprecated(reason: "Deprecated in API version 2024-04. Use `category` instead.")


  productPublications(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ProductPublicationConnection! @deprecated(reason: "Use `resourcePublications` instead.")


  productType: String!


  publicationCount(

    onlyPublished: Boolean = true
  ): Int!


  publications(

    onlyPublished: Boolean = true


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ProductPublicationConnection! @deprecated(reason: "Use `resourcePublications` instead.")


  publishedAt: DateTime


  publishedInContext(

    context: ContextualPublicationContext!
  ): Boolean!


  publishedOnChannel(

    channelId: ID!
  ): Boolean! @deprecated(reason: "Use `publishedOnPublication` instead.")


  publishedOnCurrentChannel: Boolean! @deprecated(reason: "Use `publishedOnCurrentPublication` instead.")


  publishedOnCurrentPublication: Boolean!


  publishedOnPublication(

    publicationId: ID!
  ): Boolean!


  requiresSellingPlan: Boolean!


  resourcePublicationOnCurrentPublication: ResourcePublicationV2


  resourcePublications(

    onlyPublished: Boolean = true


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ResourcePublicationConnection!


  resourcePublicationsV2(

    onlyPublished: Boolean = true


    catalogType: CatalogType


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ResourcePublicationV2Connection!


  sellingPlanGroupCount: Int!


  sellingPlanGroups(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SellingPlanGroupConnection!


  seo: SEO!


  standardizedProductType: StandardizedProductType @deprecated(reason: "Deprecated in API version 2022-10. Use `productCategory` instead.")


  status: ProductStatus!


  storefrontId: StorefrontID! @deprecated(reason: "Use `id` instead.")


  tags: [String!]!


  templateSuffix: String


  title: String!


  totalInventory: Int!


  totalVariants: Int!


  tracksInventory: Boolean!


  translations(

    locale: String!


    marketId: ID
  ): [Translation!]!


  unpublishedChannels(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ChannelConnection! @deprecated(reason: "Use `unpublishedPublications` instead.")


  unpublishedPublications(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PublicationConnection!


  updatedAt: DateTime!


  variants(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: ProductVariantSortKeys = POSITION
  ): ProductVariantConnection!


  vendor: String!
}


input ProductAppendImagesInput {

  id: ID!


  images: [ImageInput!]!
}


type ProductAppendImagesPayload {

  newImages: [Image!]


  product: Product


  userErrors: [UserError!]!
}


type ProductCategory {

  productTaxonomyNode: ProductTaxonomyNode
}


input ProductCategoryInput {

  productTaxonomyNodeId: ID!
}


type ProductChangeStatusPayload {

  product: Product


  userErrors: [ProductChangeStatusUserError!]!
}


type ProductChangeStatusUserError implements DisplayableError {

  code: ProductChangeStatusUserErrorCode


  field: [String!]


  message: String!
}


enum ProductChangeStatusUserErrorCode {

  PRODUCT_NOT_FOUND
}


input ProductClaimOwnershipInput {

  bundles: Boolean
}


enum ProductCollectionSortKeys {

  TITLE


  PRICE


  BEST_SELLING


  CREATED


  ID


  MANUAL


  COLLECTION_DEFAULT


  RELEVANCE
}


type ProductCompareAtPriceRange {

  maxVariantCompareAtPrice: MoneyV2!


  minVariantCompareAtPrice: MoneyV2!
}


type ProductConnection {

  edges: [ProductEdge!]!


  nodes: [Product!]!


  pageInfo: PageInfo!
}


type ProductContextualPricing {

  fixedQuantityRulesCount: Int!


  maxVariantPricing: ProductVariantContextualPricing


  minVariantPricing: ProductVariantContextualPricing


  priceRange: ProductPriceRangeV2!
}


type ProductCreateMediaPayload {

  media: [Media!]


  mediaUserErrors: [MediaUserError!]!


  product: Product


  userErrors: [UserError!]! @deprecated(reason: "Use `mediaUserErrors` instead.")
}


type ProductCreatePayload {

  product: Product


  shop: Shop!


  userErrors: [UserError!]!
}


type ProductDeleteAsyncPayload {

  deleteProductId: ID


  job: Job


  userErrors: [ProductDeleteUserError!]!
}


type ProductDeleteImagesPayload {

  deletedImageIds: [ID!]!


  product: Product


  userErrors: [UserError!]!
}


input ProductDeleteInput {

  id: ID!
}


type ProductDeleteMediaPayload {

  deletedMediaIds: [ID!]


  deletedProductImageIds: [ID!]


  mediaUserErrors: [MediaUserError!]!


  product: Product


  userErrors: [UserError!]! @deprecated(reason: "Use `mediaUserErrors` instead.")
}


type ProductDeletePayload {

  deletedProductId: ID


  shop: Shop!


  userErrors: [UserError!]!
}


type ProductDeleteUserError implements DisplayableError {

  code: ProductDeleteUserErrorCode


  field: [String!]


  message: String!
}


enum ProductDeleteUserErrorCode {

  PRODUCT_DOES_NOT_EXIST


  GENERIC_ERROR
}


input ProductDuplicateAsyncInput {

  productId: ID!


  newTitle: String!


  newStatus: ProductStatus


  includeImages: Boolean = false
}


type ProductDuplicateAsyncPayload {

  duplicatedProductId: ID


  job: Job


  userErrors: [ProductDuplicateUserError!]!
}


type ProductDuplicateAsyncV2Payload {

  duplicatedProductId: ID


  productDuplicateJobId: ID


  userErrors: [ProductDuplicateUserError!]!
}


type ProductDuplicateJob {

  done: Boolean!


  id: ID!
}


type ProductDuplicatePayload {

  imageJob: Job


  newProduct: Product


  shop: Shop!


  userErrors: [UserError!]!
}


type ProductDuplicateUserError implements DisplayableError {

  code: ProductDuplicateUserErrorCode


  field: [String!]


  message: String!
}


enum ProductDuplicateUserErrorCode {

  PRODUCT_DOES_NOT_EXIST


  EMPTY_VARIANT


  EMPTY_TITLE


  BUNDLES_ERROR


  GENERIC_ERROR


  FAILED_TO_SAVE
}


type ProductEdge {

  cursor: String!


  node: Product!
}


type ProductFeed implements Node {

  country: CountryCode


  id: ID!


  language: LanguageCode


  status: ProductFeedStatus!
}


type ProductFeedConnection {

  edges: [ProductFeedEdge!]!


  nodes: [ProductFeed!]!


  pageInfo: PageInfo!
}


type ProductFeedCreatePayload {

  productFeed: ProductFeed


  userErrors: [ProductFeedCreateUserError!]!
}


type ProductFeedCreateUserError implements DisplayableError {

  code: ProductFeedCreateUserErrorCode


  field: [String!]


  message: String!
}


enum ProductFeedCreateUserErrorCode {

  INVALID


  TAKEN
}


type ProductFeedDeletePayload {

  deletedId: ID


  userErrors: [ProductFeedDeleteUserError!]!
}


type ProductFeedDeleteUserError implements DisplayableError {

  code: ProductFeedDeleteUserErrorCode


  field: [String!]


  message: String!
}


enum ProductFeedDeleteUserErrorCode {

  INVALID
}


type ProductFeedEdge {

  cursor: String!


  node: ProductFeed!
}


input ProductFeedInput {

  language: LanguageCode!


  country: CountryCode!
}


enum ProductFeedStatus {

  ACTIVE


  INACTIVE
}


type ProductFullSyncPayload {

  userErrors: [ProductFullSyncUserError!]!
}


type ProductFullSyncUserError implements DisplayableError {

  code: ProductFullSyncUserErrorCode


  field: [String!]


  message: String!
}


enum ProductFullSyncUserErrorCode {

  INVALID
}


enum ProductImageSortKeys {

  CREATED_AT


  POSITION


  ID


  RELEVANCE
}


type ProductImageUpdatePayload {

  image: Image


  userErrors: [UserError!]!
}


input ProductInput {

  descriptionHtml: String


  handle: String


  redirectNewHandle: Boolean


  seo: SEOInput


  productType: String


  customProductType: String


  tags: [String!]


  templateSuffix: String


  giftCard: Boolean


  giftCardTemplateSuffix: String


  title: String


  vendor: String


  collectionsToJoin: [ID!]


  collectionsToLeave: [ID!]


  id: ID


  metafields: [MetafieldInput!]


  status: ProductStatus


  requiresSellingPlan: Boolean


  claimOwnership: ProductClaimOwnershipInput
}


type ProductJoinSellingPlanGroupsPayload {

  product: Product


  userErrors: [SellingPlanGroupUserError!]!
}


type ProductLeaveSellingPlanGroupsPayload {

  product: Product


  userErrors: [SellingPlanGroupUserError!]!
}


enum ProductMediaSortKeys {

  POSITION


  ID


  RELEVANCE
}


type ProductOption implements HasPublishedTranslations & Node {

  id: ID!


  name: String!


  position: Int!


  translations(

    locale: String!


    marketId: ID
  ): [Translation!]!


  values: [String!]!
}


type ProductPriceRange {

  maxVariantPrice: MoneyV2!


  minVariantPrice: MoneyV2!
}


type ProductPriceRangeV2 {

  maxVariantPrice: MoneyV2!


  minVariantPrice: MoneyV2!
}


type ProductPublication {

  channel: Channel!


  isPublished: Boolean!


  product: Product!


  publishDate: DateTime
}


type ProductPublicationConnection {

  edges: [ProductPublicationEdge!]!


  nodes: [ProductPublication!]!


  pageInfo: PageInfo!
}


type ProductPublicationEdge {

  cursor: String!


  node: ProductPublication!
}


input ProductPublicationInput {

  publicationId: ID


  publishDate: DateTime
}


input ProductPublishInput {

  id: ID!


  productPublications: [ProductPublicationInput!]!
}


type ProductPublishPayload {

  product: Product


  productPublications: [ProductPublication!] @deprecated(reason: "Use Product.publications instead.")


  shop: Shop!


  userErrors: [UserError!]!
}


type ProductReorderImagesPayload {

  job: Job


  userErrors: [UserError!]!
}


type ProductReorderMediaPayload {

  job: Job


  mediaUserErrors: [MediaUserError!]!


  userErrors: [UserError!]! @deprecated(reason: "Use `mediaUserErrors` instead.")
}


type ProductResourceFeedback {

  feedbackGeneratedAt: DateTime!


  messages: [String!]!


  productId: ID!


  productUpdatedAt: DateTime!


  state: ResourceFeedbackState!
}


input ProductResourceFeedbackInput {

  productId: ID!


  state: ResourceFeedbackState!


  feedbackGeneratedAt: DateTime!


  productUpdatedAt: DateTime!


  messages: [String!]
}


type ProductSale implements Sale {

  actionType: SaleActionType!


  id: ID!


  lineItem: LineItem!


  lineType: SaleLineType!


  quantity: Int


  taxes: [SaleTax!]!


  totalAmount: MoneyBag!


  totalDiscountAmountAfterTaxes: MoneyBag!


  totalDiscountAmountBeforeTaxes: MoneyBag!


  totalTaxAmount: MoneyBag!
}


enum ProductSortKeys {

  TITLE


  PRODUCT_TYPE


  VENDOR


  INVENTORY_TOTAL


  UPDATED_AT


  CREATED_AT


  PUBLISHED_AT


  ID


  RELEVANCE
}


enum ProductStatus {

  ACTIVE


  ARCHIVED


  DRAFT
}


type ProductTaxonomyNode implements Node {

  fullName: String!


  id: ID!


  isLeaf: Boolean!


  isRoot: Boolean!


  name: String!
}


input ProductUnpublishInput {

  id: ID!


  productPublications: [ProductPublicationInput!]!
}


type ProductUnpublishPayload {

  product: Product


  shop: Shop!


  userErrors: [UserError!]!
}


type ProductUpdateMediaPayload {

  media: [Media!]


  mediaUserErrors: [MediaUserError!]!


  product: Product


  userErrors: [UserError!]! @deprecated(reason: "Use `mediaUserErrors` instead.")
}


type ProductUpdatePayload {

  product: Product


  userErrors: [UserError!]!
}


type ProductVariant implements HasMetafieldDefinitions & HasMetafields & HasPublishedTranslations & LegacyInteroperability & Navigable & Node {

  availableForSale: Boolean!


  barcode: String


  compareAtPrice: Money


  contextualPricing(

    context: ContextualPricingContext!
  ): ProductVariantContextualPricing!


  createdAt: DateTime!


  defaultCursor: String!


  deliveryProfile: DeliveryProfile


  displayName: String!


  fulfillmentService: FulfillmentService @deprecated(reason: "\nThe [relationship between a product variant and a fulfillment service was changed in the `2022-07` API version](/changelog/fulfillment-service-sku-sharing). A [ProductVariant](/api/admin-graphql/latest/objects/ProductVariant) can be stocked by multiple fulfillment services. As a result, we recommend that you use the [inventoryItem field](/api/admin-graphql/latest/objects/ProductVariant#field-productvariant-inventoryitem) if you need to determine where a product variant is stocked.\n\nIf you need to determine whether a product is a gift card, then you should continue to use this field until an alternative is available.\n\nLearn more about [managing inventory quantities and states](/apps/fulfillment/inventory-management-apps/quantities-states).\n")


  fulfillmentServiceEditable: EditableProperty! @deprecated(reason: "The [relationship between a product variant and a fulfillment service was changed in the `2022-07` API version](/changelog/fulfillment-service-sku-sharing). A [ProductVariant](/api/admin-graphql/latest/objects/ProductVariant) can be stocked by multiple fulfillment services. \nAs a result, the fulfillment_service is no longer directly editable on a ProductVariant and this field is no longer applicable.\n")


  harmonizedSystemCode: String @deprecated(reason: "Use `InventoryItem.harmonizedSystemCode` instead.")


  id: ID!


  image: Image


  inventoryItem: InventoryItem!


  inventoryManagement: ProductVariantInventoryManagement! @deprecated(reason: "Use tracked attribute on `inventoryItem` instead.")


  inventoryPolicy: ProductVariantInventoryPolicy!


  inventoryQuantity: Int


  legacyResourceId: UnsignedInt64!


  media(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MediaConnection!


  metafield(

    namespace: String


    key: String!
  ): Metafield


  metafieldDefinitions(

    namespace: String


    pinnedStatus: MetafieldDefinitionPinnedStatus = ANY


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: MetafieldDefinitionSortKeys = ID


    query: String
  ): MetafieldDefinitionConnection!


  metafields(

    namespace: String


    keys: [String!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  position: Int!


  presentmentPrices(

    presentmentCurrencies: [CurrencyCode!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ProductVariantPricePairConnection! @deprecated(reason: "Use `contextualPricing` instead.")


  price: Money!


  privateMetafield(

    namespace: String!


    key: String!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  product: Product!


  productVariantComponents(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ProductVariantComponentConnection!


  requiresComponents: Boolean!


  requiresShipping: Boolean! @deprecated(reason: "Use `InventoryItem.requiresShipping` instead.")


  selectedOptions: [SelectedOption!]!


  sellableOnlineQuantity: Int!


  sellingPlanGroupCount: Int!


  sellingPlanGroups(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SellingPlanGroupConnection!


  sku: String


  storefrontId: StorefrontID! @deprecated(reason: "Use `id` instead.")


  taxCode: String


  taxable: Boolean!


  title: String!


  translations(

    locale: String!


    marketId: ID
  ): [Translation!]!


  updatedAt: DateTime!


  weight: Float @deprecated(reason: "Use InventoryItem.measurement.weight instead")


  weightUnit: WeightUnit! @deprecated(reason: "Use InventoryItem.measurement.weight instead")
}


input ProductVariantAppendMediaInput {

  variantId: ID!


  mediaIds: [ID!]!
}


type ProductVariantAppendMediaPayload {

  product: Product


  productVariants: [ProductVariant!]


  userErrors: [MediaUserError!]!
}


type ProductVariantComponent implements Node {

  id: ID!


  productVariant: ProductVariant!


  quantity: Int!
}


type ProductVariantComponentConnection {

  edges: [ProductVariantComponentEdge!]!


  nodes: [ProductVariantComponent!]!


  pageInfo: PageInfo!
}


type ProductVariantComponentEdge {

  cursor: String!


  node: ProductVariantComponent!
}


type ProductVariantConnection {

  edges: [ProductVariantEdge!]!


  nodes: [ProductVariant!]!


  pageInfo: PageInfo!
}


type ProductVariantContextualPricing {

  compareAtPrice: MoneyV2


  price: MoneyV2!


  quantityPriceBreaks(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: QuantityPriceBreakSortKeys = MINIMUM_QUANTITY
  ): QuantityPriceBreakConnection!


  quantityRule: QuantityRule!
}


type ProductVariantCreatePayload {

  product: Product


  productVariant: ProductVariant


  userErrors: [UserError!]!
}


type ProductVariantDeletePayload {

  deletedProductVariantId: ID


  product: Product


  userErrors: [UserError!]!
}


input ProductVariantDetachMediaInput {

  variantId: ID!


  mediaIds: [ID!]!
}


type ProductVariantDetachMediaPayload {

  product: Product


  productVariants: [ProductVariant!]


  userErrors: [MediaUserError!]!
}


type ProductVariantEdge {

  cursor: String!


  node: ProductVariant!
}


input ProductVariantGroupRelationshipInput {

  id: ID!


  quantity: Int!
}


input ProductVariantInput {

  requiresComponents: Boolean


  barcode: String


  compareAtPrice: Money


  id: ID


  mediaId: ID


  mediaSrc: [String!]


  inventoryPolicy: ProductVariantInventoryPolicy


  inventoryQuantities: [InventoryLevelInput!]


  inventoryItem: InventoryItemInput


  metafields: [MetafieldInput!]


  options: [String!]


  position: Int


  price: Money


  productId: ID


  sku: String


  taxable: Boolean


  taxCode: String
}


enum ProductVariantInventoryManagement {

  SHOPIFY


  NOT_MANAGED


  FULFILLMENT_SERVICE
}


enum ProductVariantInventoryPolicy {

  DENY


  CONTINUE
}


type ProductVariantJoinSellingPlanGroupsPayload {

  productVariant: ProductVariant


  userErrors: [SellingPlanGroupUserError!]!
}


type ProductVariantLeaveSellingPlanGroupsPayload {

  productVariant: ProductVariant


  userErrors: [SellingPlanGroupUserError!]!
}


input ProductVariantPositionInput {

  id: ID!


  position: Int!
}


type ProductVariantPricePair {

  compareAtPrice: MoneyV2


  price: MoneyV2!
}


type ProductVariantPricePairConnection {

  edges: [ProductVariantPricePairEdge!]!


  nodes: [ProductVariantPricePair!]!


  pageInfo: PageInfo!
}


type ProductVariantPricePairEdge {

  cursor: String!


  node: ProductVariantPricePair!
}


type ProductVariantRelationshipBulkUpdatePayload {

  parentProductVariants: [ProductVariant!]


  userErrors: [ProductVariantRelationshipBulkUpdateUserError!]!
}


type ProductVariantRelationshipBulkUpdateUserError implements DisplayableError {

  code: ProductVariantRelationshipBulkUpdateUserErrorCode


  field: [String!]


  message: String!
}


enum ProductVariantRelationshipBulkUpdateUserErrorCode {

  PARENT_REQUIRED


  FAILED_TO_CREATE


  PRODUCT_VARIANTS_NOT_FOUND


  CIRCULAR_REFERENCE


  NESTED_PARENT_PRODUCT_VARIANT


  INVALID_QUANTITY


  DUPLICATE_PRODUCT_VARIANT_RELATIONSHIP


  EXCEEDED_PRODUCT_VARIANT_RELATIONSHIP_LIMIT


  PRODUCT_VARIANT_RELATIONSHIP_TYPE_CONFLICT


  UNEXPECTED_ERROR


  FAILED_TO_REMOVE


  MUST_SPECIFY_COMPONENTS


  FAILED_TO_UPDATE


  FAILED_TO_UPDATE_PARENT_PRODUCT_VARIANT_PRICE


  UPDATE_PARENT_VARIANT_PRICE_REQUIRED


  PRODUCT_VARIANTS_NOT_COMPONENTS


  PRODUCT_EXPANDER_APP_OWNERSHIP_ALREADY_EXISTS


  UNSUPPORTED_MULTIPACK_RELATIONSHIP


  PARENT_PRODUCT_VARIANT_CANNOT_BE_GIFT_CARD


  PARENT_PRODUCT_VARIANT_CANNOT_REQUIRE_SELLING_PLAN
}


input ProductVariantRelationshipUpdateInput {

  parentProductVariantId: ID


  parentProductId: ID


  productVariantRelationshipsToCreate: [ProductVariantGroupRelationshipInput!]


  productVariantRelationshipsToUpdate: [ProductVariantGroupRelationshipInput!]


  productVariantRelationshipsToRemove: [ID!]


  removeAllProductVariantRelationships: Boolean = false


  priceInput: PriceInput
}


type ProductVariantsBulkCreatePayload {

  product: Product


  productVariants: [ProductVariant!]


  userErrors: [ProductVariantsBulkCreateUserError!]!
}


type ProductVariantsBulkCreateUserError implements DisplayableError {

  code: ProductVariantsBulkCreateUserErrorCode


  field: [String!]


  message: String!
}


enum ProductVariantsBulkCreateUserErrorCode {

  PRODUCT_DOES_NOT_EXIST


  NO_KEY_ON_CREATE


  VARIANT_ALREADY_EXISTS


  GREATER_THAN_OR_EQUAL_TO


  NEED_TO_ADD_OPTION_VALUES


  OPTION_VALUES_FOR_NUMBER_OF_UNKNOWN_OPTIONS


  TOO_MANY_INVENTORY_LOCATIONS


  SUBSCRIPTION_VIOLATION


  VARIANT_ALREADY_EXISTS_CHANGE_OPTION_VALUE


  TRACKED_VARIANT_LOCATION_NOT_FOUND


  MUST_BE_FOR_THIS_PRODUCT


  NOT_DEFINED_FOR_SHOP


  INVALID


  NEGATIVE_PRICE_VALUE
}


type ProductVariantsBulkDeletePayload {

  product: Product


  userErrors: [ProductVariantsBulkDeleteUserError!]!
}


type ProductVariantsBulkDeleteUserError implements DisplayableError {

  code: ProductVariantsBulkDeleteUserErrorCode


  field: [String!]


  message: String!
}


enum ProductVariantsBulkDeleteUserErrorCode {

  PRODUCT_DOES_NOT_EXIST


  CANNOT_DELETE_LAST_VARIANT


  AT_LEAST_ONE_VARIANT_DOES_NOT_BELONG_TO_THE_PRODUCT
}


input ProductVariantsBulkInput {

  barcode: String


  compareAtPrice: Money


  id: ID


  mediaSrc: [String!]


  inventoryPolicy: ProductVariantInventoryPolicy


  inventoryQuantities: [InventoryLevelInput!]


  inventoryItem: InventoryItemInput


  mediaId: ID


  metafields: [MetafieldInput!]


  price: Money


  sku: String


  taxable: Boolean


  taxCode: String
}


type ProductVariantsBulkReorderPayload {

  product: Product


  userErrors: [ProductVariantsBulkReorderUserError!]!
}


type ProductVariantsBulkReorderUserError implements DisplayableError {

  code: ProductVariantsBulkReorderUserErrorCode


  field: [String!]


  message: String!
}


enum ProductVariantsBulkReorderUserErrorCode {

  PRODUCT_DOES_NOT_EXIST


  MISSING_VARIANT


  INVALID_POSITION


  DUPLICATED_VARIANT_ID
}


type ProductVariantsBulkUpdatePayload {

  product: Product


  productVariants: [ProductVariant!]


  userErrors: [ProductVariantsBulkUpdateUserError!]!
}


type ProductVariantsBulkUpdateUserError implements DisplayableError {

  code: ProductVariantsBulkUpdateUserErrorCode


  field: [String!]


  message: String!
}


enum ProductVariantsBulkUpdateUserErrorCode {

  PRODUCT_DOES_NOT_EXIST


  PRODUCT_VARIANT_ID_MISSING


  PRODUCT_VARIANT_DOES_NOT_EXIST


  NO_INVENTORY_QUANTITIES_ON_VARIANTS_UPDATE


  VARIANT_ALREADY_EXISTS


  GREATER_THAN_OR_EQUAL_TO


  NEED_TO_ADD_OPTION_VALUES


  OPTION_VALUES_FOR_NUMBER_OF_UNKNOWN_OPTIONS


  SUBSCRIPTION_VIOLATION


  NO_INVENTORY_QUANTITES_DURING_UPDATE


  NEGATIVE_PRICE_VALUE
}


enum ProductVariantSortKeys {

  TITLE


  NAME


  SKU


  INVENTORY_QUANTITY


  INVENTORY_MANAGEMENT


  INVENTORY_LEVELS_AVAILABLE


  INVENTORY_POLICY


  FULL_TITLE


  POPULAR


  POSITION


  ID


  RELEVANCE
}


type ProductVariantUpdatePayload {

  product: Product


  productVariant: ProductVariant


  userErrors: [UserError!]!
}


enum ProfileItemSortKeys {

  TITLE


  PRODUCT_TYPE


  VENDOR


  INVENTORY_TOTAL


  UPDATED_AT


  CREATED_AT


  PUBLISHED_AT


  ID


  RELEVANCE
}


type Publication implements Node {

  app: App! @deprecated(reason: "Use [AppCatalog.apps](https://shopify.dev/api/admin-graphql/unstable/objects/AppCatalog#connection-appcatalog-apps) instead.")


  autoPublish: Boolean!


  catalog: Catalog


  collectionPublicationsV3(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ResourcePublicationConnection!


  collections(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): CollectionConnection!


  hasCollection(

    id: ID!
  ): Boolean!


  id: ID!


  name: String! @deprecated(reason: "Use [Catalog.title](https://shopify.dev/api/admin-graphql/unstable/interfaces/Catalog#field-catalog-title) instead.")


  operation: PublicationOperation


  productPublicationsV3(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ResourcePublicationConnection!


  products(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ProductConnection!


  supportsFuturePublishing: Boolean!
}


type PublicationConnection {

  edges: [PublicationEdge!]!


  nodes: [Publication!]!


  pageInfo: PageInfo!
}


input PublicationCreateInput {

  catalogId: ID


  defaultState: PublicationCreateInputPublicationDefaultState = EMPTY


  autoPublish: Boolean = false
}


enum PublicationCreateInputPublicationDefaultState {

  EMPTY


  ALL_PRODUCTS
}


type PublicationCreatePayload {

  publication: Publication


  userErrors: [PublicationUserError!]!
}


type PublicationDeletePayload {

  deletedId: ID


  userErrors: [PublicationUserError!]!
}


type PublicationEdge {

  cursor: String!


  node: Publication!
}


input PublicationInput {

  publicationId: ID


  publishDate: DateTime
}


union PublicationOperation = AddAllProductsOperation | CatalogCsvOperation | PublicationResourceOperation


type PublicationResourceOperation implements Node & ResourceOperation {

  id: ID!


  processedRowCount: Int


  rowCount: RowCount


  status: ResourceOperationStatus!
}


input PublicationUpdateInput {

  publishablesToAdd: [ID!] = []


  publishablesToRemove: [ID!] = []


  autoPublish: Boolean
}


type PublicationUpdatePayload {

  publication: Publication


  userErrors: [PublicationUserError!]!
}


type PublicationUserError implements DisplayableError {

  code: PublicationUserErrorCode


  field: [String!]


  message: String!
}


enum PublicationUserErrorCode {

  UNSUPPORTED_PUBLICATION_ACTION


  PUBLICATION_NOT_FOUND


  PUBLICATION_LOCKED


  UNSUPPORTED_PUBLISHABLE_TYPE


  INVALID_PUBLISHABLE_ID


  MARKET_NOT_FOUND


  CATALOG_NOT_FOUND


  CANNOT_MODIFY_APP_CATALOG_PUBLICATION


  CANNOT_MODIFY_MARKET_CATALOG_PUBLICATION


  CANNOT_MODIFY_APP_CATALOG


  CANNOT_MODIFY_MARKET_CATALOG


  INVALID


  TAKEN


  TOO_LONG


  TOO_SHORT


  BLANK


  PRODUCT_TYPE_INCOMPATIBLE_WITH_CATALOG_TYPE


  PUBLICATION_UPDATE_LIMIT_EXCEEDED
}


interface Publishable {

  availablePublicationCount: Int!


  publicationCount(

    onlyPublished: Boolean = true
  ): Int!


  publishedOnChannel(

    channelId: ID!
  ): Boolean! @deprecated(reason: "Use `publishedOnPublication` instead.")


  publishedOnCurrentChannel: Boolean! @deprecated(reason: "Use `publishedOnCurrentPublication` instead.")


  publishedOnCurrentPublication: Boolean!


  publishedOnPublication(

    publicationId: ID!
  ): Boolean!


  resourcePublications(

    onlyPublished: Boolean = true


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ResourcePublicationConnection!


  resourcePublicationsV2(

    onlyPublished: Boolean = true


    catalogType: CatalogType


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ResourcePublicationV2Connection!


  unpublishedChannels(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ChannelConnection! @deprecated(reason: "Use `unpublishedPublications` instead.")


  unpublishedPublications(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PublicationConnection!
}


type PublishablePublishPayload {

  publishable: Publishable


  shop: Shop!


  userErrors: [UserError!]!
}


type PublishablePublishToCurrentChannelPayload {

  publishable: Publishable


  shop: Shop!


  userErrors: [UserError!]!
}


type PublishableUnpublishPayload {

  publishable: Publishable


  shop: Shop!


  userErrors: [UserError!]!
}


type PublishableUnpublishToCurrentChannelPayload {

  publishable: Publishable


  shop: Shop!


  userErrors: [UserError!]!
}


type PubSubServerPixelUpdatePayload {

  serverPixel: ServerPixel


  userErrors: [ErrorsServerPixelUserError!]!
}


type PubSubWebhookSubscriptionCreatePayload {

  userErrors: [PubSubWebhookSubscriptionCreateUserError!]!


  webhookSubscription: WebhookSubscription
}


type PubSubWebhookSubscriptionCreateUserError implements DisplayableError {

  code: PubSubWebhookSubscriptionCreateUserErrorCode


  field: [String!]


  message: String!
}


enum PubSubWebhookSubscriptionCreateUserErrorCode {

  INVALID_PARAMETERS
}


input PubSubWebhookSubscriptionInput {

  pubSubProject: String!


  pubSubTopic: String!


  format: WebhookSubscriptionFormat


  includeFields: [String!]


  metafieldNamespaces: [String!]
}


type PubSubWebhookSubscriptionUpdatePayload {

  userErrors: [PubSubWebhookSubscriptionUpdateUserError!]!


  webhookSubscription: WebhookSubscription
}


type PubSubWebhookSubscriptionUpdateUserError implements DisplayableError {

  code: PubSubWebhookSubscriptionUpdateUserErrorCode


  field: [String!]


  message: String!
}


enum PubSubWebhookSubscriptionUpdateUserErrorCode {

  INVALID_PARAMETERS
}


type PurchasingCompany {

  company: Company!


  contact: CompanyContact


  location: CompanyLocation!
}


input PurchasingCompanyInput {

  companyId: ID!


  companyContactId: ID!


  companyLocationId: ID!
}


union PurchasingEntity = Customer | PurchasingCompany


input PurchasingEntityInput {

  customerId: ID


  purchasingCompany: PurchasingCompanyInput
}


type QuantityPriceBreak implements Node {

  id: ID!


  minimumQuantity: Int!


  price: MoneyV2!


  priceList: PriceList!


  variant: ProductVariant!
}


type QuantityPriceBreakConnection {

  edges: [QuantityPriceBreakEdge!]!


  nodes: [QuantityPriceBreak!]!


  pageInfo: PageInfo!
}


type QuantityPriceBreakEdge {

  cursor: String!


  node: QuantityPriceBreak!
}


input QuantityPriceBreakInput {

  variantId: ID!


  price: MoneyInput!


  minimumQuantity: Int!
}


enum QuantityPriceBreakSortKeys {

  MINIMUM_QUANTITY


  ID


  RELEVANCE
}


input QuantityPricingByVariantUpdateInput {

  quantityPriceBreaksToAdd: [QuantityPriceBreakInput!]!


  quantityPriceBreaksToDelete: [ID!]!


  quantityRulesToAdd: [QuantityRuleInput!]!


  quantityRulesToDeleteByVariantId: [ID!]!


  pricesToAdd: [PriceListPriceInput!]!


  pricesToDeleteByVariantId: [ID!]!
}


type QuantityPricingByVariantUpdatePayload {

  productVariants: [ProductVariant!]


  userErrors: [QuantityPricingByVariantUserError!]!
}


type QuantityPricingByVariantUserError implements DisplayableError {

  code: QuantityPricingByVariantUserErrorCode


  field: [String!]


  message: String!
}


enum QuantityPricingByVariantUserErrorCode {

  BLANK


  PRICE_LIST_NOT_FOUND


  GENERIC_ERROR


  QUANTITY_PRICE_BREAK_ADD_INVALID


  QUANTITY_PRICE_BREAK_ADD_PRICE_LIST_PRICE_NOT_FOUND


  QUANTITY_PRICE_BREAK_ADD_LIMIT_EXCEEDED


  QUANTITY_PRICE_BREAK_ADD_CURRENCY_MISMATCH


  QUANTITY_PRICE_BREAK_ADD_FAILED_TO_SAVE


  QUANTITY_PRICE_BREAK_ADD_MIN_LOWER_THAN_QUANTITY_RULES_MIN


  QUANTITY_PRICE_BREAK_ADD_MIN_HIGHER_THAN_QUANTITY_RULES_MAX


  QUANTITY_PRICE_BREAK_ADD_MIN_NOT_A_MULTIPLE_OF_QUANTITY_RULES_INCREMENT


  QUANTITY_PRICE_BREAK_ADD_VARIANT_NOT_FOUND


  QUANTITY_PRICE_BREAK_ADD_DUPLICATE_INPUT_FOR_VARIANT_AND_MIN


  QUANTITY_PRICE_BREAK_DELETE_NOT_FOUND


  QUANTITY_PRICE_BREAK_DELETE_FAILED


  QUANTITY_RULE_ADD_VARIANT_NOT_FOUND


  QUANTITY_RULE_ADD_MIN_HIGHER_THAN_QUANTITY_PRICE_BREAK_MIN


  QUANTITY_RULE_ADD_MAX_LOWER_THAN_QUANTITY_PRICE_BREAK_MIN


  QUANTITY_RULE_ADD_INCREMENT_NOT_A_MULTIPLE_OF_QUANTITY_PRICE_BREAK_MIN


  QUANTITY_RULE_ADD_CATALOG_CONTEXT_NOT_SUPPORTED


  QUANTITY_RULE_ADD_INCREMENT_IS_GREATER_THAN_MINIMUM


  QUANTITY_RULE_ADD_MINIMUM_NOT_A_MULTIPLE_OF_INCREMENT


  QUANTITY_RULE_ADD_MAXIMUM_NOT_A_MULTIPLE_OF_INCREMENT


  QUANTITY_RULE_ADD_MINIMUM_GREATER_THAN_MAXIMUM


  QUANTITY_RULE_ADD_INCREMENT_IS_LESS_THAN_ONE


  QUANTITY_RULE_ADD_MINIMUM_IS_LESS_THAN_ONE


  QUANTITY_RULE_ADD_MAXIMUM_IS_LESS_THAN_ONE


  QUANTITY_RULE_ADD_DUPLICATE_INPUT_FOR_VARIANT


  QUANTITY_RULE_DELETE_RULE_NOT_FOUND


  QUANTITY_RULE_DELETE_VARIANT_NOT_FOUND


  PRICE_ADD_CURRENCY_MISMATCH


  PRICE_ADD_VARIANT_NOT_FOUND


  PRICE_ADD_DUPLICATE_INPUT_FOR_VARIANT


  PRICE_DELETE_PRICE_NOT_FIXED


  PRICE_DELETE_VARIANT_NOT_FOUND
}


type QuantityRule {

  increment: Int!


  isDefault: Boolean!


  maximum: Int


  minimum: Int!


  originType: QuantityRuleOriginType!


  productVariant: ProductVariant!
}


type QuantityRuleConnection {

  edges: [QuantityRuleEdge!]!


  nodes: [QuantityRule!]!


  pageInfo: PageInfo!
}


type QuantityRuleEdge {

  cursor: String!


  node: QuantityRule!
}


input QuantityRuleInput {

  increment: Int!


  maximum: Int 


  minimum: Int!


  variantId: ID!
}


enum QuantityRuleOriginType {

  FIXED


  RELATIVE
}


type QuantityRulesAddPayload {

  quantityRules: [QuantityRule!]


  userErrors: [QuantityRuleUserError!]!
}


type QuantityRulesDeletePayload {

  deletedQuantityRulesVariantIds: [ID!]


  userErrors: [QuantityRuleUserError!]!
}


type QuantityRuleUserError implements DisplayableError {

  code: QuantityRuleUserErrorCode


  field: [String!]


  message: String!
}


enum QuantityRuleUserErrorCode {

  BLANK


  PRODUCT_VARIANT_DOES_NOT_EXIST


  PRICE_LIST_DOES_NOT_EXIST


  VARIANT_QUANTITY_RULE_DOES_NOT_EXIST


  MINIMUM_IS_GREATER_THAN_MAXIMUM


  MINIMUM_IS_HIGHER_THAN_QUANTITY_PRICE_BREAK_MINIMUM


  MAXIMUM_IS_LOWER_THAN_QUANTITY_PRICE_BREAK_MINIMUM


  INCREMENT_NOT_A_MULTIPLE_OF_QUANTITY_PRICE_BREAK_MINIMUM


  INCREMENT_IS_GREATER_THAN_MINIMUM


  GREATER_THAN_OR_EQUAL_TO


  MAXIMUM_NOT_MULTIPLE_OF_INCREMENT


  MINIMUM_NOT_MULTIPLE_OF_INCREMENT


  CATALOG_CONTEXT_DOES_NOT_SUPPORT_QUANTITY_RULES


  DUPLICATE_INPUT_FOR_VARIANT


  GENERIC_ERROR
}


type QueryRoot {

  abandonment(

    id: ID!
  ): Abandonment


  abandonmentByAbandonedCheckoutId(

    abandonedCheckoutId: ID!
  ): Abandonment


  app(

    id: ID
  ): App


  appByHandle(

    handle: String!
  ): App


  appByKey(

    apiKey: String!
  ): App


  appDiscountType(

    functionId: String!
  ): AppDiscountType


  appDiscountTypes: [AppDiscountType!]!


  appInstallation(

    id: ID
  ): AppInstallation


  appInstallations(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: AppInstallationSortKeys = INSTALLED_AT


    category: AppInstallationCategory


    privacy: AppInstallationPrivacy = PUBLIC
  ): AppInstallationConnection!


  automaticDiscount(

    id: ID!
  ): DiscountAutomatic @deprecated(reason: "Use `automaticDiscountNode` instead.")


  automaticDiscountNode(

    id: ID!
  ): DiscountAutomaticNode


  automaticDiscountNodes(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: AutomaticDiscountSortKeys = CREATED_AT


    query: String


    savedSearchId: ID
  ): DiscountAutomaticNodeConnection!


  automaticDiscountSavedSearches(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SavedSearchConnection!


  automaticDiscounts(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: AutomaticDiscountSortKeys = CREATED_AT


    query: String


    savedSearchId: ID
  ): DiscountAutomaticConnection! @deprecated(reason: "Use `automaticDiscountNodes` instead.")


  availableCarrierServices: [DeliveryCarrierServiceAndLocations!]!


  availableLocales: [Locale!]!


  carrierService(

    id: ID!
  ): DeliveryCarrierService


  cartTransforms(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): CartTransformConnection!


  catalog(

    id: ID!
  ): Catalog


  catalogOperations: [ResourceOperation!]!


  catalogs(

    type: CatalogType 


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: CatalogSortKeys = ID


    query: String
  ): CatalogConnection!


  channel(

    id: ID!
  ): Channel @deprecated(reason: "Use `publication` instead.")


  channels(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ChannelConnection! @deprecated(reason: "Use `publications` instead.")


  checkoutBranding(

    checkoutProfileId: ID!
  ): CheckoutBranding


  checkoutProfile(

    id: ID!
  ): CheckoutProfile


  checkoutProfiles(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: CheckoutProfileSortKeys = UPDATED_AT


    query: String
  ): CheckoutProfileConnection!


  codeDiscountNode(

    id: ID!
  ): DiscountCodeNode


  codeDiscountNodeByCode(

    code: String!
  ): DiscountCodeNode


  codeDiscountNodes(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: CodeDiscountSortKeys = CREATED_AT


    query: String


    savedSearchId: ID
  ): DiscountCodeNodeConnection!


  codeDiscountSavedSearches(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SavedSearchConnection!


  collection(

    id: ID!
  ): Collection


  collectionByHandle(

    handle: String!
  ): Collection


  collectionRulesConditions: [CollectionRuleConditions!]!


  collectionSavedSearches(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SavedSearchConnection!


  collections(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: CollectionSortKeys = ID


    query: String


    savedSearchId: ID
  ): CollectionConnection!


  companies(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: CompanySortKeys = ID


    query: String
  ): CompanyConnection!


  company(

    id: ID!
  ): Company


  companyContact(

    id: ID!
  ): CompanyContact


  companyContactRole(

    id: ID!
  ): CompanyContactRole


  companyCount: Int!


  companyLocation(

    id: ID!
  ): CompanyLocation


  companyLocations(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: CompanyLocationSortKeys = ID


    query: String
  ): CompanyLocationConnection!


  currentAppInstallation: AppInstallation!


  currentBulkOperation(

    type: BulkOperationType = QUERY
  ): BulkOperation


  customer(

    id: ID!
  ): Customer


  customerMergeJobStatus(

    jobId: ID!
  ): CustomerMergeRequest


  customerMergePreview(

    customerOneId: ID!


    customerTwoId: ID!


    overrideFields: CustomerMergeOverrideFields
  ): CustomerMergePreview!


  customerPaymentMethod(

    id: ID!


    showRevoked: Boolean = false
  ): CustomerPaymentMethod


  customerSegmentMembers(

    segmentId: ID


    query: String


    queryId: ID


    timezone: String


    reverse: Boolean = false


    sortKey: String


    first: Int


    after: String


    last: Int


    before: String
  ): CustomerSegmentMemberConnection!


  customerSegmentMembersQuery(

    id: ID!
  ): CustomerSegmentMembersQuery


  customerSegmentMembership(

    segmentIds: [ID!]!


    customerId: ID!
  ): SegmentMembershipResponse!


  customers(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: CustomerSortKeys = ID


    query: String
  ): CustomerConnection!


  deletionEvents(

    subjectTypes: [DeletionEventSubjectType!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: DeletionEventSortKeys = ID


    query: String
  ): DeletionEventConnection!


  deliveryCustomization(

    id: ID!
  ): DeliveryCustomization


  deliveryCustomizations(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    query: String
  ): DeliveryCustomizationConnection!


  deliveryProfile(

    id: ID!
  ): DeliveryProfile


  deliveryProfiles(

    merchantOwnedOnly: Boolean


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): DeliveryProfileConnection!


  deliverySettings: DeliverySetting


  discountCodeCount(

    query: String
  ): Int!


  discountNode(

    id: ID!
  ): DiscountNode


  discountNodes(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: DiscountSortKeys = CREATED_AT


    query: String


    savedSearchId: ID
  ): DiscountNodeConnection!


  discountRedeemCodeBulkCreation(

    id: ID!
  ): DiscountRedeemCodeBulkCreation


  discountRedeemCodeSavedSearches(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: DiscountCodeSortKeys = ID


    query: String
  ): SavedSearchConnection!


  dispute(

    id: ID!
  ): ShopifyPaymentsDispute


  disputeEvidence(

    id: ID!
  ): ShopifyPaymentsDisputeEvidence


  domain(

    id: ID!
  ): Domain


  draftOrder(

    id: ID!
  ): DraftOrder


  draftOrderSavedSearches(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SavedSearchConnection!


  draftOrderTag(

    id: ID!
  ): DraftOrderTag


  draftOrders(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: DraftOrderSortKeys = ID


    query: String


    savedSearchId: ID
  ): DraftOrderConnection!


  fileSavedSearches(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SavedSearchConnection!


  files(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: FileSortKeys = ID


    query: String


    savedSearchId: ID
  ): FileConnection!


  fulfillment(

    id: ID!
  ): Fulfillment


  fulfillmentConstraintRules: [FulfillmentConstraintRule!]!


  fulfillmentOrder(

    id: ID!
  ): FulfillmentOrder


  fulfillmentOrders(

    includeClosed: Boolean = false


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: FulfillmentOrderSortKeys = ID


    query: String
  ): FulfillmentOrderConnection!


  fulfillmentService(

    id: ID!
  ): FulfillmentService


  giftCard(

    id: ID!
  ): GiftCard


  giftCards(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: GiftCardSortKeys = ID


    query: String


    savedSearchId: ID
  ): GiftCardConnection!


  giftCardsCount(

    enabled: Boolean
  ): UnsignedInt64!


  inventoryItem(

    id: ID!
  ): InventoryItem


  inventoryItems(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    query: String
  ): InventoryItemConnection!


  inventoryLevel(

    id: ID!
  ): InventoryLevel


  inventoryProperties: InventoryProperties!


  job(

    id: ID!
  ): Job


  location(

    id: ID
  ): Location


  locations(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: LocationSortKeys = NAME


    query: String


    includeLegacy: Boolean = false


    includeInactive: Boolean = false
  ): LocationConnection!


  locationsAvailableForDeliveryProfiles: [Location!] @deprecated(reason: "Use `locationsAvailableForDeliveryProfilesConnection` instead.")


  locationsAvailableForDeliveryProfilesConnection(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): LocationConnection!


  manualHoldsFulfillmentOrders(

    query: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): FulfillmentOrderConnection!


  market(

    id: ID!
  ): Market


  marketByGeography(

    countryCode: CountryCode!
  ): Market


  marketLocalizableResource(

    resourceId: ID!
  ): MarketLocalizableResource


  marketLocalizableResources(

    resourceType: MarketLocalizableResourceType!


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MarketLocalizableResourceConnection!


  marketLocalizableResourcesByIds(

    resourceIds: [ID!]!


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MarketLocalizableResourceConnection!


  marketingActivities(

    marketingActivityIds: [ID!] = []


    remoteIds: [String!] = []


    utm: UTMInput


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: MarketingActivitySortKeys = CREATED_AT


    query: String


    savedSearchId: ID
  ): MarketingActivityConnection!


  marketingActivity(

    id: ID!
  ): MarketingActivity


  marketingEvent(

    id: ID!
  ): MarketingEvent


  marketingEvents(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: MarketingEventSortKeys = ID


    query: String
  ): MarketingEventConnection!


  markets(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MarketConnection!


  metafieldDefinition(

    id: ID!
  ): MetafieldDefinition


  metafieldDefinitionTypes: [MetafieldDefinitionType!]!


  metafieldDefinitions(

    key: String


    namespace: String


    ownerType: MetafieldOwnerType!


    pinnedStatus: MetafieldDefinitionPinnedStatus = ANY


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: MetafieldDefinitionSortKeys = ID


    query: String
  ): MetafieldDefinitionConnection!


  metafieldStorefrontVisibilities(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldStorefrontVisibilityConnection! @deprecated(reason: "This query will be removed in a future version. Use the `access.storefront` field for nodes inside the `metafieldDefinitions` query instead.\n")


  metafieldStorefrontVisibility(

    id: ID!
  ): MetafieldStorefrontVisibility @deprecated(reason: "This query will be removed in a future version. Use the `access.storefront` field inside the `metafieldDefinition` query instead.\n")


  metaobject(

    id: ID!
  ): Metaobject


  metaobjectByHandle(

    handle: MetaobjectHandleInput!
  ): Metaobject


  metaobjectDefinition(

    id: ID!
  ): MetaobjectDefinition


  metaobjectDefinitionByType(

    type: String!
  ): MetaobjectDefinition


  metaobjectDefinitions(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetaobjectDefinitionConnection!


  metaobjects(

    type: String!


    sortKey: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    query: String
  ): MetaobjectConnection!


  node(

    id: ID!
  ): Node


  nodes(

    ids: [ID!]!
  ): [Node]!


  order(

    id: ID!
  ): Order


  orderPaymentStatus(

    paymentReferenceId: String!


    orderId: ID!
  ): OrderPaymentStatus


  orderSavedSearches(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SavedSearchConnection!


  orders(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: OrderSortKeys = PROCESSED_AT


    query: String


    savedSearchId: ID
  ): OrderConnection!


  paymentCustomization(

    id: ID!
  ): PaymentCustomization


  paymentCustomizations(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    query: String
  ): PaymentCustomizationConnection!


  paymentTermsTemplates(

    paymentTermsType: PaymentTermsType
  ): [PaymentTermsTemplate!]!


  priceList(

    id: ID!
  ): PriceList


  priceLists(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: PriceListSortKeys = ID
  ): PriceListConnection!


  priceRule(

    id: ID!
  ): PriceRule @deprecated(reason: "Use `codeDiscountNode` instead.")


  priceRuleSavedSearches(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SavedSearchConnection!


  priceRules(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: PriceRuleSortKeys = ID


    query: String


    savedSearchId: ID
  ): PriceRuleConnection! @deprecated(reason: "Use `codeDiscountNodes` instead.")


  primaryMarket: Market!


  privateMetafield(

    id: ID!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    owner: ID!


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  product(

    id: ID!
  ): Product


  productByHandle(

    handle: String!
  ): Product


  productDuplicateJob(

    id: ID!
  ): ProductDuplicateJob!


  productFeed(

    id: ID!
  ): ProductFeed


  productFeeds(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ProductFeedConnection!


  productResourceFeedback(

    id: ID!
  ): ProductResourceFeedback


  productSavedSearches(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SavedSearchConnection!


  productVariant(

    id: ID!
  ): ProductVariant


  productVariants(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: ProductVariantSortKeys = ID


    query: String


    savedSearchId: ID
  ): ProductVariantConnection!


  products(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: ProductSortKeys = ID


    query: String


    savedSearchId: ID
  ): ProductConnection!


  publicApiVersions: [ApiVersion!]!


  publication(

    id: ID!
  ): Publication


  publications(

    catalogType: CatalogType


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PublicationConnection!


  refund(

    id: ID!
  ): Refund


  return(

    id: ID!
  ): Return


  returnableFulfillment(

    id: ID!
  ): ReturnableFulfillment


  returnableFulfillments(

    orderId: ID!


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ReturnableFulfillmentConnection!


  reverseDelivery(

    id: ID!
  ): ReverseDelivery


  reverseFulfillmentOrder(

    id: ID!
  ): ReverseFulfillmentOrder


  scriptTag(

    id: ID!
  ): ScriptTag


  scriptTags(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    src: URL
  ): ScriptTagConnection!


  segment(

    id: ID!
  ): Segment


  segmentCount: Int!


  segmentFilterSuggestions(

    search: String!


    first: Int!


    after: String
  ): SegmentFilterConnection!


  segmentFilters(

    first: Int


    after: String


    last: Int


    before: String
  ): SegmentFilterConnection!


  segmentMigrations(

    savedSearchId: ID


    first: Int


    after: String


    last: Int


    before: String
  ): SegmentMigrationConnection!


  segmentValueSuggestions(

    search: String!


    filterQueryName: String


    functionParameterQueryName: String


    first: Int


    after: String


    last: Int


    before: String
  ): SegmentValueConnection!


  segments(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: SegmentSortKeys = CREATION_DATE


    query: String
  ): SegmentConnection!


  sellingPlanGroup(

    id: ID!
  ): SellingPlanGroup


  sellingPlanGroups(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: SellingPlanGroupSortKeys = ID


    query: String
  ): SellingPlanGroupConnection!


  serverPixel: ServerPixel


  shop: Shop!


  shopBillingPreferences: ShopBillingPreferences!


  shopLocales(

    published: Boolean = false
  ): [ShopLocale!]!


  shopifyFunction(

    id: String!
  ): ShopifyFunction


  shopifyFunctions(

    apiType: String


    useCreationUi: Boolean


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ShopifyFunctionConnection!


  shopifyPaymentsAccount: ShopifyPaymentsAccount


  shopifyqlQuery(

    query: String!
  ): ShopifyqlResponse


  staffMember(

    id: ID
  ): StaffMember


  standardMetafieldDefinitionTemplates(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): StandardMetafieldDefinitionTemplateConnection!


  subscriptionBillingAttempt(

    id: ID!
  ): SubscriptionBillingAttempt


  subscriptionBillingAttempts(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: SubscriptionBillingAttemptsSortKeys = CREATED_AT


    query: String
  ): SubscriptionBillingAttemptConnection!


  subscriptionBillingCycle(

    billingCycleInput: SubscriptionBillingCycleInput!
  ): SubscriptionBillingCycle


  subscriptionBillingCycles(

    contractId: ID!


    billingCyclesDateRangeSelector: SubscriptionBillingCyclesDateRangeSelector


    billingCyclesIndexRangeSelector: SubscriptionBillingCyclesIndexRangeSelector


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: SubscriptionBillingCyclesSortKeys = CYCLE_INDEX
  ): SubscriptionBillingCycleConnection!


  subscriptionContract(

    id: ID!
  ): SubscriptionContract


  subscriptionContracts(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    query: String
  ): SubscriptionContractConnection!


  subscriptionDraft(

    id: ID!
  ): SubscriptionDraft


  tenderTransactions(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    query: String
  ): TenderTransactionConnection!


  translatableResource(

    resourceId: ID!
  ): TranslatableResource


  translatableResources(

    resourceType: TranslatableResourceType!


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): TranslatableResourceConnection!


  translatableResourcesByIds(

    resourceIds: [ID!]!


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): TranslatableResourceConnection!


  urlRedirect(

    id: ID!
  ): UrlRedirect


  urlRedirectImport(

    id: ID!
  ): UrlRedirectImport


  urlRedirectSavedSearches(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SavedSearchConnection!


  urlRedirects(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: UrlRedirectSortKeys = ID


    query: String


    savedSearchId: ID
  ): UrlRedirectConnection!


  validation(

    id: ID!
  ): Validation


  validations(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: ValidationSortKeys = ID
  ): ValidationConnection!


  webPixel(

    id: ID
  ): WebPixel


  webhookSubscription(

    id: ID!
  ): WebhookSubscription


  webhookSubscriptions(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: WebhookSubscriptionSortKeys = CREATED_AT


    query: String


    callbackUrl: URL


    format: WebhookSubscriptionFormat


    topics: [WebhookSubscriptionTopic!]
  ): WebhookSubscriptionConnection!
}


type Refund implements LegacyInteroperability & Node {

  createdAt: DateTime


  duties: [RefundDuty!]


  id: ID!


  legacyResourceId: UnsignedInt64!


  note: String


  order: Order!


  refundLineItems(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): RefundLineItemConnection!


  return: Return


  staffMember: StaffMember


  totalRefunded: MoneyV2! @deprecated(reason: "Use `totalRefundedSet` instead.")


  totalRefundedSet: MoneyBag!


  transactions(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): OrderTransactionConnection!


  updatedAt: DateTime!
}


type RefundAgreement implements SalesAgreement {

  app: App


  happenedAt: DateTime!


  id: ID!


  reason: OrderActionType!


  refund: Refund!


  sales(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SaleConnection!


  user: StaffMember
}


type RefundConnection {

  edges: [RefundEdge!]!


  nodes: [Refund!]!


  pageInfo: PageInfo!
}


type RefundCreatePayload {

  order: Order


  refund: Refund


  userErrors: [UserError!]!
}


type RefundDuty {

  amountSet: MoneyBag!


  originalDuty: Duty
}


input RefundDutyInput {

  dutyId: ID!


  refundType: RefundDutyRefundType
}


enum RefundDutyRefundType {

  PROPORTIONAL


  FULL
}


type RefundEdge {

  cursor: String!


  node: Refund!
}


input RefundInput {

  currency: CurrencyCode


  orderId: ID!


  note: String


  notify: Boolean


  shipping: ShippingRefundInput


  refundLineItems: [RefundLineItemInput!]


  refundDuties: [RefundDutyInput!]


  transactions: [OrderTransactionInput!]
}


type RefundLineItem {

  lineItem: LineItem!


  location: Location


  price: Money! @deprecated(reason: "Use `priceSet` instead.")


  priceSet: MoneyBag!


  quantity: Int!


  restockType: RefundLineItemRestockType!


  restocked: Boolean!


  subtotal: Money! @deprecated(reason: "Use `subtotalSet` instead.")


  subtotalSet: MoneyBag!


  totalTax: Money! @deprecated(reason: "Use `totalTaxSet` instead.")


  totalTaxSet: MoneyBag!
}


type RefundLineItemConnection {

  edges: [RefundLineItemEdge!]!


  nodes: [RefundLineItem!]!


  pageInfo: PageInfo!
}


type RefundLineItemEdge {

  cursor: String!


  node: RefundLineItem!
}


input RefundLineItemInput {

  lineItemId: ID!


  quantity: Int!


  restockType: RefundLineItemRestockType


  locationId: ID
}


enum RefundLineItemRestockType {

  RETURN


  CANCEL


  LEGACY_RESTOCK


  NO_RESTOCK
}


input RefundShippingInput {

  shippingRefundAmount: MoneyInput


  fullRefund: Boolean = false
}


input RemoteAuthorizeNetCustomerPaymentProfileInput {

  customerProfileId: String!


  customerPaymentProfileId: String
}


input RemoteBraintreePaymentMethodInput {

  customerId: String!


  paymentMethodToken: String
}


input RemoteStripePaymentMethodInput {

  customerId: String!


  paymentMethodId: String
}


type ResourceAlert {

  actions: [ResourceAlertAction!]!


  content: HTML!


  dismissibleHandle: String


  icon: ResourceAlertIcon


  severity: ResourceAlertSeverity!


  title: String!
}


type ResourceAlertAction {

  primary: Boolean!


  show: String


  title: String!


  url: URL!
}


enum ResourceAlertIcon {

  CHECKMARK_CIRCLE


  INFORMATION_CIRCLE
}


enum ResourceAlertSeverity {

  DEFAULT


  INFO


  WARNING


  SUCCESS


  CRITICAL
  ERROR @deprecated(reason: "`ERROR` severity is being deprecated in favour of `WARNING` or `CRITICAL` instead.")
}


type ResourceFeedback {

  appFeedback: [AppFeedback!]! @deprecated(reason: "Use `details` instead.")


  details: [AppFeedback!]!


  summary: String!
}


input ResourceFeedbackCreateInput {

  feedbackGeneratedAt: DateTime!


  messages: [String!]


  state: ResourceFeedbackState!
}


enum ResourceFeedbackState {

  ACCEPTED


  REQUIRES_ACTION
}


interface ResourceOperation {

  id: ID!


  processedRowCount: Int


  rowCount: RowCount


  status: ResourceOperationStatus!
}


enum ResourceOperationStatus {

  CREATED


  ACTIVE


  COMPLETE
}


type ResourcePublication {

  channel: Channel! @deprecated(reason: "Use `publication` instead.")


  isPublished: Boolean!


  publication: Publication!


  publishDate: DateTime!


  publishable: Publishable!
}


type ResourcePublicationConnection {

  edges: [ResourcePublicationEdge!]!


  nodes: [ResourcePublication!]!


  pageInfo: PageInfo!
}


type ResourcePublicationEdge {

  cursor: String!


  node: ResourcePublication!
}


type ResourcePublicationV2 {

  isPublished: Boolean!


  publication: Publication!


  publishDate: DateTime


  publishable: Publishable!
}


type ResourcePublicationV2Connection {

  edges: [ResourcePublicationV2Edge!]!


  nodes: [ResourcePublicationV2!]!


  pageInfo: PageInfo!
}


type ResourcePublicationV2Edge {

  cursor: String!


  node: ResourcePublicationV2!
}


type Return implements Node {

  decline: ReturnDecline


  id: ID!


  name: String!


  order: Order!


  refunds(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): RefundConnection!


  returnLineItems(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ReturnLineItemConnection!


  reverseFulfillmentOrders(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ReverseFulfillmentOrderConnection!


  status: ReturnStatus!


  suggestedRefund(

    returnRefundLineItems: [ReturnRefundLineItemInput!]!


    refundShipping: RefundShippingInput


    refundDuties: [RefundDutyInput!]
  ): SuggestedReturnRefund


  totalQuantity: Int!
}


type ReturnableFulfillment implements Node {

  fulfillment: Fulfillment!


  id: ID!


  returnableFulfillmentLineItems(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ReturnableFulfillmentLineItemConnection!
}


type ReturnableFulfillmentConnection {

  edges: [ReturnableFulfillmentEdge!]!


  nodes: [ReturnableFulfillment!]!


  pageInfo: PageInfo!
}


type ReturnableFulfillmentEdge {

  cursor: String!


  node: ReturnableFulfillment!
}


type ReturnableFulfillmentLineItem {

  fulfillmentLineItem: FulfillmentLineItem!


  quantity: Int!
}


type ReturnableFulfillmentLineItemConnection {

  edges: [ReturnableFulfillmentLineItemEdge!]!


  nodes: [ReturnableFulfillmentLineItem!]!


  pageInfo: PageInfo!
}


type ReturnableFulfillmentLineItemEdge {

  cursor: String!


  node: ReturnableFulfillmentLineItem!
}


input ReturnApproveRequestInput {

  id: ID!
}


type ReturnApproveRequestPayload {

  return: Return


  userErrors: [ReturnUserError!]!
}


type ReturnCancelPayload {

  return: Return


  userErrors: [ReturnUserError!]!
}


type ReturnClosePayload {

  return: Return


  userErrors: [ReturnUserError!]!
}


type ReturnConnection {

  edges: [ReturnEdge!]!


  nodes: [Return!]!


  pageInfo: PageInfo!
}


type ReturnCreatePayload {

  return: Return


  userErrors: [ReturnUserError!]!
}


type ReturnDecline {

  note: String


  reason: ReturnDeclineReason!
}


enum ReturnDeclineReason {

  RETURN_PERIOD_ENDED


  FINAL_SALE


  OTHER
}


input ReturnDeclineRequestInput {

  id: ID!


  declineReason: ReturnDeclineReason!
}


type ReturnDeclineRequestPayload {

  return: Return


  userErrors: [ReturnUserError!]!
}


type ReturnEdge {

  cursor: String!


  node: Return!
}


enum ReturnErrorCode {

  INTERNAL_ERROR


  TOO_MANY_ARGUMENTS


  BLANK


  EQUAL_TO


  GREATER_THAN


  GREATER_THAN_OR_EQUAL_TO


  INCLUSION


  INVALID


  LESS_THAN


  LESS_THAN_OR_EQUAL_TO


  NOT_A_NUMBER


  PRESENT


  TAKEN


  TOO_BIG


  TOO_LONG


  TOO_SHORT


  WRONG_LENGTH


  ALREADY_EXISTS


  CREATION_FAILED


  FEATURE_NOT_ENABLED


  INVALID_STATE


  NOTIFICATION_FAILED


  NOT_EDITABLE


  NOT_FOUND
}


input ReturnInput {

  orderId: ID!


  returnLineItems: [ReturnLineItemInput!]!


  notifyCustomer: Boolean = false


  requestedAt: DateTime
}


type ReturnLineItem implements Node {

  customerNote: String


  fulfillmentLineItem: FulfillmentLineItem!


  id: ID!


  quantity: Int!


  refundableQuantity: Int!


  refundedQuantity: Int!


  returnReason: ReturnReason!


  returnReasonNote: String!


  totalWeight: Weight


  withCodeDiscountedTotalPriceSet: MoneyBag!
}


type ReturnLineItemConnection {

  edges: [ReturnLineItemEdge!]!


  nodes: [ReturnLineItem!]!


  pageInfo: PageInfo!
}


type ReturnLineItemEdge {

  cursor: String!


  node: ReturnLineItem!
}


input ReturnLineItemInput {

  fulfillmentLineItemId: ID!


  quantity: Int!


  returnReason: ReturnReason!


  returnReasonNote: String = ""
}


enum ReturnReason {

  SIZE_TOO_SMALL


  SIZE_TOO_LARGE


  UNWANTED


  NOT_AS_DESCRIBED


  WRONG_ITEM


  DEFECTIVE


  STYLE


  COLOR


  OTHER


  UNKNOWN
}


input ReturnRefundInput {

  returnId: ID!


  returnRefundLineItems: [ReturnRefundLineItemInput!]!


  refundShipping: RefundShippingInput


  refundDuties: [RefundDutyInput!]


  orderTransactions: [ReturnRefundOrderTransactionInput!] = []


  notifyCustomer: Boolean = false
}


input ReturnRefundLineItemInput {

  returnLineItemId: ID!


  quantity: Int!
}


input ReturnRefundOrderTransactionInput {

  transactionAmount: MoneyInput!


  parentId: ID!
}


type ReturnRefundPayload {

  refund: Refund


  userErrors: [ReturnUserError!]!
}


type ReturnReopenPayload {

  return: Return


  userErrors: [ReturnUserError!]!
}


input ReturnRequestInput {

  orderId: ID!


  returnLineItems: [ReturnRequestLineItemInput!]!
}


input ReturnRequestLineItemInput {

  fulfillmentLineItemId: ID!


  quantity: Int!


  returnReason: ReturnReason!


  customerNote: String
}


type ReturnRequestPayload {

  return: Return


  userErrors: [ReturnUserError!]!
}


enum ReturnStatus {

  CANCELED


  CLOSED


  OPEN


  REQUESTED


  DECLINED
}


type ReturnUserError implements DisplayableError {

  code: ReturnErrorCode


  field: [String!]


  message: String!
}


type ReverseDelivery implements Node {

  deliverable: ReverseDeliveryDeliverable


  id: ID!


  reverseDeliveryLineItems(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ReverseDeliveryLineItemConnection!


  reverseFulfillmentOrder: ReverseFulfillmentOrder!
}


type ReverseDeliveryConnection {

  edges: [ReverseDeliveryEdge!]!


  nodes: [ReverseDelivery!]!


  pageInfo: PageInfo!
}


type ReverseDeliveryCreateWithShippingPayload {

  reverseDelivery: ReverseDelivery


  userErrors: [ReturnUserError!]!
}


union ReverseDeliveryDeliverable = ReverseDeliveryShippingDeliverable


input ReverseDeliveryDisposeInput {

  reverseDeliveryLineItemId: ID!


  quantity: Int!


  dispositionType: ReverseFulfillmentOrderDispositionType!


  locationId: ID
}


type ReverseDeliveryDisposePayload {

  reverseDeliveryLineItems: [ReverseDeliveryLineItem!]


  userErrors: [ReturnUserError!]!
}


type ReverseDeliveryEdge {

  cursor: String!


  node: ReverseDelivery!
}


input ReverseDeliveryLabelInput {

  fileUrl: URL!
}


type ReverseDeliveryLabelV2 {

  createdAt: DateTime!


  publicFileUrl: URL


  updatedAt: DateTime!
}


type ReverseDeliveryLineItem implements Node {

  dispositions: [ReverseFulfillmentOrderDisposition!]!


  id: ID!


  quantity: Int!


  reverseFulfillmentOrderLineItem: ReverseFulfillmentOrderLineItem!
}


type ReverseDeliveryLineItemConnection {

  edges: [ReverseDeliveryLineItemEdge!]!


  nodes: [ReverseDeliveryLineItem!]!


  pageInfo: PageInfo!
}


type ReverseDeliveryLineItemEdge {

  cursor: String!


  node: ReverseDeliveryLineItem!
}


input ReverseDeliveryLineItemInput {

  reverseFulfillmentOrderLineItemId: ID!


  quantity: Int!
}


type ReverseDeliveryShippingDeliverable {

  label: ReverseDeliveryLabelV2


  tracking: ReverseDeliveryTrackingV2
}


type ReverseDeliveryShippingUpdatePayload {

  reverseDelivery: ReverseDelivery


  userErrors: [ReturnUserError!]!
}


input ReverseDeliveryTrackingInput {

  number: String


  url: URL
}


type ReverseDeliveryTrackingV2 {

  carrierName: String


  number: String


  url: URL
}


type ReverseFulfillmentOrder implements Node {

  id: ID!


  lineItems(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ReverseFulfillmentOrderLineItemConnection!


  order: Order!


  reverseDeliveries(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ReverseDeliveryConnection!


  status: ReverseFulfillmentOrderStatus!


  thirdPartyConfirmation: ReverseFulfillmentOrderThirdPartyConfirmation
}


type ReverseFulfillmentOrderConnection {

  edges: [ReverseFulfillmentOrderEdge!]!


  nodes: [ReverseFulfillmentOrder!]!


  pageInfo: PageInfo!
}


input ReverseFulfillmentOrderDisposeInput {

  reverseFulfillmentOrderLineItemId: ID!


  quantity: Int!


  locationId: ID


  dispositionType: ReverseFulfillmentOrderDispositionType!
}


type ReverseFulfillmentOrderDisposePayload {

  reverseFulfillmentOrderLineItems: [ReverseFulfillmentOrderLineItem!]


  userErrors: [ReturnUserError!]!
}


type ReverseFulfillmentOrderDisposition implements Node {

  id: ID!


  location: Location


  quantity: Int!


  type: ReverseFulfillmentOrderDispositionType!
}


enum ReverseFulfillmentOrderDispositionType {

  RESTOCKED


  PROCESSING_REQUIRED


  NOT_RESTOCKED


  MISSING
}


type ReverseFulfillmentOrderEdge {

  cursor: String!


  node: ReverseFulfillmentOrder!
}


type ReverseFulfillmentOrderLineItem implements Node {

  dispositions: [ReverseFulfillmentOrderDisposition!]!


  fulfillmentLineItem: FulfillmentLineItem!


  id: ID!


  totalQuantity: Int!
}


type ReverseFulfillmentOrderLineItemConnection {

  edges: [ReverseFulfillmentOrderLineItemEdge!]!


  nodes: [ReverseFulfillmentOrderLineItem!]!


  pageInfo: PageInfo!
}


type ReverseFulfillmentOrderLineItemEdge {

  cursor: String!


  node: ReverseFulfillmentOrderLineItem!
}


enum ReverseFulfillmentOrderStatus {

  CANCELED


  CLOSED


  OPEN
}


type ReverseFulfillmentOrderThirdPartyConfirmation {

  status: ReverseFulfillmentOrderThirdPartyConfirmationStatus!
}


enum ReverseFulfillmentOrderThirdPartyConfirmationStatus {

  ACCEPTED


  CANCEL_ACCEPTED


  CANCEL_REJECTED


  PENDING_ACCEPTANCE


  PENDING_CANCELATION


  REJECTED
}


type RowCount {

  count: Int!


  exceedsMax: Boolean!
}


interface Sale {

  actionType: SaleActionType!


  id: ID!


  lineType: SaleLineType!


  quantity: Int


  taxes: [SaleTax!]!


  totalAmount: MoneyBag!


  totalDiscountAmountAfterTaxes: MoneyBag!


  totalDiscountAmountBeforeTaxes: MoneyBag!


  totalTaxAmount: MoneyBag!
}


enum SaleActionType {

  ORDER


  RETURN


  UPDATE


  UNKNOWN
}


type SaleAdditionalFee implements Node {

  id: ID!


  name: String!


  price: MoneyBag!


  taxLines: [TaxLine!]!
}


type SaleConnection {

  edges: [SaleEdge!]!


  nodes: [Sale!]!


  pageInfo: PageInfo!
}


type SaleEdge {

  cursor: String!


  node: Sale!
}


enum SaleLineType {

  PRODUCT


  TIP


  GIFT_CARD


  SHIPPING


  DUTY


  ADDITIONAL_FEE


  UNKNOWN


  ADJUSTMENT
}


interface SalesAgreement {

  app: App


  happenedAt: DateTime!


  id: ID!


  reason: OrderActionType!


  sales(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SaleConnection!


  user: StaffMember
}


type SalesAgreementConnection {

  edges: [SalesAgreementEdge!]!


  nodes: [SalesAgreement!]!


  pageInfo: PageInfo!
}


type SalesAgreementEdge {

  cursor: String!


  node: SalesAgreement!
}


type SaleTax {

  amount: MoneyBag!


  id: ID!


  taxLine: TaxLine!
}


type SavedSearch implements LegacyInteroperability & Node {

  filters: [SearchFilter!]!


  id: ID!


  legacyResourceId: UnsignedInt64!


  name: String!


  query: String!


  resourceType: SearchResultType!


  searchTerms: String!
}


type SavedSearchConnection {

  edges: [SavedSearchEdge!]!


  nodes: [SavedSearch!]!


  pageInfo: PageInfo!
}


input SavedSearchCreateInput {

  resourceType: SearchResultType!


  name: String!


  query: String!
}


type SavedSearchCreatePayload {

  savedSearch: SavedSearch


  userErrors: [UserError!]!
}


input SavedSearchDeleteInput {

  id: ID!
}


type SavedSearchDeletePayload {

  deletedSavedSearchId: ID


  shop: Shop!


  userErrors: [UserError!]!
}


type SavedSearchEdge {

  cursor: String!


  node: SavedSearch!
}


input SavedSearchUpdateInput {

  id: ID!


  name: String


  query: String
}


type SavedSearchUpdatePayload {

  savedSearch: SavedSearch


  userErrors: [UserError!]!
}


enum ScheduledChangeSortKeys {

  EXPECTED_AT


  ID


  RELEVANCE
}


type ScriptDiscountApplication implements DiscountApplication {

  allocationMethod: DiscountApplicationAllocationMethod!


  description: String! @deprecated(reason: "Use `title` instead.")


  index: Int!


  targetSelection: DiscountApplicationTargetSelection!


  targetType: DiscountApplicationTargetType!


  title: String!


  value: PricingValue!
}


type ScriptTag implements LegacyInteroperability & Node {

  cache: Boolean!


  createdAt: DateTime!


  displayScope: ScriptTagDisplayScope!


  id: ID!


  legacyResourceId: UnsignedInt64!


  src: URL!


  updatedAt: DateTime!
}


type ScriptTagConnection {

  edges: [ScriptTagEdge!]!


  nodes: [ScriptTag!]!


  pageInfo: PageInfo!
}


type ScriptTagCreatePayload {

  scriptTag: ScriptTag


  userErrors: [UserError!]!
}


type ScriptTagDeletePayload {

  deletedScriptTagId: ID


  userErrors: [UserError!]!
}


enum ScriptTagDisplayScope {

  ALL


  ORDER_STATUS


  ONLINE_STORE
}


type ScriptTagEdge {

  cursor: String!


  node: ScriptTag!
}


input ScriptTagInput {

  src: URL


  displayScope: ScriptTagDisplayScope


  cache: Boolean = false
}


type ScriptTagUpdatePayload {

  scriptTag: ScriptTag


  userErrors: [UserError!]!
}


type SearchFilter {

  key: String!


  value: String!
}


type SearchFilterOptions {

  productAvailability: [FilterOption!]!
}


type SearchResult {

  description: String


  image: Image


  reference: Node!


  title: String!


  url: URL!
}


type SearchResultConnection {

  edges: [SearchResultEdge!]!


  pageInfo: PageInfo!


  resultsAfterCount: Int! @deprecated(reason: "The provided information is not accurate.")
}


type SearchResultEdge {

  cursor: String!


  node: SearchResult!
}


enum SearchResultType {
  CUSTOMER
  DRAFT_ORDER
  PRODUCT
  COLLECTION


  FILE
  ONLINE_STORE_PAGE
  ONLINE_STORE_BLOG
  ONLINE_STORE_ARTICLE


  URL_REDIRECT
  PRICE_RULE


  DISCOUNT_REDEEM_CODE
  ORDER


  BALANCE_TRANSACTION
}


type Segment implements Node {

  creationDate: DateTime!


  id: ID!


  lastEditDate: DateTime!


  name: String!


  query: String!
}


type SegmentAssociationFilter implements SegmentFilter {

  localizedName: String!


  multiValue: Boolean!


  queryName: String!
}


type SegmentAttributeStatistics {

  average: Float!


  sum: Float!
}


type SegmentBooleanFilter implements SegmentFilter {

  localizedName: String!


  multiValue: Boolean!


  queryName: String!
}


type SegmentConnection {

  edges: [SegmentEdge!]!


  nodes: [Segment!]!


  pageInfo: PageInfo!
}


type SegmentCreatePayload {

  segment: Segment


  userErrors: [UserError!]!
}


type SegmentDateFilter implements SegmentFilter {

  localizedName: String!


  multiValue: Boolean!


  queryName: String!
}


type SegmentDeletePayload {

  deletedSegmentId: ID


  userErrors: [UserError!]!
}


type SegmentEdge {

  cursor: String!


  node: Segment!
}


type SegmentEnumFilter implements SegmentFilter {

  localizedName: String!


  multiValue: Boolean!


  queryName: String!
}


type SegmentEventFilter implements SegmentFilter {

  localizedName: String!


  multiValue: Boolean!


  parameters: [SegmentEventFilterParameter!]!


  queryName: String!


  returnValueType: String!
}


type SegmentEventFilterParameter {

  acceptsMultipleValues: Boolean!


  localizedDescription: String!


  localizedName: String!


  optional: Boolean!


  parameterType: String!


  queryName: String!
}


interface SegmentFilter {

  localizedName: String!


  multiValue: Boolean!


  queryName: String!
}


type SegmentFilterConnection {

  edges: [SegmentFilterEdge!]!


  nodes: [SegmentFilter!]!


  pageInfo: PageInfo!
}


type SegmentFilterEdge {

  cursor: String!


  node: SegmentFilter!
}


type SegmentFloatFilter implements SegmentFilter {

  localizedName: String!


  multiValue: Boolean!


  queryName: String!
}


type SegmentIntegerFilter implements SegmentFilter {

  localizedName: String!


  multiValue: Boolean!


  queryName: String!
}


type SegmentMembership {

  isMember: Boolean!


  segmentId: ID!
}


type SegmentMembershipResponse {

  memberships: [SegmentMembership!]!
}


type SegmentMigration {

  id: ID!


  savedSearchId: ID!


  segmentId: ID
}


type SegmentMigrationConnection {

  edges: [SegmentMigrationEdge!]!


  nodes: [SegmentMigration!]!


  pageInfo: PageInfo!
}


type SegmentMigrationEdge {

  cursor: String!


  node: SegmentMigration!
}


enum SegmentSortKeys {

  CREATION_DATE


  LAST_EDIT_DATE


  ID


  RELEVANCE
}


type SegmentStatistics {

  attributeStatistics(

    attributeName: String!
  ): SegmentAttributeStatistics!
}


type SegmentStringFilter implements SegmentFilter {

  localizedName: String!


  multiValue: Boolean!


  queryName: String!
}


type SegmentUpdatePayload {

  segment: Segment


  userErrors: [UserError!]!
}


type SegmentValue {

  localizedValue: String!


  queryName: String!
}


type SegmentValueConnection {

  edges: [SegmentValueEdge!]!


  nodes: [SegmentValue!]!


  pageInfo: PageInfo!
}


type SegmentValueEdge {

  cursor: String!


  node: SegmentValue!
}


type SelectedOption {

  name: String!


  value: String!
}


type SellingPlan implements HasPublishedTranslations & Node {

  billingPolicy: SellingPlanBillingPolicy!


  category: SellingPlanCategory


  createdAt: DateTime!


  deliveryPolicy: SellingPlanDeliveryPolicy!


  description: String


  id: ID!


  inventoryPolicy: SellingPlanInventoryPolicy


  name: String!


  options: [String!]!


  position: Int


  pricingPolicies: [SellingPlanPricingPolicy!]!


  translations(

    locale: String!


    marketId: ID
  ): [Translation!]!
}


type SellingPlanAnchor {

  cutoffDay: Int


  day: Int!


  month: Int


  type: SellingPlanAnchorType!
}


input SellingPlanAnchorInput {

  type: SellingPlanAnchorType


  day: Int


  month: Int


  cutoffDay: Int
}


enum SellingPlanAnchorType {

  WEEKDAY


  MONTHDAY


  YEARDAY
}


union SellingPlanBillingPolicy = SellingPlanFixedBillingPolicy | SellingPlanRecurringBillingPolicy


input SellingPlanBillingPolicyInput {

  fixed: SellingPlanFixedBillingPolicyInput


  recurring: SellingPlanRecurringBillingPolicyInput
}


enum SellingPlanCategory {

  OTHER


  PRE_ORDER


  SUBSCRIPTION


  TRY_BEFORE_YOU_BUY
}


type SellingPlanCheckoutCharge {

  type: SellingPlanCheckoutChargeType!


  value: SellingPlanCheckoutChargeValue!
}


input SellingPlanCheckoutChargeInput {

  type: SellingPlanCheckoutChargeType


  value: SellingPlanCheckoutChargeValueInput
}


type SellingPlanCheckoutChargePercentageValue {

  percentage: Float!
}


enum SellingPlanCheckoutChargeType {

  PERCENTAGE


  PRICE
}


union SellingPlanCheckoutChargeValue = MoneyV2 | SellingPlanCheckoutChargePercentageValue


input SellingPlanCheckoutChargeValueInput {

  percentage: Float


  fixedValue: Decimal
}


type SellingPlanConnection {

  edges: [SellingPlanEdge!]!


  nodes: [SellingPlan!]!


  pageInfo: PageInfo!
}


union SellingPlanDeliveryPolicy = SellingPlanFixedDeliveryPolicy | SellingPlanRecurringDeliveryPolicy


input SellingPlanDeliveryPolicyInput {

  fixed: SellingPlanFixedDeliveryPolicyInput


  recurring: SellingPlanRecurringDeliveryPolicyInput
}


type SellingPlanEdge {

  cursor: String!


  node: SellingPlan!
}


type SellingPlanFixedBillingPolicy {

  checkoutCharge: SellingPlanCheckoutCharge!


  remainingBalanceChargeExactTime: DateTime


  remainingBalanceChargeTimeAfterCheckout: String


  remainingBalanceChargeTrigger: SellingPlanRemainingBalanceChargeTrigger!
}


input SellingPlanFixedBillingPolicyInput {

  remainingBalanceChargeTrigger: SellingPlanRemainingBalanceChargeTrigger


  remainingBalanceChargeExactTime: DateTime


  remainingBalanceChargeTimeAfterCheckout: String


  checkoutCharge: SellingPlanCheckoutChargeInput
}


type SellingPlanFixedDeliveryPolicy {

  anchors: [SellingPlanAnchor!]!


  cutoff: Int


  fulfillmentExactTime: DateTime


  fulfillmentTrigger: SellingPlanFulfillmentTrigger!


  intent: SellingPlanFixedDeliveryPolicyIntent!


  preAnchorBehavior: SellingPlanFixedDeliveryPolicyPreAnchorBehavior!
}


input SellingPlanFixedDeliveryPolicyInput {

  anchors: [SellingPlanAnchorInput!]


  fulfillmentTrigger: SellingPlanFulfillmentTrigger


  fulfillmentExactTime: DateTime


  cutoff: Int


  intent: SellingPlanFixedDeliveryPolicyIntent


  preAnchorBehavior: SellingPlanFixedDeliveryPolicyPreAnchorBehavior
}


enum SellingPlanFixedDeliveryPolicyIntent {

  FULFILLMENT_BEGIN
}


enum SellingPlanFixedDeliveryPolicyPreAnchorBehavior {

  ASAP


  NEXT
}


type SellingPlanFixedPricingPolicy implements SellingPlanPricingPolicyBase {

  adjustmentType: SellingPlanPricingPolicyAdjustmentType!


  adjustmentValue: SellingPlanPricingPolicyAdjustmentValue!


  createdAt: DateTime!
}


input SellingPlanFixedPricingPolicyInput {

  id: ID


  adjustmentType: SellingPlanPricingPolicyAdjustmentType


  adjustmentValue: SellingPlanPricingPolicyValueInput
}


enum SellingPlanFulfillmentTrigger {

  ANCHOR


  ASAP


  EXACT_TIME


  UNKNOWN
}


type SellingPlanGroup implements HasPublishedTranslations & Node {

  appId: String


  appliesToProduct(

    productId: ID!
  ): Boolean!


  appliesToProductVariant(

    productVariantId: ID!
  ): Boolean!


  appliesToProductVariants(

    productId: ID!
  ): Boolean!


  createdAt: DateTime!


  description: String


  id: ID!


  merchantCode: String!


  name: String!


  options: [String!]!


  position: Int


  productCount: Int!


  productVariantCount(

    productId: ID
  ): Int!


  productVariants(

    productId: ID


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ProductVariantConnection!


  products(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ProductConnection!


  sellingPlans(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SellingPlanConnection!


  summary: String


  translations(

    locale: String!


    marketId: ID
  ): [Translation!]!
}


type SellingPlanGroupAddProductsPayload {

  sellingPlanGroup: SellingPlanGroup


  userErrors: [SellingPlanGroupUserError!]!
}


type SellingPlanGroupAddProductVariantsPayload {

  sellingPlanGroup: SellingPlanGroup


  userErrors: [SellingPlanGroupUserError!]!
}


type SellingPlanGroupConnection {

  edges: [SellingPlanGroupEdge!]!


  nodes: [SellingPlanGroup!]!


  pageInfo: PageInfo!
}


type SellingPlanGroupCreatePayload {

  sellingPlanGroup: SellingPlanGroup


  userErrors: [SellingPlanGroupUserError!]!
}


type SellingPlanGroupDeletePayload {

  deletedSellingPlanGroupId: ID


  userErrors: [SellingPlanGroupUserError!]!
}


type SellingPlanGroupEdge {

  cursor: String!


  node: SellingPlanGroup!
}


input SellingPlanGroupInput {

  name: String


  appId: String


  merchantCode: String


  description: String


  sellingPlansToCreate: [SellingPlanInput!]


  sellingPlansToUpdate: [SellingPlanInput!]


  sellingPlansToDelete: [ID!]


  options: [String!]


  position: Int
}


type SellingPlanGroupRemoveProductsPayload {

  removedProductIds: [ID!]


  userErrors: [SellingPlanGroupUserError!]!
}


type SellingPlanGroupRemoveProductVariantsPayload {

  removedProductVariantIds: [ID!]


  userErrors: [SellingPlanGroupUserError!]!
}


input SellingPlanGroupResourceInput {

  productVariantIds: [ID!]


  productIds: [ID!]
}


enum SellingPlanGroupSortKeys {

  NAME


  UPDATED_AT


  CREATED_AT


  ID


  RELEVANCE
}


type SellingPlanGroupUpdatePayload {

  deletedSellingPlanIds: [ID!]


  sellingPlanGroup: SellingPlanGroup


  userErrors: [SellingPlanGroupUserError!]!
}


type SellingPlanGroupUserError implements DisplayableError {

  code: SellingPlanGroupUserErrorCode


  field: [String!]


  message: String!
}


enum SellingPlanGroupUserErrorCode {

  BLANK


  EQUAL_TO


  GREATER_THAN


  GREATER_THAN_OR_EQUAL_TO


  INCLUSION


  INVALID


  LESS_THAN


  LESS_THAN_OR_EQUAL_TO


  NOT_A_NUMBER


  NOT_FOUND


  PRESENT


  TAKEN


  TOO_BIG


  TOO_LONG


  TOO_SHORT


  WRONG_LENGTH


  SELLING_PLAN_COUNT_UPPER_BOUND


  SELLING_PLAN_COUNT_LOWER_BOUND


  SELLING_PLAN_MAX_CYCLES_MUST_BE_GREATER_THAN_MIN_CYCLES


  SELLING_PLAN_BILLING_AND_DELIVERY_POLICY_ANCHORS_MUST_BE_EQUAL


  SELLING_PLAN_BILLING_CYCLE_MUST_BE_A_MULTIPLE_OF_DELIVERY_CYCLE


  SELLING_PLAN_PRICING_POLICIES_MUST_CONTAIN_A_FIXED_PRICING_POLICY


  SELLING_PLAN_MISSING_OPTION2_LABEL_ON_PARENT_GROUP


  SELLING_PLAN_MISSING_OPTION3_LABEL_ON_PARENT_GROUP


  SELLING_PLAN_OPTION2_REQUIRED_AS_DEFINED_ON_PARENT_GROUP


  SELLING_PLAN_OPTION3_REQUIRED_AS_DEFINED_ON_PARENT_GROUP


  SELLING_PLAN_PRICING_POLICIES_LIMIT


  RESOURCE_LIST_CONTAINS_INVALID_IDS


  PRODUCT_VARIANT_DOES_NOT_EXIST


  PRODUCT_DOES_NOT_EXIST


  GROUP_DOES_NOT_EXIST


  GROUP_COULD_NOT_BE_DELETED


  ERROR_ADDING_RESOURCE_TO_GROUP


  SELLING_PLAN_DELIVERY_POLICY_MISSING


  SELLING_PLAN_BILLING_POLICY_MISSING


  PLAN_DOES_NOT_EXIST


  PLAN_ID_MUST_BE_SPECIFIED_TO_UPDATE


  ONLY_NEED_ONE_BILLING_POLICY_TYPE


  ONLY_NEED_ONE_DELIVERY_POLICY_TYPE


  ONLY_NEED_ONE_PRICING_POLICY_TYPE


  BILLING_AND_DELIVERY_POLICY_TYPES_MUST_BE_THE_SAME


  ONLY_NEED_ONE_PRICING_POLICY_VALUE


  PRICING_POLICY_ADJUSTMENT_VALUE_AND_TYPE_MUST_MATCH


  SELLING_PLAN_DUPLICATE_NAME


  SELLING_PLAN_DUPLICATE_OPTIONS


  SELLING_PLAN_FIXED_PRICING_POLICIES_LIMIT


  REMAINING_BALANCE_CHARGE_EXACT_TIME_REQUIRED


  CHECKOUT_CHARGE_VALUE_AND_TYPE_MUST_MATCH


  ONLY_NEED_ONE_CHECKOUT_CHARGE_VALUE


  REMAINING_BALANCE_CHARGE_EXACT_TIME_NOT_ALLOWED


  REMAINING_BALANCE_CHARGE_TIME_AFTER_CHECKOUT_MUST_BE_GREATER_THAN_ZERO


  REMAINING_BALANCE_CHARGE_TRIGGER_ON_FULL_CHECKOUT


  REMAINING_BALANCE_CHARGE_TRIGGER_NO_REMAINING_BALANCE_ON_PARTIAL_PERCENTAGE_CHECKOUT_CHARGE


  REMAINING_BALANCE_CHARGE_TRIGGER_NO_REMAINING_BALANCE_ON_PRICE_CHECKOUT_CHARGE


  FULFILLMENT_EXACT_TIME_REQUIRED


  FULFILLMENT_EXACT_TIME_NOT_ALLOWED


  SELLING_PLAN_ANCHORS_NOT_ALLOWED


  SELLING_PLAN_ANCHORS_REQUIRED


  ONLY_ONE_OF_FIXED_OR_RECURRING_BILLING


  ONLY_ONE_OF_FIXED_OR_RECURRING_DELIVERY


  BILLING_POLICY_INTERVAL_TOO_LARGE


  DELIVERY_POLICY_INTERVAL_TOO_LARGE
}


input SellingPlanInput {

  id: ID


  name: String


  description: String


  billingPolicy: SellingPlanBillingPolicyInput


  deliveryPolicy: SellingPlanDeliveryPolicyInput


  inventoryPolicy: SellingPlanInventoryPolicyInput


  pricingPolicies: [SellingPlanPricingPolicyInput!]


  options: [String!]


  position: Int


  category: SellingPlanCategory
}


enum SellingPlanInterval {

  DAY


  WEEK


  MONTH


  YEAR
}


type SellingPlanInventoryPolicy {

  reserve: SellingPlanReserve!
}


input SellingPlanInventoryPolicyInput {

  reserve: SellingPlanReserve
}


union SellingPlanPricingPolicy = SellingPlanFixedPricingPolicy | SellingPlanRecurringPricingPolicy


enum SellingPlanPricingPolicyAdjustmentType {

  PERCENTAGE


  FIXED_AMOUNT


  PRICE
}


union SellingPlanPricingPolicyAdjustmentValue = MoneyV2 | SellingPlanPricingPolicyPercentageValue


interface SellingPlanPricingPolicyBase {

  adjustmentType: SellingPlanPricingPolicyAdjustmentType!


  adjustmentValue: SellingPlanPricingPolicyAdjustmentValue!
}


input SellingPlanPricingPolicyInput {

  recurring: SellingPlanRecurringPricingPolicyInput


  fixed: SellingPlanFixedPricingPolicyInput
}


type SellingPlanPricingPolicyPercentageValue {

  percentage: Float!
}


input SellingPlanPricingPolicyValueInput {

  percentage: Float


  fixedValue: Decimal
}


type SellingPlanRecurringBillingPolicy {

  anchors: [SellingPlanAnchor!]!


  createdAt: DateTime!


  interval: SellingPlanInterval!


  intervalCount: Int!


  maxCycles: Int


  minCycles: Int
}


input SellingPlanRecurringBillingPolicyInput {

  interval: SellingPlanInterval


  intervalCount: Int


  anchors: [SellingPlanAnchorInput!]


  minCycles: Int


  maxCycles: Int
}


type SellingPlanRecurringDeliveryPolicy {

  anchors: [SellingPlanAnchor!]!


  createdAt: DateTime!


  cutoff: Int


  intent: SellingPlanRecurringDeliveryPolicyIntent!


  interval: SellingPlanInterval!


  intervalCount: Int!


  preAnchorBehavior: SellingPlanRecurringDeliveryPolicyPreAnchorBehavior!
}


input SellingPlanRecurringDeliveryPolicyInput {

  interval: SellingPlanInterval


  intervalCount: Int


  anchors: [SellingPlanAnchorInput!]


  cutoff: Int


  intent: SellingPlanRecurringDeliveryPolicyIntent


  preAnchorBehavior: SellingPlanRecurringDeliveryPolicyPreAnchorBehavior
}


enum SellingPlanRecurringDeliveryPolicyIntent {

  FULFILLMENT_BEGIN
}


enum SellingPlanRecurringDeliveryPolicyPreAnchorBehavior {

  ASAP


  NEXT
}


type SellingPlanRecurringPricingPolicy implements SellingPlanPricingPolicyBase {

  adjustmentType: SellingPlanPricingPolicyAdjustmentType!


  adjustmentValue: SellingPlanPricingPolicyAdjustmentValue!


  afterCycle: Int


  createdAt: DateTime!
}


input SellingPlanRecurringPricingPolicyInput {

  id: ID


  adjustmentType: SellingPlanPricingPolicyAdjustmentType


  adjustmentValue: SellingPlanPricingPolicyValueInput


  afterCycle: Int!
}


enum SellingPlanRemainingBalanceChargeTrigger {

  NO_REMAINING_BALANCE


  EXACT_TIME


  TIME_AFTER_CHECKOUT
}


enum SellingPlanReserve {

  ON_FULFILLMENT


  ON_SALE
}


type SEO {

  description: String


  title: String
}


input SEOInput {

  title: String


  description: String
}


type ServerPixel implements Node {

  id: ID!


  status: ServerPixelStatus


  webhookEndpointAddress: String
}


type ServerPixelCreatePayload {

  serverPixel: ServerPixel


  userErrors: [ErrorsServerPixelUserError!]!
}


type ServerPixelDeletePayload {

  deletedServerPixelId: ID


  userErrors: [ErrorsServerPixelUserError!]!
}


enum ServerPixelStatus {

  CONNECTED


  DISCONNECTED_UNCONFIGURED


  DISCONNECTED_CONFIGURED
}


enum ShippingDiscountClass {

  SHIPPING
}


type ShippingLabel implements Node {

  cancellable: Boolean!


  id: ID!


  location: Location


  printed: Boolean!
}


type ShippingLine {

  carrierIdentifier: String


  code: String


  custom: Boolean!


  deliveryCategory: String


  discountAllocations: [DiscountAllocation!]!


  discountedPrice: MoneyV2! @deprecated(reason: "Use `discountedPriceSet` instead.")


  discountedPriceSet: MoneyBag!


  id: ID


  originalPrice: MoneyV2! @deprecated(reason: "Use `originalPriceSet` instead.")


  originalPriceSet: MoneyBag!


  phone: String


  price: Money! @deprecated(reason: "Use `originalPriceSet` instead.")


  requestedFulfillmentService: FulfillmentService


  shippingRateHandle: String


  source: String


  taxLines: [TaxLine!]!


  title: String!
}


type ShippingLineConnection {

  edges: [ShippingLineEdge!]!


  nodes: [ShippingLine!]!


  pageInfo: PageInfo!
}


type ShippingLineEdge {

  cursor: String!


  node: ShippingLine!
}


input ShippingLineInput {

  price: Money


  shippingRateHandle: String


  title: String
}


type ShippingLineSale implements Sale {

  actionType: SaleActionType!


  id: ID!


  lineType: SaleLineType!


  quantity: Int


  shippingLine: ShippingLine


  taxes: [SaleTax!]!


  totalAmount: MoneyBag!


  totalDiscountAmountAfterTaxes: MoneyBag!


  totalDiscountAmountBeforeTaxes: MoneyBag!


  totalTaxAmount: MoneyBag!
}


type ShippingMethod {

  code: String!


  label: String!
}


type ShippingPackageDeletePayload {

  deletedId: ID


  userErrors: [UserError!]!
}


type ShippingPackageMakeDefaultPayload {

  userErrors: [UserError!]!
}


enum ShippingPackageType {

  BOX


  FLAT_RATE


  ENVELOPE


  SOFT_PACK
}


type ShippingPackageUpdatePayload {

  userErrors: [UserError!]!
}


type ShippingRate {

  handle: String!


  price: MoneyV2!


  title: String!
}


type ShippingRefund {

  amount: Money! @deprecated(reason: "Use `amountSet` instead.")


  amountSet: MoneyBag!


  maximumRefundable: Money! @deprecated(reason: "Use `maximumRefundableSet` instead.")


  maximumRefundableSet: MoneyBag!


  tax: Money! @deprecated(reason: "Use `taxSet` instead.")


  taxSet: MoneyBag!
}


input ShippingRefundInput {

  amount: Money


  fullRefund: Boolean
}


type Shop implements HasMetafields & HasPublishedTranslations & Node {

  alerts: [ShopAlert!]!


  allProductCategories: [ProductCategory!]!


  analyticsToken: String! @deprecated(reason: "Not supported anymore.")


  assignedFulfillmentOrders(

    assignmentStatus: FulfillmentOrderAssignmentStatus


    locationIds: [ID!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: FulfillmentOrderSortKeys = ID
  ): FulfillmentOrderConnection!


  availableChannelApps(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): AppConnection!


  billingAddress: ShopAddress!


  channelCount: Int! @deprecated(reason: "Use `publicationCount` instead.")


  channelDefinitionsForInstalledChannels: [AvailableChannelDefinitionsByChannel!]!


  channels(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ChannelConnection! @deprecated(reason: "Use `QueryRoot.channels` instead.")


  checkoutApiSupported: Boolean!


  collectionByHandle(

    handle: String!
  ): Collection @deprecated(reason: "Use `QueryRoot.collectionByHandle` instead.")


  collectionSavedSearches(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SavedSearchConnection! @deprecated(reason: "Use `QueryRoot.collectionSavedSearches` instead.")


  collections(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: CollectionSortKeys = ID


    query: String


    savedSearchId: ID
  ): CollectionConnection! @deprecated(reason: "Use `QueryRoot.collections` instead.")


  contactEmail: String!


  countriesInShippingZones: CountriesInShippingZones!


  currencyCode: CurrencyCode!


  currencyFormats: CurrencyFormats!


  currencySettings(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): CurrencySettingConnection!


  customerAccounts: ShopCustomerAccountsSetting!


  customerAccountsV2: CustomerAccountsV2!


  customerSavedSearches(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: CustomerSavedSearchSortKeys = ID


    query: String
  ): SavedSearchConnection! @deprecated(reason: "Use `QueryRoot.customerSavedSearches` instead.")


  customerTags(

    first: Int!
  ): StringConnection!


  customers(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: CustomerSortKeys = ID


    query: String
  ): CustomerConnection! @deprecated(reason: "Use `QueryRoot.customers` instead.")


  description: String


  domains: [Domain!]! @deprecated(reason: "Use `domainsPaginated` instead.")


  draftOrderSavedSearches(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SavedSearchConnection! @deprecated(reason: "Use `QueryRoot.draftOrderSavedSearches` instead.")


  draftOrderTags(

    first: Int!
  ): StringConnection!


  draftOrders(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: DraftOrderSortKeys = ID


    query: String
  ): DraftOrderConnection! @deprecated(reason: "Use `QueryRoot.draftOrders` instead.")


  email: String!


  enabledPresentmentCurrencies: [CurrencyCode!]!


  features: ShopFeatures!


  fulfillmentOrders(

    includeClosed: Boolean = false


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: FulfillmentOrderSortKeys = ID


    query: String
  ): FulfillmentOrderConnection! @deprecated(reason: "Use `QueryRoot.fulfillmentOrders` instead.")


  fulfillmentServices: [FulfillmentService!]!


  ianaTimezone: String!


  id: ID!


  inventoryItems(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    query: String
  ): InventoryItemConnection! @deprecated(reason: "Use `QueryRoot.inventoryItems` instead.")


  limitedPendingOrderCount: LimitedPendingOrderCount!


  locations(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: LocationSortKeys = NAME


    query: String


    includeLegacy: Boolean = false


    includeInactive: Boolean = false
  ): LocationConnection! @deprecated(reason: "Use `QueryRoot.locations` instead.")


  marketingEvents(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: MarketingEventSortKeys = ID


    query: String
  ): MarketingEventConnection! @deprecated(reason: "Use `QueryRoot.marketingEvents` instead.")


  merchantApprovalSignals: MerchantApprovalSignals


  metafield(

    namespace: String


    key: String!
  ): Metafield


  metafields(

    namespace: String


    keys: [String!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  myshopifyDomain: String!


  name: String!


  navigationSettings: [NavigationItem!]!


  orderNumberFormatPrefix: String!


  orderNumberFormatSuffix: String!


  orderSavedSearches(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SavedSearchConnection! @deprecated(reason: "Use `QueryRoot.orderSavedSearches` instead.")


  orderTags(

    first: Int!


    sort: ShopTagSort = ALPHABETICAL
  ): StringConnection!


  orders(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: OrderSortKeys = PROCESSED_AT


    query: String
  ): OrderConnection! @deprecated(reason: "Use `QueryRoot.orders` instead.")


  paymentSettings: PaymentSettings!


  pendingOrderCount: Int! @deprecated(reason: "Use `limitedPendingOrderCount` instead.")


  plan: ShopPlan!


  priceRuleSavedSearches(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SavedSearchConnection! @deprecated(reason: "Use `QueryRoot.priceRuleSavedSearches` instead.")


  priceRules(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: PriceRuleSortKeys = ID


    query: String


    savedSearchId: ID
  ): PriceRuleConnection! @deprecated(reason: "Use `QueryRoot.priceRules` instead.")


  primaryDomain: Domain!


  privateMetafield(

    namespace: String!


    key: String!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  productByHandle(

    handle: String!
  ): Product @deprecated(reason: "Use `QueryRoot.productByHandle` instead.")


  productImages(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: ProductImageSortKeys = CREATED_AT
  ): ImageConnection! @deprecated(reason: "Use `files` instead. See [filesQuery](https://shopify.dev/docs/api/admin-graphql/latest/queries/files) and its [query](https://shopify.dev/docs/api/admin-graphql/2024-01/queries/files#argument-query) argument for more information.")


  productSavedSearches(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SavedSearchConnection! @deprecated(reason: "Use `QueryRoot.productSavedSearches` instead.")


  productTags(

    first: Int!
  ): StringConnection!


  productTypes(

    first: Int!
  ): StringConnection!


  productVariants(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: ProductVariantSortKeys = ID


    query: String
  ): ProductVariantConnection! @deprecated(reason: "Use `QueryRoot.productVariants` instead.")


  productVendors(

    first: Int!
  ): StringConnection!


  products(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: ProductSortKeys = ID


    query: String


    savedSearchId: ID
  ): ProductConnection! @deprecated(reason: "Use `QueryRoot.products`.")


  publicationCount: Int!


  resourceLimits: ShopResourceLimits!


  richTextEditorUrl: URL!


  search(

    query: String!


    types: [SearchResultType!]


    first: Int!


    after: String
  ): SearchResultConnection!


  searchFilters: SearchFilterOptions!


  setupRequired: Boolean!


  shipsToCountries: [CountryCode!]!


  shopPolicies: [ShopPolicy!]!


  staffMembers(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): StaffMemberConnection!


  storefrontAccessTokens(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): StorefrontAccessTokenConnection!


  storefrontUrl: URL! @deprecated(reason: "Use `url` instead.")


  taxShipping: Boolean!


  taxesIncluded: Boolean!


  timezoneAbbreviation: String!


  timezoneOffset: String!


  timezoneOffsetMinutes: Int!


  transactionalSmsDisabled: Boolean!


  translations(

    locale: String!


    marketId: ID
  ): [Translation!]!


  unitSystem: UnitSystem!


  uploadedImagesByIds(

    imageIds: [ID!]!
  ): [Image!]!


  url: URL!


  weightUnit: WeightUnit!
}


type ShopAddress implements Node {

  address1: String


  address2: String


  city: String


  company: String


  coordinatesValidated: Boolean!


  country: String


  countryCode: String @deprecated(reason: "Use `countryCodeV2` instead.")


  countryCodeV2: CountryCode


  firstName: String @deprecated(reason: "Always null in this context.")


  formatted(

    withCompany: Boolean = true
  ): [String!]!


  formattedArea: String


  id: ID!


  lastName: String @deprecated(reason: "Always null in this context.")


  latitude: Float


  longitude: Float


  name: String @deprecated(reason: "Always null in this context.")


  phone: String


  province: String


  provinceCode: String


  zip: String
}


type ShopAlert {

  action: ShopAlertAction!


  description: String!
}


type ShopAlertAction {

  title: String!


  url: URL!
}


type ShopBillingPreferences {

  currency: CurrencyCode!
}


enum ShopBranding {

  SHOPIFY_GOLD


  SHOPIFY_PLUS


  ROGERS


  SHOPIFY
}


enum ShopCustomerAccountsSetting {
  REQUIRED
  OPTIONAL
  DISABLED
}


type ShopFeatures {

  avalaraAvatax: Boolean!


  branding: ShopBranding!


  bundles: BundlesFeature!


  captcha: Boolean!


  captchaExternalDomains: Boolean!


  cartTransform: CartTransformFeature!


  deliveryProfiles: Boolean! @deprecated(reason: "Delivery profiles are now 100% enabled across Shopify.")


  dynamicRemarketing: Boolean!


  eligibleForSubscriptionMigration: Boolean!


  eligibleForSubscriptions: Boolean!


  giftCards: Boolean!


  harmonizedSystemCode: Boolean!


  internationalDomains: Boolean! @deprecated(reason: "All shops have international domains through Shopify Markets.")


  internationalPriceOverrides: Boolean!


  internationalPriceRules: Boolean!


  legacySubscriptionGatewayEnabled: Boolean!


  liveView: Boolean!


  multiLocation: Boolean! @deprecated(reason: "All shops support multi-location inventory. Use `QueryRoot.locations` to determine whether shop has more than one location.\n")


  onboardingVisual: Boolean!


  paypalExpressSubscriptionGatewayStatus: PaypalExpressSubscriptionsGatewayStatus!


  reports: Boolean!


  sellsSubscriptions: Boolean!


  shopifyPlus: Boolean! @deprecated(reason: "Use Shop.plan.shopifyPlus instead.")


  showMetrics: Boolean!


  storefront: Boolean!


  usingShopifyBalance: Boolean!
}


type ShopifyFunction {

  apiType: String!


  apiVersion: String!


  app: App!


  appBridge: FunctionsAppBridge!


  appKey: String!


  description: String


  id: String!


  inputQuery: String


  title: String!


  useCreationUi: Boolean!
}


type ShopifyFunctionConnection {

  edges: [ShopifyFunctionEdge!]!


  nodes: [ShopifyFunction!]!


  pageInfo: PageInfo!
}


type ShopifyFunctionEdge {

  cursor: String!


  node: ShopifyFunction!
}


type ShopifyPaymentsAccount implements Node {

  activated: Boolean!


  balance: [MoneyV2!]!


  balanceTransactions(

    hideTransfers: Boolean = false


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: BalanceTransactionSortKeys = PROCESSED_AT


    query: String


    savedSearchId: ID
  ): ShopifyPaymentsBalanceTransactionConnection!


  bankAccounts(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ShopifyPaymentsBankAccountConnection!


  chargeStatementDescriptor: String @deprecated(reason: "Use `chargeStatementDescriptors` instead.")


  chargeStatementDescriptors: ShopifyPaymentsChargeStatementDescriptor


  country: String!


  defaultCurrency: CurrencyCode!


  disputes(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    query: String
  ): ShopifyPaymentsDisputeConnection!


  fraudSettings: ShopifyPaymentsFraudSettings!


  id: ID!


  notificationSettings: ShopifyPaymentsNotificationSettings!


  onboardable: Boolean!


  payoutSchedule: ShopifyPaymentsPayoutSchedule!


  payoutStatementDescriptor: String


  payouts(

    transactionType: ShopifyPaymentsPayoutTransactionType


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ShopifyPaymentsPayoutConnection!


  permittedVerificationDocuments: [ShopifyPaymentsVerificationDocument!]!


  verifications: [ShopifyPaymentsVerification!]!
}


type ShopifyPaymentsAdjustmentOrder {

  amount: MoneyV2!


  link: URL!


  name: String!
}


type ShopifyPaymentsBalanceTransaction implements Node {

  adjustmentsOrders: [ShopifyPaymentsAdjustmentOrder!]!


  id: ID!


  net: MoneyV2!


  transactionDate: DateTime!
}


type ShopifyPaymentsBalanceTransactionConnection {

  edges: [ShopifyPaymentsBalanceTransactionEdge!]!


  nodes: [ShopifyPaymentsBalanceTransaction!]!


  pageInfo: PageInfo!
}


type ShopifyPaymentsBalanceTransactionEdge {

  cursor: String!


  node: ShopifyPaymentsBalanceTransaction!
}


type ShopifyPaymentsBankAccount implements Node {

  accountNumber: String!


  accountNumberLastDigits: String!


  bankName: String


  country: CountryCode!


  createdAt: DateTime!


  currency: CurrencyCode!


  id: ID!


  payouts(

    transactionType: ShopifyPaymentsPayoutTransactionType


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): ShopifyPaymentsPayoutConnection!


  routingNumber: String!


  status: ShopifyPaymentsBankAccountStatus!
}


type ShopifyPaymentsBankAccountConnection {

  edges: [ShopifyPaymentsBankAccountEdge!]!


  nodes: [ShopifyPaymentsBankAccount!]!


  pageInfo: PageInfo!
}


type ShopifyPaymentsBankAccountEdge {

  cursor: String!


  node: ShopifyPaymentsBankAccount!
}


enum ShopifyPaymentsBankAccountStatus {

  NEW


  VALIDATED


  VERIFIED


  ERRORED
}


interface ShopifyPaymentsChargeStatementDescriptor {

  default: String


  prefix: String!
}


type ShopifyPaymentsDefaultChargeStatementDescriptor implements ShopifyPaymentsChargeStatementDescriptor {

  default: String


  prefix: String!
}


type ShopifyPaymentsDispute implements LegacyInteroperability & Node {

  amount: MoneyV2!


  evidenceDueBy: Date


  evidenceSentOn: Date


  finalizedOn: Date


  id: ID!


  initiatedAt: DateTime!


  legacyResourceId: UnsignedInt64!


  order: Order


  reasonDetails: ShopifyPaymentsDisputeReasonDetails!


  status: DisputeStatus!


  type: DisputeType!
}


type ShopifyPaymentsDisputeConnection {

  edges: [ShopifyPaymentsDisputeEdge!]!


  nodes: [ShopifyPaymentsDispute!]!


  pageInfo: PageInfo!
}


type ShopifyPaymentsDisputeEdge {

  cursor: String!


  node: ShopifyPaymentsDispute!
}


type ShopifyPaymentsDisputeEvidence implements Node {

  accessActivityLog: String


  billingAddress: MailingAddress


  cancellationPolicyDisclosure: String


  cancellationPolicyFile: ShopifyPaymentsDisputeFileUpload


  cancellationRebuttal: String


  customerCommunicationFile: ShopifyPaymentsDisputeFileUpload


  customerEmailAddress: String


  customerFirstName: String


  customerLastName: String


  customerPurchaseIp: String


  dispute: ShopifyPaymentsDispute!


  disputeFileUploads: [ShopifyPaymentsDisputeFileUpload!]!


  fulfillments: [ShopifyPaymentsDisputeFulfillment!]!


  id: ID!


  productDescription: String


  refundPolicyDisclosure: String


  refundPolicyFile: ShopifyPaymentsDisputeFileUpload


  refundRefusalExplanation: String


  serviceDocumentationFile: ShopifyPaymentsDisputeFileUpload


  shippingAddress: MailingAddress


  shippingDocumentationFile: ShopifyPaymentsDisputeFileUpload


  submitted: Boolean!


  uncategorizedFile: ShopifyPaymentsDisputeFileUpload


  uncategorizedText: String
}


enum ShopifyPaymentsDisputeEvidenceFileType {

  CUSTOMER_COMMUNICATION_FILE


  REFUND_POLICY_FILE


  CANCELLATION_POLICY_FILE


  UNCATEGORIZED_FILE


  SHIPPING_DOCUMENTATION_FILE


  SERVICE_DOCUMENTATION_FILE
}


input ShopifyPaymentsDisputeEvidenceUpdateInput {

  customerEmailAddress: String


  customerLastName: String


  customerFirstName: String


  shippingAddress: MailingAddressInput


  uncategorizedText: String


  accessActivityLog: String


  cancellationPolicyDisclosure: String


  cancellationRebuttal: String


  refundPolicyDisclosure: String


  refundRefusalExplanation: String


  cancellationPolicyFile: ShopifyPaymentsDisputeFileUploadUpdateInput


  customerCommunicationFile: ShopifyPaymentsDisputeFileUploadUpdateInput


  refundPolicyFile: ShopifyPaymentsDisputeFileUploadUpdateInput


  shippingDocumentationFile: ShopifyPaymentsDisputeFileUploadUpdateInput


  uncategorizedFile: ShopifyPaymentsDisputeFileUploadUpdateInput


  serviceDocumentationFile: ShopifyPaymentsDisputeFileUploadUpdateInput


  submitEvidence: Boolean = false
}


type ShopifyPaymentsDisputeFileUpload implements Node {

  disputeEvidenceType: ShopifyPaymentsDisputeEvidenceFileType


  fileSize: Int!


  fileType: String!


  id: ID!


  originalFileName: String


  url: URL!
}


input ShopifyPaymentsDisputeFileUploadUpdateInput {

  id: ID!


  destroy: Boolean = false
}


type ShopifyPaymentsDisputeFulfillment implements Node {

  id: ID!


  shippingCarrier: String


  shippingDate: Date


  shippingTrackingNumber: String
}


enum ShopifyPaymentsDisputeReason {

  FRAUDULENT


  GENERAL


  UNRECOGNIZED


  DUPLICATE


  SUBSCRIPTION_CANCELLED


  PRODUCT_UNACCEPTABLE


  PRODUCT_NOT_RECEIVED


  CREDIT_NOT_PROCESSED


  INCORRECT_ACCOUNT_DETAILS


  INSUFFICIENT_FUNDS


  BANK_CANNOT_PROCESS


  DEBIT_NOT_AUTHORIZED


  CUSTOMER_INITIATED
}


type ShopifyPaymentsDisputeReasonDetails {

  networkReasonCode: String


  reason: ShopifyPaymentsDisputeReason!
}


type ShopifyPaymentsExtendedAuthorization {

  extendedAuthorizationExpiresAt: DateTime!


  standardAuthorizationExpiresAt: DateTime!
}


type ShopifyPaymentsFraudSettings {

  declineChargeOnAvsFailure: Boolean!


  declineChargeOnCvcFailure: Boolean!
}


type ShopifyPaymentsJpChargeStatementDescriptor implements ShopifyPaymentsChargeStatementDescriptor {

  default: String


  kana: String


  kanji: String


  prefix: String!
}


type ShopifyPaymentsNotificationSettings {

  payouts: Boolean!
}


type ShopifyPaymentsPayout implements LegacyInteroperability & Node {

  bankAccount: ShopifyPaymentsBankAccount


  gross: MoneyV2! @deprecated(reason: "Use `net` instead.")


  id: ID!


  issuedAt: DateTime!


  legacyResourceId: UnsignedInt64!


  net: MoneyV2!


  status: ShopifyPaymentsPayoutStatus!


  summary: ShopifyPaymentsPayoutSummary!


  transactionType: ShopifyPaymentsPayoutTransactionType!
}


type ShopifyPaymentsPayoutConnection {

  edges: [ShopifyPaymentsPayoutEdge!]!


  nodes: [ShopifyPaymentsPayout!]!


  pageInfo: PageInfo!
}


type ShopifyPaymentsPayoutEdge {

  cursor: String!


  node: ShopifyPaymentsPayout!
}


enum ShopifyPaymentsPayoutInterval {

  DAILY


  WEEKLY


  MONTHLY


  MANUAL
}


type ShopifyPaymentsPayoutSchedule {

  interval: ShopifyPaymentsPayoutInterval!


  monthlyAnchor: Int


  weeklyAnchor: DayOfTheWeek
}


enum ShopifyPaymentsPayoutStatus {

  SCHEDULED


  IN_TRANSIT


  PAID


  FAILED


  CANCELED
}


type ShopifyPaymentsPayoutSummary {

  adjustmentsFee: MoneyV2!


  adjustmentsGross: MoneyV2!


  chargesFee: MoneyV2!


  chargesGross: MoneyV2!


  refundsFee: MoneyV2!


  refundsFeeGross: MoneyV2!


  reservedFundsFee: MoneyV2!


  reservedFundsGross: MoneyV2!


  retriedPayoutsFee: MoneyV2!


  retriedPayoutsGross: MoneyV2!
}


enum ShopifyPaymentsPayoutTransactionType {

  DEPOSIT


  WITHDRAWAL
}


type ShopifyPaymentsRefundSet {

  acquirerReferenceNumber: String
}


type ShopifyPaymentsTransactionSet {

  extendedAuthorizationSet: ShopifyPaymentsExtendedAuthorization


  refundSet: ShopifyPaymentsRefundSet
}


type ShopifyPaymentsVerification implements Node {

  id: ID!


  status: ShopifyPaymentsVerificationStatus!


  subject: ShopifyPaymentsVerificationSubject!
}


type ShopifyPaymentsVerificationDocument {

  backRequired: Boolean!


  frontRequired: Boolean!


  type: ShopifyPaymentsVerificationDocumentType!
}


enum ShopifyPaymentsVerificationDocumentType {

  DRIVERS_LICENSE


  GOVERNMENT_IDENTIFICATION


  PASSPORT
}


enum ShopifyPaymentsVerificationStatus {

  VERIFIED


  UNVERIFIED


  PENDING
}


type ShopifyPaymentsVerificationSubject {

  familyName: String!


  givenName: String!
}


enum ShopifyProtectEligibilityStatus {

  PENDING


  ELIGIBLE


  NOT_ELIGIBLE
}


type ShopifyProtectOrderEligibility {

  status: ShopifyProtectEligibilityStatus!
}


type ShopifyProtectOrderSummary {

  eligibility: ShopifyProtectOrderEligibility!


  status: ShopifyProtectStatus!
}


enum ShopifyProtectStatus {

  PENDING


  ACTIVE


  INACTIVE


  PROTECTED


  NOT_PROTECTED
}


interface ShopifyqlResponse {

  parseErrors: [ParseError!]


  tableData: TableData
}


type ShopLocale {

  locale: String!


  marketWebPresences: [MarketWebPresence!]!


  name: String!


  primary: Boolean!


  published: Boolean!
}


type ShopLocaleDisablePayload {

  locale: String


  userErrors: [UserError!]!
}


type ShopLocaleEnablePayload {

  shopLocale: ShopLocale


  userErrors: [UserError!]!
}


input ShopLocaleInput {

  published: Boolean


  marketWebPresenceIds: [ID!]
}


type ShopLocaleUpdatePayload {

  shopLocale: ShopLocale


  userErrors: [UserError!]!
}


type ShopPayInstallmentsPaymentDetails implements BasePaymentDetails {

  paymentMethodName: String
}


type ShopPlan {

  displayName: String!


  partnerDevelopment: Boolean!


  shopifyPlus: Boolean!
}


type ShopPolicy implements HasPublishedTranslations & Node {

  body: HTML!


  id: ID!


  translations(

    locale: String!


    marketId: ID
  ): [Translation!]!


  type: ShopPolicyType!


  url: URL!
}


enum ShopPolicyErrorCode {

  TOO_BIG
}


input ShopPolicyInput {

  type: ShopPolicyType!


  body: String!
}


enum ShopPolicyType {

  REFUND_POLICY


  SHIPPING_POLICY


  PRIVACY_POLICY


  TERMS_OF_SERVICE


  TERMS_OF_SALE


  LEGAL_NOTICE


  SUBSCRIPTION_POLICY


  CONTACT_INFORMATION
}


type ShopPolicyUpdatePayload {

  shopPolicy: ShopPolicy


  userErrors: [ShopPolicyUserError!]!
}


type ShopPolicyUserError implements DisplayableError {

  code: ShopPolicyErrorCode


  field: [String!]


  message: String!
}


type ShopResourceFeedbackCreatePayload {

  feedback: AppFeedback


  userErrors: [ShopResourceFeedbackCreateUserError!]!
}


type ShopResourceFeedbackCreateUserError implements DisplayableError {

  code: ShopResourceFeedbackCreateUserErrorCode


  field: [String!]


  message: String!
}


enum ShopResourceFeedbackCreateUserErrorCode {

  OUTDATED_FEEDBACK


  INVALID


  BLANK


  PRESENT
}


type ShopResourceLimits {

  locationLimit: Int!


  maxProductOptions: Int!


  maxProductVariants: Int!


  redirectLimitReached: Boolean!
}


enum ShopTagSort {

  ALPHABETICAL


  POPULAR
}


type StaffMember implements Node {

  active: Boolean!


  avatar(

    fallback: StaffMemberDefaultImage = DEFAULT
  ): Image!


  email: String!


  exists: Boolean!


  firstName: String


  id: ID!


  initials: [String!]


  isShopOwner: Boolean!


  lastName: String


  locale: String!


  name: String!


  phone: String


  privateData: StaffMemberPrivateData!
}


type StaffMemberConnection {

  edges: [StaffMemberEdge!]!


  nodes: [StaffMember!]!


  pageInfo: PageInfo!
}


enum StaffMemberDefaultImage {

  DEFAULT


  TRANSPARENT


  NOT_FOUND
}


type StaffMemberEdge {

  cursor: String!


  node: StaffMember!
}


enum StaffMemberPermission {

  APPLICATIONS


  CHANNELS


  CUSTOMERS


  DASHBOARD


  DOMAINS


  DRAFT_ORDERS


  EDIT_ORDERS


  FULL @deprecated(reason: "Use the list of the staff member's explicit permissions returned in the `StaffMember.permissions.userPermissions` field instead of `full` permission.")


  GIFT_CARDS


  LINKS


  LOCATIONS


  MARKETING


  MARKETING_SECTION


  ORDERS


  OVERVIEWS


  PAGES


  PAY_ORDERS_BY_VAULTED_CARD


  PREFERENCES


  PRODUCTS


  REPORTS


  THEMES


  TRANSLATIONS @deprecated(reason: "Unused.")
}


type StaffMemberPrivateData {

  accountSettingsUrl: URL!


  createdAt: DateTime!


  permissions: [StaffMemberPermission!]! @deprecated(reason: "Use StaffMember.permissions.userPermissions instead")
}


type StagedMediaUploadTarget {

  parameters: [StagedUploadParameter!]!


  resourceUrl: URL


  url: URL
}


enum StagedUploadHttpMethodType {

  POST


  PUT
}


input StagedUploadInput {

  resource: StagedUploadTargetGenerateUploadResource!


  filename: String!


  mimeType: String!


  httpMethod: StagedUploadHttpMethodType = PUT


  fileSize: UnsignedInt64
}


type StagedUploadParameter {

  name: String!


  value: String!
}


type StagedUploadsCreatePayload {

  stagedTargets: [StagedMediaUploadTarget!]


  userErrors: [UserError!]!
}


type StagedUploadTarget {

  parameters: [ImageUploadParameter!]!


  url: String!
}


input StagedUploadTargetGenerateInput {

  resource: StagedUploadTargetGenerateUploadResource!


  filename: String!


  mimeType: String!


  httpMethod: StagedUploadHttpMethodType = PUT


  fileSize: UnsignedInt64
}


type StagedUploadTargetGeneratePayload {

  parameters: [MutationsStagedUploadTargetGenerateUploadParameter!]!


  url: String!


  userErrors: [UserError!]!
}


enum StagedUploadTargetGenerateUploadResource {

  COLLECTION_IMAGE


  FILE


  IMAGE


  MODEL_3D


  PRODUCT_IMAGE


  SHOP_IMAGE


  VIDEO


  BULK_MUTATION_VARIABLES


  RETURN_LABEL


  URL_REDIRECT_IMPORT
}


type StagedUploadTargetsGeneratePayload {

  urls: [StagedUploadTarget!]


  userErrors: [UserError!]!
}


input StageImageInput {

  resource: StagedUploadTargetGenerateUploadResource!


  filename: String!


  mimeType: String!


  httpMethod: StagedUploadHttpMethodType = PUT
}


type StandardizedProductType {

  productTaxonomyNode: ProductTaxonomyNode
}


input StandardizedProductTypeInput {

  productTaxonomyNodeId: ID!
}


type StandardMetafieldDefinitionEnablePayload {

  createdDefinition: MetafieldDefinition


  userErrors: [StandardMetafieldDefinitionEnableUserError!]!
}


type StandardMetafieldDefinitionEnableUserError implements DisplayableError {

  code: StandardMetafieldDefinitionEnableUserErrorCode


  field: [String!]


  message: String!
}


enum StandardMetafieldDefinitionEnableUserErrorCode {

  INVALID


  TAKEN


  TEMPLATE_NOT_FOUND


  LIMIT_EXCEEDED


  UNSTRUCTURED_ALREADY_EXISTS


  TYPE_NOT_ALLOWED_FOR_CONDITIONS
}


type StandardMetafieldDefinitionTemplate implements Node {

  description: String


  id: ID!


  key: String!


  name: String!


  namespace: String!


  ownerTypes: [MetafieldOwnerType!]!


  type: MetafieldDefinitionType!


  validations: [MetafieldDefinitionValidation!]!


  visibleToStorefrontApi: Boolean!
}


type StandardMetafieldDefinitionTemplateConnection {

  edges: [StandardMetafieldDefinitionTemplateEdge!]!


  nodes: [StandardMetafieldDefinitionTemplate!]!


  pageInfo: PageInfo!
}


type StandardMetafieldDefinitionTemplateEdge {

  cursor: String!


  node: StandardMetafieldDefinitionTemplate!
}


type StandardMetaobjectDefinitionEnablePayload {

  metaobjectDefinition: MetaobjectDefinition


  userErrors: [MetaobjectUserError!]!
}


type StorefrontAccessToken implements Node {

  accessScopes: [AccessScope!]!


  accessToken: String!


  createdAt: DateTime!


  id: ID!


  title: String!


  updatedAt: DateTime!
}


type StorefrontAccessTokenConnection {

  edges: [StorefrontAccessTokenEdge!]!


  nodes: [StorefrontAccessToken!]!


  pageInfo: PageInfo!
}


type StorefrontAccessTokenCreatePayload {

  shop: Shop!


  storefrontAccessToken: StorefrontAccessToken


  userErrors: [UserError!]!
}


input StorefrontAccessTokenDeleteInput {

  id: ID!
}


type StorefrontAccessTokenDeletePayload {

  deletedStorefrontAccessTokenId: ID


  userErrors: [UserError!]!
}


type StorefrontAccessTokenEdge {

  cursor: String!


  node: StorefrontAccessToken!
}


input StorefrontAccessTokenInput {

  title: String!
}


scalar StorefrontID


type StringConnection {

  edges: [StringEdge!]!


  pageInfo: PageInfo!
}


type StringEdge {

  cursor: String!


  node: String!
}


type SubscriptionAppliedCodeDiscount {

  id: ID!


  redeemCode: String!


  rejectionReason: SubscriptionDiscountRejectionReason
}


input SubscriptionAtomicLineInput {

  line: SubscriptionLineInput!


  discounts: [SubscriptionAtomicManualDiscountInput!]
}


input SubscriptionAtomicManualDiscountInput {

  title: String


  value: SubscriptionManualDiscountValueInput


  recurringCycleLimit: Int
}


type SubscriptionBillingAttempt implements Node {

  completedAt: DateTime


  createdAt: DateTime!


  errorCode: SubscriptionBillingAttemptErrorCode


  errorMessage: String


  id: ID!


  idempotencyKey: String!


  nextActionUrl: URL


  order: Order


  originTime: DateTime


  ready: Boolean!


  subscriptionContract: SubscriptionContract!
}


type SubscriptionBillingAttemptConnection {

  edges: [SubscriptionBillingAttemptEdge!]!


  nodes: [SubscriptionBillingAttempt!]!


  pageInfo: PageInfo!
}


type SubscriptionBillingAttemptCreatePayload {

  subscriptionBillingAttempt: SubscriptionBillingAttempt


  userErrors: [BillingAttemptUserError!]!
}


type SubscriptionBillingAttemptEdge {

  cursor: String!


  node: SubscriptionBillingAttempt!
}


enum SubscriptionBillingAttemptErrorCode {

  PAYMENT_METHOD_NOT_FOUND


  PAYMENT_PROVIDER_IS_NOT_ENABLED


  INVALID_PAYMENT_METHOD


  UNEXPECTED_ERROR


  EXPIRED_PAYMENT_METHOD


  PAYMENT_METHOD_DECLINED


  AUTHENTICATION_ERROR


  TEST_MODE


  BUYER_CANCELED_PAYMENT_METHOD


  CUSTOMER_NOT_FOUND


  CUSTOMER_INVALID


  INVALID_SHIPPING_ADDRESS


  INVALID_CUSTOMER_BILLING_AGREEMENT


  INVOICE_ALREADY_PAID


  PAYMENT_METHOD_INCOMPATIBLE_WITH_GATEWAY_CONFIG


  AMOUNT_TOO_SMALL


  INVENTORY_ALLOCATIONS_NOT_FOUND


  TRANSIENT_ERROR
}


input SubscriptionBillingAttemptInput {

  idempotencyKey: String!


  originTime: DateTime


  billingCycleSelector: SubscriptionBillingCycleSelector
}


enum SubscriptionBillingAttemptsSortKeys {

  CREATED_AT


  ID


  RELEVANCE
}


type SubscriptionBillingCycle {

  billingAttemptExpectedDate: DateTime!


  billingAttempts(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SubscriptionBillingAttemptConnection!


  cycleEndAt: DateTime!


  cycleIndex: Int!


  cycleStartAt: DateTime!


  edited: Boolean!


  editedContract: SubscriptionBillingCycleEditedContract


  skipped: Boolean!


  sourceContract: SubscriptionContract!


  status: SubscriptionBillingCycleBillingCycleStatus!
}


enum SubscriptionBillingCycleBillingCycleStatus {

  BILLED


  UNBILLED
}


type SubscriptionBillingCycleConnection {

  edges: [SubscriptionBillingCycleEdge!]!


  nodes: [SubscriptionBillingCycle!]!


  pageInfo: PageInfo!
}


type SubscriptionBillingCycleContractDraftCommitPayload {

  contract: SubscriptionBillingCycleEditedContract


  userErrors: [SubscriptionDraftUserError!]!
}


type SubscriptionBillingCycleContractDraftConcatenatePayload {

  draft: SubscriptionDraft


  userErrors: [SubscriptionDraftUserError!]!
}


type SubscriptionBillingCycleContractEditPayload {

  draft: SubscriptionDraft


  userErrors: [SubscriptionDraftUserError!]!
}


type SubscriptionBillingCycleEdge {

  cursor: String!


  node: SubscriptionBillingCycle!
}


type SubscriptionBillingCycleEditDeletePayload {

  billingCycles: [SubscriptionBillingCycle!]


  userErrors: [SubscriptionBillingCycleUserError!]!
}


type SubscriptionBillingCycleEditedContract implements SubscriptionContractBase {

  app: App


  appAdminUrl: URL


  billingCycles(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: SubscriptionBillingCyclesSortKeys = CYCLE_INDEX
  ): SubscriptionBillingCycleConnection!


  createdAt: DateTime!


  currencyCode: CurrencyCode!


  customAttributes: [Attribute!]!


  customer: Customer


  customerPaymentMethod(

    showRevoked: Boolean = false
  ): CustomerPaymentMethod


  deliveryMethod: SubscriptionDeliveryMethod


  deliveryPrice: MoneyV2!


  discounts(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SubscriptionManualDiscountConnection!


  lineCount: Int!


  lines(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SubscriptionLineConnection!


  note: String


  orders(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): OrderConnection!


  updatedAt: DateTime!
}


type SubscriptionBillingCycleEditsDeletePayload {

  billingCycles: [SubscriptionBillingCycle!]


  userErrors: [SubscriptionBillingCycleUserError!]!
}


enum SubscriptionBillingCycleErrorCode {

  INVALID


  CYCLE_NOT_FOUND


  NO_CYCLE_EDITS


  INVALID_CYCLE_INDEX


  INVALID_DATE


  EMPTY_BILLING_CYCLE_EDIT_SCHEDULE_INPUT


  BILLING_DATE_SET_ON_SKIPPED


  OUT_OF_BOUNDS


  UPCOMING_CYCLE_LIMIT_EXCEEDED


  CYCLE_INDEX_OUT_OF_RANGE


  CYCLE_START_DATE_OUT_OF_RANGE


  INCOMPLETE_BILLING_ATTEMPTS
}


input SubscriptionBillingCycleInput {

  contractId: ID!


  selector: SubscriptionBillingCycleSelector!
}


input SubscriptionBillingCycleScheduleEditInput {

  skip: Boolean


  billingDate: DateTime


  reason: SubscriptionBillingCycleScheduleEditInputScheduleEditReason!
}


enum SubscriptionBillingCycleScheduleEditInputScheduleEditReason {

  BUYER_INITIATED


  MERCHANT_INITIATED


  DEV_INITIATED
}


type SubscriptionBillingCycleScheduleEditPayload {

  billingCycle: SubscriptionBillingCycle


  userErrors: [SubscriptionBillingCycleUserError!]!
}


input SubscriptionBillingCyclesDateRangeSelector {

  startDate: DateTime!


  endDate: DateTime!
}


input SubscriptionBillingCycleSelector {

  index: Int


  date: DateTime
}


input SubscriptionBillingCyclesIndexRangeSelector {

  startIndex: Int!


  endIndex: Int!
}


type SubscriptionBillingCycleSkipPayload {

  billingCycle: SubscriptionBillingCycle


  userErrors: [SubscriptionBillingCycleSkipUserError!]!
}


type SubscriptionBillingCycleSkipUserError implements DisplayableError {

  code: SubscriptionBillingCycleSkipUserErrorCode


  field: [String!]


  message: String!
}


enum SubscriptionBillingCycleSkipUserErrorCode {

  INVALID
}


enum SubscriptionBillingCyclesSortKeys {

  CYCLE_INDEX


  ID


  RELEVANCE
}


enum SubscriptionBillingCyclesTargetSelection {

  ALL
}


type SubscriptionBillingCycleUnskipPayload {

  billingCycle: SubscriptionBillingCycle


  userErrors: [SubscriptionBillingCycleUnskipUserError!]!
}


type SubscriptionBillingCycleUnskipUserError implements DisplayableError {

  code: SubscriptionBillingCycleUnskipUserErrorCode


  field: [String!]


  message: String!
}


enum SubscriptionBillingCycleUnskipUserErrorCode {

  INVALID
}


type SubscriptionBillingCycleUserError implements DisplayableError {

  code: SubscriptionBillingCycleErrorCode


  field: [String!]


  message: String!
}


type SubscriptionBillingPolicy {

  anchors: [SellingPlanAnchor!]!


  interval: SellingPlanInterval!


  intervalCount: Int!


  maxCycles: Int


  minCycles: Int
}


input SubscriptionBillingPolicyInput {

  interval: SellingPlanInterval!


  intervalCount: Int!


  minCycles: Int


  maxCycles: Int


  anchors: [SellingPlanAnchorInput!] = []
}


type SubscriptionContract implements Node & SubscriptionContractBase {

  app: App


  appAdminUrl: URL


  billingAttempts(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SubscriptionBillingAttemptConnection!


  billingPolicy: SubscriptionBillingPolicy!


  createdAt: DateTime!


  currencyCode: CurrencyCode!


  customAttributes: [Attribute!]!


  customer: Customer


  customerPaymentMethod(

    showRevoked: Boolean = false
  ): CustomerPaymentMethod


  deliveryMethod: SubscriptionDeliveryMethod


  deliveryPolicy: SubscriptionDeliveryPolicy!


  deliveryPrice: MoneyV2!


  discounts(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SubscriptionManualDiscountConnection!


  id: ID!


  lastPaymentStatus: SubscriptionContractLastPaymentStatus


  lineCount: Int!


  lines(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SubscriptionLineConnection!


  nextBillingDate: DateTime


  note: String


  orders(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): OrderConnection!


  originOrder: Order


  revisionId: UnsignedInt64!


  status: SubscriptionContractSubscriptionStatus!


  updatedAt: DateTime!
}


type SubscriptionContractActivatePayload {

  contract: SubscriptionContract


  userErrors: [SubscriptionContractStatusUpdateUserError!]!
}


input SubscriptionContractAtomicCreateInput {

  customerId: ID!


  nextBillingDate: DateTime!


  currencyCode: CurrencyCode!


  contract: SubscriptionDraftInput!


  lines: [SubscriptionAtomicLineInput!]!


  discountCodes: [String!] = []
}


type SubscriptionContractAtomicCreatePayload {

  contract: SubscriptionContract


  userErrors: [SubscriptionDraftUserError!]!
}


interface SubscriptionContractBase {

  app: App


  appAdminUrl: URL


  currencyCode: CurrencyCode!


  customAttributes: [Attribute!]!


  customer: Customer


  customerPaymentMethod(

    showRevoked: Boolean = false
  ): CustomerPaymentMethod


  deliveryMethod: SubscriptionDeliveryMethod


  deliveryPrice: MoneyV2!


  discounts(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SubscriptionManualDiscountConnection!


  lineCount: Int!


  lines(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SubscriptionLineConnection!


  note: String


  orders(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): OrderConnection!


  updatedAt: DateTime!
}


type SubscriptionContractCancelPayload {

  contract: SubscriptionContract


  userErrors: [SubscriptionContractStatusUpdateUserError!]!
}


type SubscriptionContractConnection {

  edges: [SubscriptionContractEdge!]!


  nodes: [SubscriptionContract!]!


  pageInfo: PageInfo!
}


input SubscriptionContractCreateInput {

  customerId: ID!


  nextBillingDate: DateTime!


  currencyCode: CurrencyCode!


  contract: SubscriptionDraftInput!
}


type SubscriptionContractCreatePayload {

  draft: SubscriptionDraft


  userErrors: [SubscriptionDraftUserError!]!
}


type SubscriptionContractEdge {

  cursor: String!


  node: SubscriptionContract!
}


enum SubscriptionContractErrorCode {

  INVALID
}


type SubscriptionContractExpirePayload {

  contract: SubscriptionContract


  userErrors: [SubscriptionContractStatusUpdateUserError!]!
}


type SubscriptionContractFailPayload {

  contract: SubscriptionContract


  userErrors: [SubscriptionContractStatusUpdateUserError!]!
}


enum SubscriptionContractLastPaymentStatus {

  SUCCEEDED


  FAILED
}


type SubscriptionContractPausePayload {

  contract: SubscriptionContract


  userErrors: [SubscriptionContractStatusUpdateUserError!]!
}


input SubscriptionContractProductChangeInput {

  productVariantId: ID


  currentPrice: Decimal
}


type SubscriptionContractProductChangePayload {

  contract: SubscriptionContract


  lineUpdated: SubscriptionLine


  userErrors: [SubscriptionDraftUserError!]!
}


type SubscriptionContractSetNextBillingDatePayload {

  contract: SubscriptionContract


  userErrors: [SubscriptionContractUserError!]!
}


enum SubscriptionContractStatusUpdateErrorCode {

  INVALID


  CONTRACT_TERMINATED
}


type SubscriptionContractStatusUpdateUserError implements DisplayableError {

  code: SubscriptionContractStatusUpdateErrorCode


  field: [String!]


  message: String!
}


enum SubscriptionContractSubscriptionStatus {

  ACTIVE


  PAUSED


  CANCELLED


  EXPIRED


  FAILED
}


type SubscriptionContractUpdatePayload {

  draft: SubscriptionDraft


  userErrors: [SubscriptionDraftUserError!]!
}


type SubscriptionContractUserError implements DisplayableError {

  code: SubscriptionContractErrorCode


  field: [String!]


  message: String!
}


type SubscriptionCyclePriceAdjustment {

  adjustmentType: SellingPlanPricingPolicyAdjustmentType!


  adjustmentValue: SellingPlanPricingPolicyAdjustmentValue!


  afterCycle: Int!


  computedPrice: MoneyV2!
}


union SubscriptionDeliveryMethod = SubscriptionDeliveryMethodLocalDelivery | SubscriptionDeliveryMethodPickup | SubscriptionDeliveryMethodShipping


input SubscriptionDeliveryMethodInput {

  shipping: SubscriptionDeliveryMethodShippingInput


  localDelivery: SubscriptionDeliveryMethodLocalDeliveryInput


  pickup: SubscriptionDeliveryMethodPickupInput
}


type SubscriptionDeliveryMethodLocalDelivery {

  address: SubscriptionMailingAddress!


  localDeliveryOption: SubscriptionDeliveryMethodLocalDeliveryOption!
}


input SubscriptionDeliveryMethodLocalDeliveryInput {

  address: MailingAddressInput


  localDeliveryOption: SubscriptionDeliveryMethodLocalDeliveryOptionInput
}


type SubscriptionDeliveryMethodLocalDeliveryOption {

  code: String


  description: String


  instructions: String


  phone: String!


  presentmentTitle: String


  title: String
}


input SubscriptionDeliveryMethodLocalDeliveryOptionInput {

  title: String


  presentmentTitle: String


  description: String


  code: String


  phone: String!


  instructions: String
}


type SubscriptionDeliveryMethodPickup {

  pickupOption: SubscriptionDeliveryMethodPickupOption!
}


input SubscriptionDeliveryMethodPickupInput {

  pickupOption: SubscriptionDeliveryMethodPickupOptionInput
}


type SubscriptionDeliveryMethodPickupOption {

  code: String


  description: String


  location: Location!


  presentmentTitle: String


  title: String
}


input SubscriptionDeliveryMethodPickupOptionInput {

  title: String


  presentmentTitle: String


  description: String


  code: String


  locationId: ID!
}


type SubscriptionDeliveryMethodShipping {

  address: SubscriptionMailingAddress!


  shippingOption: SubscriptionDeliveryMethodShippingOption!
}


input SubscriptionDeliveryMethodShippingInput {

  address: MailingAddressInput


  shippingOption: SubscriptionDeliveryMethodShippingOptionInput
}


type SubscriptionDeliveryMethodShippingOption {

  carrierService: DeliveryCarrierService @deprecated(reason: "This field has never been implemented.")


  code: String


  description: String


  presentmentTitle: String


  title: String
}


input SubscriptionDeliveryMethodShippingOptionInput {

  title: String


  presentmentTitle: String


  description: String


  code: String


  carrierServiceId: ID
}


union SubscriptionDeliveryOption = SubscriptionLocalDeliveryOption | SubscriptionPickupOption | SubscriptionShippingOption


union SubscriptionDeliveryOptionResult = SubscriptionDeliveryOptionResultFailure | SubscriptionDeliveryOptionResultSuccess


type SubscriptionDeliveryOptionResultFailure {

  message: String
}


type SubscriptionDeliveryOptionResultSuccess {

  deliveryOptions: [SubscriptionDeliveryOption!]!
}


type SubscriptionDeliveryPolicy {

  anchors: [SellingPlanAnchor!]!


  interval: SellingPlanInterval!


  intervalCount: Int!
}


input SubscriptionDeliveryPolicyInput {

  interval: SellingPlanInterval!


  intervalCount: Int!


  anchors: [SellingPlanAnchorInput!] = []
}


union SubscriptionDiscount = SubscriptionAppliedCodeDiscount | SubscriptionManualDiscount


type SubscriptionDiscountAllocation {

  amount: MoneyV2!


  discount: SubscriptionDiscount!
}


type SubscriptionDiscountConnection {

  edges: [SubscriptionDiscountEdge!]!


  nodes: [SubscriptionDiscount!]!


  pageInfo: PageInfo!
}


type SubscriptionDiscountEdge {

  cursor: String!


  node: SubscriptionDiscount!
}


type SubscriptionDiscountEntitledLines {

  all: Boolean!


  lines(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SubscriptionLineConnection!
}


type SubscriptionDiscountFixedAmountValue {

  amount: MoneyV2!


  appliesOnEachItem: Boolean!
}


type SubscriptionDiscountPercentageValue {

  percentage: Int!
}


enum SubscriptionDiscountRejectionReason {

  NOT_FOUND


  NO_ENTITLED_LINE_ITEMS


  QUANTITY_NOT_IN_RANGE


  PURCHASE_NOT_IN_RANGE


  CUSTOMER_NOT_ELIGIBLE


  USAGE_LIMIT_REACHED


  CUSTOMER_USAGE_LIMIT_REACHED


  CURRENTLY_INACTIVE


  NO_ENTITLED_SHIPPING_LINES


  INCOMPATIBLE_PURCHASE_TYPE


  INTERNAL_ERROR
}


union SubscriptionDiscountValue = SubscriptionDiscountFixedAmountValue | SubscriptionDiscountPercentageValue


type SubscriptionDraft implements Node {

  billingCycle: SubscriptionBillingCycle


  billingPolicy: SubscriptionBillingPolicy!


  concatenatedBillingCycles(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: SubscriptionBillingCyclesSortKeys = CYCLE_INDEX
  ): SubscriptionBillingCycleConnection!


  currencyCode: CurrencyCode!


  customAttributes: [Attribute!]!


  customer: Customer!


  customerPaymentMethod(

    showRevoked: Boolean = false
  ): CustomerPaymentMethod


  deliveryMethod: SubscriptionDeliveryMethod


  deliveryOptions(

    deliveryAddress: MailingAddressInput
  ): SubscriptionDeliveryOptionResult


  deliveryPolicy: SubscriptionDeliveryPolicy!


  deliveryPrice: MoneyV2


  discounts(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SubscriptionDiscountConnection!


  discountsAdded(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SubscriptionDiscountConnection!


  discountsRemoved(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SubscriptionDiscountConnection!


  discountsUpdated(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SubscriptionDiscountConnection!


  id: ID!


  lines(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SubscriptionLineConnection!


  linesAdded(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SubscriptionLineConnection!


  linesRemoved(

    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): SubscriptionLineConnection!


  nextBillingDate: DateTime


  note: String


  originalContract: SubscriptionContract


  shippingOptions(

    deliveryAddress: MailingAddressInput
  ): SubscriptionShippingOptionResult @deprecated(reason: "Use `deliveryOptions` instead.")


  status: SubscriptionContractSubscriptionStatus
}


type SubscriptionDraftCommitPayload {

  contract: SubscriptionContract


  userErrors: [SubscriptionDraftUserError!]!
}


type SubscriptionDraftDiscountAddPayload {

  discountAdded: SubscriptionManualDiscount


  draft: SubscriptionDraft


  userErrors: [SubscriptionDraftUserError!]!
}


type SubscriptionDraftDiscountCodeApplyPayload {

  appliedDiscount: SubscriptionAppliedCodeDiscount


  draft: SubscriptionDraft


  userErrors: [SubscriptionDraftUserError!]!
}


type SubscriptionDraftDiscountRemovePayload {

  discountRemoved: SubscriptionDiscount


  draft: SubscriptionDraft


  userErrors: [SubscriptionDraftUserError!]!
}


type SubscriptionDraftDiscountUpdatePayload {

  discountUpdated: SubscriptionManualDiscount


  draft: SubscriptionDraft


  userErrors: [SubscriptionDraftUserError!]!
}


enum SubscriptionDraftErrorCode {

  ALREADY_REMOVED


  PRESENCE


  COMMITTED


  NOT_IN_RANGE


  NOT_AN_INTEGER


  SELLING_PLAN_MAX_CYCLES_MUST_BE_GREATER_THAN_MIN_CYCLES


  DELIVERY_MUST_BE_MULTIPLE_OF_BILLING


  INVALID_BILLING_DATE


  INVALID_NOTE_LENGTH


  INVALID_LINES


  NO_ENTITLED_LINES


  CUSTOMER_DOES_NOT_EXIST


  CUSTOMER_MISMATCH


  DELIVERY_METHOD_REQUIRED


  MISSING_LOCAL_DELIVERY_OPTIONS


  CYCLE_DISCOUNTS_UNIQUE_AFTER_CYCLE


  INVALID_ADJUSTMENT_TYPE


  INVALID_ADJUSTMENT_VALUE


  STALE_CONTRACT


  CURRENCY_NOT_ENABLED


  HAS_FUTURE_EDITS


  BILLING_CYCLE_PRESENT


  BILLING_CYCLE_ABSENT


  BILLING_CYCLE_CONTRACT_DRAFT_DELIVERY_POLICY_INVALID


  BILLING_CYCLE_CONTRACT_DRAFT_BILLING_POLICY_INVALID


  CONCATENATION_BILLING_CYCLE_CONTRACT_DRAFT_REQUIRED


  DUPLICATE_CONCATENATED_CONTRACTS


  UPCOMING_CYCLE_LIMIT_EXCEEDED


  CYCLE_INDEX_OUT_OF_RANGE


  CYCLE_START_DATE_OUT_OF_RANGE


  CYCLE_SELECTOR_VALIDATE_ONE_OF


  EXCEEDED_MAX_CONCATENATED_CONTRACTS


  INVALID


  BLANK


  GREATER_THAN


  GREATER_THAN_OR_EQUAL_TO


  LESS_THAN


  LESS_THAN_OR_EQUAL_TO


  TOO_LONG


  TOO_SHORT
}


type SubscriptionDraftFreeShippingDiscountAddPayload {

  discountAdded: SubscriptionManualDiscount


  draft: SubscriptionDraft


  userErrors: [SubscriptionDraftUserError!]!
}


type SubscriptionDraftFreeShippingDiscountUpdatePayload {

  discountUpdated: SubscriptionManualDiscount


  draft: SubscriptionDraft


  userErrors: [SubscriptionDraftUserError!]!
}


input SubscriptionDraftInput {

  status: SubscriptionContractSubscriptionStatus


  paymentMethodId: ID


  nextBillingDate: DateTime


  billingPolicy: SubscriptionBillingPolicyInput


  deliveryPolicy: SubscriptionDeliveryPolicyInput


  deliveryPrice: Decimal


  deliveryMethod: SubscriptionDeliveryMethodInput


  note: String


  customAttributes: [AttributeInput!]
}


type SubscriptionDraftLineAddPayload {

  draft: SubscriptionDraft


  lineAdded: SubscriptionLine


  userErrors: [SubscriptionDraftUserError!]!
}


type SubscriptionDraftLineRemovePayload {

  discountsUpdated: [SubscriptionManualDiscount!]


  draft: SubscriptionDraft


  lineRemoved: SubscriptionLine


  userErrors: [SubscriptionDraftUserError!]!
}


type SubscriptionDraftLineUpdatePayload {

  draft: SubscriptionDraft


  lineUpdated: SubscriptionLine


  userErrors: [SubscriptionDraftUserError!]!
}


type SubscriptionDraftUpdatePayload {

  draft: SubscriptionDraft


  userErrors: [SubscriptionDraftUserError!]!
}


type SubscriptionDraftUserError implements DisplayableError {

  code: SubscriptionDraftErrorCode


  field: [String!]


  message: String!
}


input SubscriptionFreeShippingDiscountInput {

  title: String


  recurringCycleLimit: Int
}


type SubscriptionLine {

  currentPrice: MoneyV2!


  customAttributes: [Attribute!]!


  discountAllocations: [SubscriptionDiscountAllocation!]!


  id: ID!


  lineDiscountedPrice: MoneyV2!


  pricingPolicy: SubscriptionPricingPolicy


  productId: ID


  quantity: Int!


  requiresShipping: Boolean!


  sellingPlanId: ID


  sellingPlanName: String


  sku: String


  taxable: Boolean!


  title: String!


  variantId: ID


  variantImage: Image


  variantTitle: String
}


type SubscriptionLineConnection {

  edges: [SubscriptionLineEdge!]!


  nodes: [SubscriptionLine!]!


  pageInfo: PageInfo!
}


type SubscriptionLineEdge {

  cursor: String!


  node: SubscriptionLine!
}


input SubscriptionLineInput {

  productVariantId: ID!


  quantity: Int!


  currentPrice: Decimal!


  customAttributes: [AttributeInput!]


  sellingPlanId: ID


  sellingPlanName: String


  pricingPolicy: SubscriptionPricingPolicyInput
}


input SubscriptionLineUpdateInput {

  productVariantId: ID


  quantity: Int


  sellingPlanId: ID


  sellingPlanName: String


  currentPrice: Decimal


  customAttributes: [AttributeInput!]


  pricingPolicy: SubscriptionPricingPolicyInput
}


type SubscriptionLocalDeliveryOption {

  code: String!


  description: String


  phoneRequired: Boolean!


  presentmentTitle: String


  price: MoneyV2


  title: String!
}


type SubscriptionMailingAddress {

  address1: String


  address2: String


  city: String


  company: String


  country: String


  countryCode: CountryCode


  firstName: String


  lastName: String


  name: String


  phone: String


  province: String


  provinceCode: String


  zip: String
}


type SubscriptionManualDiscount {

  entitledLines: SubscriptionDiscountEntitledLines!


  id: ID!


  recurringCycleLimit: Int


  rejectionReason: SubscriptionDiscountRejectionReason


  targetType: DiscountTargetType!


  title: String


  type: DiscountType!


  usageCount: Int!


  value: SubscriptionDiscountValue!
}


type SubscriptionManualDiscountConnection {

  edges: [SubscriptionManualDiscountEdge!]!


  nodes: [SubscriptionManualDiscount!]!


  pageInfo: PageInfo!
}


type SubscriptionManualDiscountEdge {

  cursor: String!


  node: SubscriptionManualDiscount!
}


input SubscriptionManualDiscountEntitledLinesInput {

  all: Boolean


  lines: SubscriptionManualDiscountLinesInput
}


input SubscriptionManualDiscountFixedAmountInput {

  amount: Float


  appliesOnEachItem: Boolean
}


input SubscriptionManualDiscountInput {

  title: String


  value: SubscriptionManualDiscountValueInput


  recurringCycleLimit: Int


  entitledLines: SubscriptionManualDiscountEntitledLinesInput
}


input SubscriptionManualDiscountLinesInput {

  add: [ID!]


  remove: [ID!]
}


input SubscriptionManualDiscountValueInput {

  percentage: Int


  fixedAmount: SubscriptionManualDiscountFixedAmountInput
}


type SubscriptionPickupOption {

  code: String!


  description: String


  location: Location!


  phoneRequired: Boolean!


  pickupTime: String!


  presentmentTitle: String


  price: MoneyV2


  title: String!
}


type SubscriptionPricingPolicy {

  basePrice: MoneyV2!


  cycleDiscounts: [SubscriptionCyclePriceAdjustment!]!
}


input SubscriptionPricingPolicyCycleDiscountsInput {

  afterCycle: Int!


  adjustmentType: SellingPlanPricingPolicyAdjustmentType!


  adjustmentValue: SellingPlanPricingPolicyValueInput!


  computedPrice: Decimal!
}


input SubscriptionPricingPolicyInput {

  basePrice: Decimal!


  cycleDiscounts: [SubscriptionPricingPolicyCycleDiscountsInput!]!
}


type SubscriptionShippingOption {

  carrierService: DeliveryCarrierService @deprecated(reason: "This field has never been implemented.")


  code: String!


  description: String


  phoneRequired: Boolean


  presentmentTitle: String


  price: MoneyV2


  title: String!
}


union SubscriptionShippingOptionResult = SubscriptionShippingOptionResultFailure | SubscriptionShippingOptionResultSuccess


type SubscriptionShippingOptionResultFailure {

  message: String
}


type SubscriptionShippingOptionResultSuccess {

  shippingOptions: [SubscriptionShippingOption!]!
}


type SuggestedOrderTransaction {

  accountNumber: String


  amount: Money! @deprecated(reason: "Use `amountSet` instead.")


  amountSet: MoneyBag!


  formattedGateway: String


  gateway: String


  kind: SuggestedOrderTransactionKind!


  maximumRefundable: Money @deprecated(reason: "Use `maximumRefundableSet` instead.")


  maximumRefundableSet: MoneyBag


  parentTransaction: OrderTransaction


  paymentDetails: PaymentDetails
}


enum SuggestedOrderTransactionKind {

  SUGGESTED_REFUND
}


type SuggestedRefund {

  amount: Money! @deprecated(reason: "Use `amountSet` instead.")


  amountSet: MoneyBag!


  discountedSubtotalSet: MoneyBag!


  maximumRefundable: Money! @deprecated(reason: "Use `maximumRefundableSet` instead.")


  maximumRefundableSet: MoneyBag!


  refundDuties: [RefundDuty!]!


  refundLineItems: [RefundLineItem!]!


  shipping: ShippingRefund!


  subtotal: Money! @deprecated(reason: "Use `subtotalSet` instead.")


  subtotalSet: MoneyBag!


  suggestedTransactions: [SuggestedOrderTransaction!]!


  totalCartDiscountAmountSet: MoneyBag!


  totalDutiesSet: MoneyBag!


  totalTaxSet: MoneyBag!


  totalTaxes: Money! @deprecated(reason: "Use `totalTaxSet` instead.")
}


type SuggestedReturnRefund {

  amount: MoneyBag!


  discountedSubtotal: MoneyBag!


  maximumRefundable: MoneyBag!


  refundDuties: [RefundDuty!]!


  shipping: ShippingRefund!


  subtotal: MoneyBag!


  suggestedTransactions: [SuggestedOrderTransaction!]!


  totalCartDiscountAmount: MoneyBag!


  totalDuties: MoneyBag!


  totalTax: MoneyBag!
}


type TableData {

  columns: [TableDataColumn!]!


  rowData: [[String!]!]!


  unformattedData: JSON!
}


type TableDataColumn {

  comparedTo: String!


  dataType: String!


  displayName: String!


  name: String!
}


type TableResponse implements ShopifyqlResponse {

  parseErrors: [ParseError!]


  tableData: TableData
}


type TagsAddPayload {

  node: Node


  userErrors: [UserError!]!
}


type TagsRemovePayload {

  node: Node


  userErrors: [UserError!]!
}


type TaxAppConfiguration {

  state: TaxPartnerState!
}


type TaxAppConfigurePayload {

  taxAppConfiguration: TaxAppConfiguration


  userErrors: [TaxAppConfigureUserError!]!
}


type TaxAppConfigureUserError implements DisplayableError {

  code: TaxAppConfigureUserErrorCode


  field: [String!]


  message: String!
}


enum TaxAppConfigureUserErrorCode {

  TAX_PARTNER_NOT_FOUND


  TAX_PARTNER_STATE_UPDATE_FAILED


  TAX_PARTNER_ALREADY_ACTIVE
}


enum TaxExemption {

  CA_STATUS_CARD_EXEMPTION


  CA_BC_RESELLER_EXEMPTION


  CA_MB_RESELLER_EXEMPTION


  CA_SK_RESELLER_EXEMPTION


  CA_DIPLOMAT_EXEMPTION


  CA_BC_COMMERCIAL_FISHERY_EXEMPTION


  CA_MB_COMMERCIAL_FISHERY_EXEMPTION


  CA_NS_COMMERCIAL_FISHERY_EXEMPTION


  CA_PE_COMMERCIAL_FISHERY_EXEMPTION


  CA_SK_COMMERCIAL_FISHERY_EXEMPTION


  CA_BC_PRODUCTION_AND_MACHINERY_EXEMPTION


  CA_SK_PRODUCTION_AND_MACHINERY_EXEMPTION


  CA_BC_SUB_CONTRACTOR_EXEMPTION


  CA_SK_SUB_CONTRACTOR_EXEMPTION


  CA_BC_CONTRACTOR_EXEMPTION


  CA_SK_CONTRACTOR_EXEMPTION


  CA_ON_PURCHASE_EXEMPTION


  CA_MB_FARMER_EXEMPTION


  CA_NS_FARMER_EXEMPTION


  CA_SK_FARMER_EXEMPTION


  EU_REVERSE_CHARGE_EXEMPTION_RULE


  US_AL_RESELLER_EXEMPTION


  US_AK_RESELLER_EXEMPTION


  US_AZ_RESELLER_EXEMPTION


  US_AR_RESELLER_EXEMPTION


  US_CA_RESELLER_EXEMPTION


  US_CO_RESELLER_EXEMPTION


  US_CT_RESELLER_EXEMPTION


  US_DE_RESELLER_EXEMPTION


  US_FL_RESELLER_EXEMPTION


  US_GA_RESELLER_EXEMPTION


  US_HI_RESELLER_EXEMPTION


  US_ID_RESELLER_EXEMPTION


  US_IL_RESELLER_EXEMPTION


  US_IN_RESELLER_EXEMPTION


  US_IA_RESELLER_EXEMPTION


  US_KS_RESELLER_EXEMPTION


  US_KY_RESELLER_EXEMPTION


  US_LA_RESELLER_EXEMPTION


  US_ME_RESELLER_EXEMPTION


  US_MD_RESELLER_EXEMPTION


  US_MA_RESELLER_EXEMPTION


  US_MI_RESELLER_EXEMPTION


  US_MN_RESELLER_EXEMPTION


  US_MS_RESELLER_EXEMPTION


  US_MO_RESELLER_EXEMPTION


  US_MT_RESELLER_EXEMPTION


  US_NE_RESELLER_EXEMPTION


  US_NV_RESELLER_EXEMPTION


  US_NH_RESELLER_EXEMPTION


  US_NJ_RESELLER_EXEMPTION


  US_NM_RESELLER_EXEMPTION


  US_NY_RESELLER_EXEMPTION


  US_NC_RESELLER_EXEMPTION


  US_ND_RESELLER_EXEMPTION


  US_OH_RESELLER_EXEMPTION


  US_OK_RESELLER_EXEMPTION


  US_OR_RESELLER_EXEMPTION


  US_PA_RESELLER_EXEMPTION


  US_RI_RESELLER_EXEMPTION


  US_SC_RESELLER_EXEMPTION


  US_SD_RESELLER_EXEMPTION


  US_TN_RESELLER_EXEMPTION


  US_TX_RESELLER_EXEMPTION


  US_UT_RESELLER_EXEMPTION


  US_VT_RESELLER_EXEMPTION


  US_VA_RESELLER_EXEMPTION


  US_WA_RESELLER_EXEMPTION


  US_WV_RESELLER_EXEMPTION


  US_WI_RESELLER_EXEMPTION


  US_WY_RESELLER_EXEMPTION


  US_DC_RESELLER_EXEMPTION
}


type TaxLine {

  channelLiable: Boolean


  price: Money! @deprecated(reason: "Use `priceSet` instead.")


  priceSet: MoneyBag!


  rate: Float


  ratePercentage: Float


  title: String!
}


enum TaxPartnerState {

  PENDING


  READY


  ACTIVE
}


type TenderTransaction implements Node {

  amount: MoneyV2!


  id: ID!


  paymentMethod: String


  processedAt: DateTime


  remoteReference: String


  test: Boolean!


  transactionDetails: TenderTransactionDetails


  user: StaffMember
}


type TenderTransactionConnection {

  edges: [TenderTransactionEdge!]!


  nodes: [TenderTransaction!]!


  pageInfo: PageInfo!
}


type TenderTransactionCreditCardDetails {

  creditCardCompany: String


  creditCardNumber: String
}


union TenderTransactionDetails = TenderTransactionCreditCardDetails


type TenderTransactionEdge {

  cursor: String!


  node: TenderTransaction!
}


type TipSale implements Sale {

  actionType: SaleActionType!


  id: ID!


  lineItem: LineItem!


  lineType: SaleLineType!


  quantity: Int


  taxes: [SaleTax!]!


  totalAmount: MoneyBag!


  totalDiscountAmountAfterTaxes: MoneyBag!


  totalDiscountAmountBeforeTaxes: MoneyBag!


  totalTaxAmount: MoneyBag!
}


type TransactionFee implements Node {

  amount: MoneyV2!


  flatFee: MoneyV2!


  flatFeeName: String


  id: ID!


  rate: Decimal!


  rateName: String


  taxAmount: MoneyV2!


  type: String!
}


type TranslatableContent {

  digest: String


  key: String!


  locale: String!


  type: LocalizableContentType!


  value: String
}


type TranslatableResource {

  resourceId: ID!


  translatableContent: [TranslatableContent!]!


  translations(

    locale: String!


    outdated: Boolean


    marketId: ID
  ): [Translation!]!
}


type TranslatableResourceConnection {

  edges: [TranslatableResourceEdge!]!


  nodes: [TranslatableResource!]!


  pageInfo: PageInfo!
}


type TranslatableResourceEdge {

  cursor: String!


  node: TranslatableResource!
}


enum TranslatableResourceType {

  COLLECTION


  DELIVERY_METHOD_DEFINITION


  EMAIL_TEMPLATE


  FILTER


  LINK


  METAFIELD


  METAOBJECT


  ONLINE_STORE_ARTICLE


  ONLINE_STORE_BLOG


  ONLINE_STORE_MENU


  ONLINE_STORE_PAGE


  ONLINE_STORE_THEME


  PACKING_SLIP_TEMPLATE


  PAYMENT_GATEWAY


  PRODUCT


  PRODUCT_OPTION


  PRODUCT_VARIANT @deprecated(reason: "`PRODUCT_VARIANT` is deprecated, it is no longer a translatable resource type. Use `PRODUCT_OPTION_VALUE` instead.")


  SELLING_PLAN


  SELLING_PLAN_GROUP


  SHOP


  SHOP_POLICY
}


type Translation {

  key: String!


  locale: String!


  market: Market


  outdated: Boolean!


  updatedAt: DateTime


  value: String
}


enum TranslationErrorCode {

  BLANK


  INVALID


  RESOURCE_NOT_FOUND


  RESOURCE_NOT_TRANSLATABLE


  TOO_MANY_KEYS_FOR_RESOURCE


  INVALID_KEY_FOR_MODEL


  FAILS_RESOURCE_VALIDATION


  INVALID_TRANSLATABLE_CONTENT


  INVALID_MARKET_LOCALIZABLE_CONTENT


  INVALID_LOCALE_FOR_SHOP


  INVALID_CODE


  INVALID_FORMAT


  MARKET_CUSTOM_CONTENT_NOT_ALLOWED


  MARKET_DOES_NOT_EXIST


  MARKET_LOCALE_CREATION_FAILED


  RESOURCE_NOT_MARKET_CUSTOMIZABLE


  INVALID_LOCALE_FOR_MARKET


  INVALID_VALUE_FOR_HANDLE_TRANSLATION
}


input TranslationInput {

  locale: String!


  key: String!


  value: String!


  translatableContentDigest: String!


  marketId: ID
}


type TranslationsRegisterPayload {

  translations: [Translation!]


  userErrors: [TranslationUserError!]!
}


type TranslationsRemovePayload {

  translations: [Translation!]


  userErrors: [TranslationUserError!]!
}


type TranslationUserError implements DisplayableError {

  code: TranslationErrorCode


  field: [String!]


  message: String!
}


type TypedAttribute {

  key: String!


  value: String!
}


enum UnitSystem {

  IMPERIAL_SYSTEM


  METRIC_SYSTEM
}


type UnknownSale implements Sale {

  actionType: SaleActionType!


  id: ID!


  lineType: SaleLineType!


  quantity: Int


  taxes: [SaleTax!]!


  totalAmount: MoneyBag!


  totalDiscountAmountAfterTaxes: MoneyBag!


  totalDiscountAmountBeforeTaxes: MoneyBag!


  totalTaxAmount: MoneyBag!
}


scalar UnsignedInt64


input UpdateMediaInput {

  id: ID!


  previewImageSource: String


  alt: String
}


scalar URL


type UrlRedirect implements Node {

  id: ID!


  path: String!


  target: String!
}


type UrlRedirectBulkDeleteAllPayload {

  job: Job


  userErrors: [UserError!]!
}


type UrlRedirectBulkDeleteByIdsPayload {

  job: Job


  userErrors: [UrlRedirectBulkDeleteByIdsUserError!]!
}


type UrlRedirectBulkDeleteByIdsUserError implements DisplayableError {

  code: UrlRedirectBulkDeleteByIdsUserErrorCode


  field: [String!]


  message: String!
}


enum UrlRedirectBulkDeleteByIdsUserErrorCode {

  IDS_EMPTY
}


type UrlRedirectBulkDeleteBySavedSearchPayload {

  job: Job


  userErrors: [UrlRedirectBulkDeleteBySavedSearchUserError!]!
}


type UrlRedirectBulkDeleteBySavedSearchUserError implements DisplayableError {

  code: UrlRedirectBulkDeleteBySavedSearchUserErrorCode


  field: [String!]


  message: String!
}


enum UrlRedirectBulkDeleteBySavedSearchUserErrorCode {

  SAVED_SEARCH_NOT_FOUND


  INVALID_SAVED_SEARCH_QUERY
}


type UrlRedirectBulkDeleteBySearchPayload {

  job: Job


  userErrors: [UrlRedirectBulkDeleteBySearchUserError!]!
}


type UrlRedirectBulkDeleteBySearchUserError implements DisplayableError {

  code: UrlRedirectBulkDeleteBySearchUserErrorCode


  field: [String!]


  message: String!
}


enum UrlRedirectBulkDeleteBySearchUserErrorCode {

  INVALID_SEARCH_ARGUMENT
}


type UrlRedirectConnection {

  edges: [UrlRedirectEdge!]!


  nodes: [UrlRedirect!]!


  pageInfo: PageInfo!
}


type UrlRedirectCreatePayload {

  urlRedirect: UrlRedirect


  userErrors: [UrlRedirectUserError!]!
}


type UrlRedirectDeletePayload {

  deletedUrlRedirectId: ID


  userErrors: [UrlRedirectUserError!]!
}


type UrlRedirectEdge {

  cursor: String!


  node: UrlRedirect!
}


enum UrlRedirectErrorCode {

  DOES_NOT_EXIST


  CREATE_FAILED


  UPDATE_FAILED


  DELETE_FAILED
}


type UrlRedirectImport implements Node {

  count: Int


  createdCount: Int


  failedCount: Int


  finished: Boolean!


  finishedAt: DateTime


  id: ID!


  previewRedirects: [UrlRedirectImportPreview!]!


  updatedCount: Int
}


type UrlRedirectImportCreatePayload {

  urlRedirectImport: UrlRedirectImport


  userErrors: [UrlRedirectImportUserError!]!
}


enum UrlRedirectImportErrorCode {

  FILE_DOES_NOT_EXIST @deprecated(reason: "This error code is never returned")


  NOT_FOUND


  ALREADY_IMPORTED


  IN_PROGRESS
}


type UrlRedirectImportPreview {

  path: String!


  target: String!
}


type UrlRedirectImportSubmitPayload {

  job: Job


  userErrors: [UrlRedirectImportUserError!]!
}


type UrlRedirectImportUserError implements DisplayableError {

  code: UrlRedirectImportErrorCode


  field: [String!]


  message: String!
}


input UrlRedirectInput {

  path: String


  target: String
}


enum UrlRedirectSortKeys {

  RELEVANCE


  PATH


  ID
}


type UrlRedirectUpdatePayload {

  urlRedirect: UrlRedirect


  userErrors: [UrlRedirectUserError!]!
}


type UrlRedirectUserError implements DisplayableError {

  code: UrlRedirectErrorCode


  field: [String!]


  message: String!
}


type UserError implements DisplayableError {

  field: [String!]


  message: String!
}


scalar UtcOffset


input UTMInput {

  campaign: String!


  source: String!


  medium: String!
}


type UTMParameters {

  campaign: String


  content: String


  medium: String


  source: String


  term: String
}


type Validation implements HasMetafieldDefinitions & HasMetafields & Node {

  blockOnFailure: Boolean!


  enabled: Boolean!


  errorHistory: FunctionsErrorHistory


  id: ID!


  metafield(

    namespace: String


    key: String!
  ): Metafield


  metafieldDefinitions(

    namespace: String


    pinnedStatus: MetafieldDefinitionPinnedStatus = ANY


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false


    sortKey: MetafieldDefinitionSortKeys = ID


    query: String
  ): MetafieldDefinitionConnection!


  metafields(

    namespace: String


    keys: [String!]


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): MetafieldConnection!


  privateMetafield(

    namespace: String!


    key: String!
  ): PrivateMetafield @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  privateMetafields(

    namespace: String


    first: Int


    after: String


    last: Int


    before: String


    reverse: Boolean = false
  ): PrivateMetafieldConnection! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  shopifyFunction: ShopifyFunction!


  title: String!
}


type ValidationConnection {

  edges: [ValidationEdge!]!


  nodes: [Validation!]!


  pageInfo: PageInfo!
}


input ValidationCreateInput {

  functionId: String!


  enable: Boolean = false


  blockOnFailure: Boolean = false


  metafields: [MetafieldInput!] = []
}


type ValidationCreatePayload {

  userErrors: [ValidationUserError!]!


  validation: Validation
}


type ValidationDeletePayload {

  deletedId: ID


  userErrors: [ValidationUserError!]!
}


type ValidationEdge {

  cursor: String!


  node: Validation!
}


enum ValidationSortKeys {

  ID


  RELEVANCE
}


input ValidationUpdateInput {

  enable: Boolean = false


  blockOnFailure: Boolean = false


  metafields: [MetafieldInput!] = []
}


type ValidationUpdatePayload {

  userErrors: [ValidationUserError!]!


  validation: Validation
}


type ValidationUserError implements DisplayableError {

  code: ValidationUserErrorCode


  field: [String!]


  message: String!
}


enum ValidationUserErrorCode {

  NOT_FOUND


  FUNCTION_NOT_FOUND


  CUSTOM_APP_FUNCTION_NOT_ELIGIBLE


  FUNCTION_DOES_NOT_IMPLEMENT


  PUBLIC_APP_NOT_ALLOWED


  FUNCTION_PENDING_DELETION


  INVALID_TYPE


  INVALID_VALUE


  APP_NOT_AUTHORIZED


  UNSTRUCTURED_RESERVED_NAMESPACE


  DISALLOWED_OWNER_TYPE


  INCLUSION


  TAKEN


  PRESENT


  BLANK


  TOO_LONG


  TOO_SHORT
}


type VaultCreditCard {

  billingAddress: CustomerCreditCardBillingAddress


  brand: String!


  expired: Boolean!


  expiryMonth: Int!


  expiryYear: Int!


  lastDigits: String!


  name: String!
}


type VaultPaypalBillingAgreement {

  inactive: Boolean!


  name: String!


  paypalAccountEmail: String!
}


type Vector3 {

  x: Float!


  y: Float!


  z: Float!
}


type Video implements File & Media & Node {

  alt: String


  createdAt: DateTime!


  duration: Int


  fileErrors: [FileError!]!


  fileStatus: FileStatus!


  filename: String!


  id: ID!


  mediaContentType: MediaContentType!


  mediaErrors: [MediaError!]!


  mediaWarnings: [MediaWarning!]!


  originalSource: VideoSource


  preview: MediaPreviewImage


  sources: [VideoSource!]!


  status: MediaStatus!


  updatedAt: DateTime!
}


type VideoSource {

  fileSize: Int


  format: String!


  height: Int!


  mimeType: String!


  url: String!


  width: Int!
}


enum VisualizationType {

  LINE


  BAR
}


type WebhookEventBridgeEndpoint {

  arn: ARN!
}


type WebhookHttpEndpoint {

  callbackUrl: URL!
}


type WebhookPubSubEndpoint {

  pubSubProject: String!


  pubSubTopic: String!
}


type WebhookSubscription implements LegacyInteroperability & Node {

  apiVersion: ApiVersion!


  callbackUrl: URL! @deprecated(reason: "Use `endpoint` instead.")


  createdAt: DateTime!


  endpoint: WebhookSubscriptionEndpoint!


  format: WebhookSubscriptionFormat!


  id: ID!


  includeFields: [String!]!


  legacyResourceId: UnsignedInt64!


  metafieldNamespaces: [String!]!


  privateMetafieldNamespaces: [String!]! @deprecated(reason: "Metafields created using a reserved namespace are private by default. See our guide for\n[migrating private metafields](https://shopify.dev/docs/apps/custom-data/metafields/migrate-private-metafields).\n")


  subTopic: String


  topic: WebhookSubscriptionTopic!


  updatedAt: DateTime!
}


type WebhookSubscriptionConnection {

  edges: [WebhookSubscriptionEdge!]!


  nodes: [WebhookSubscription!]!


  pageInfo: PageInfo!
}


type WebhookSubscriptionCreatePayload {

  userErrors: [UserError!]!


  webhookSubscription: WebhookSubscription
}


type WebhookSubscriptionDeletePayload {

  deletedWebhookSubscriptionId: ID


  userErrors: [UserError!]!
}


type WebhookSubscriptionEdge {

  cursor: String!


  node: WebhookSubscription!
}


union WebhookSubscriptionEndpoint = WebhookEventBridgeEndpoint | WebhookHttpEndpoint | WebhookPubSubEndpoint


enum WebhookSubscriptionFormat {
  JSON
  XML
}


input WebhookSubscriptionInput {

  callbackUrl: URL


  format: WebhookSubscriptionFormat


  includeFields: [String!]


  metafieldNamespaces: [String!]
}


enum WebhookSubscriptionSortKeys {

  CREATED_AT


  ID


  RELEVANCE
}


enum WebhookSubscriptionTopic {

  APP_UNINSTALLED


  CARTS_CREATE


  CARTS_UPDATE


  CHANNELS_DELETE


  CHECKOUTS_CREATE


  CHECKOUTS_DELETE


  CHECKOUTS_UPDATE


  CUSTOMER_PAYMENT_METHODS_CREATE


  CUSTOMER_PAYMENT_METHODS_UPDATE


  CUSTOMER_PAYMENT_METHODS_REVOKE


  COLLECTION_LISTINGS_ADD


  COLLECTION_LISTINGS_REMOVE


  COLLECTION_LISTINGS_UPDATE


  COLLECTION_PUBLICATIONS_CREATE


  COLLECTION_PUBLICATIONS_DELETE


  COLLECTION_PUBLICATIONS_UPDATE


  COLLECTIONS_CREATE


  COLLECTIONS_DELETE


  COLLECTIONS_UPDATE


  CUSTOMER_GROUPS_CREATE


  CUSTOMER_GROUPS_DELETE


  CUSTOMER_GROUPS_UPDATE


  CUSTOMERS_CREATE


  CUSTOMERS_DELETE


  CUSTOMERS_DISABLE


  CUSTOMERS_ENABLE


  CUSTOMERS_UPDATE


  CUSTOMERS_MARKETING_CONSENT_UPDATE


  CUSTOMER_TAGS_ADDED


  CUSTOMER_TAGS_REMOVED


  CUSTOMERS_EMAIL_MARKETING_CONSENT_UPDATE


  DISPUTES_CREATE


  DISPUTES_UPDATE


  DRAFT_ORDERS_CREATE


  DRAFT_ORDERS_DELETE


  DRAFT_ORDERS_UPDATE


  FULFILLMENT_EVENTS_CREATE


  FULFILLMENT_EVENTS_DELETE


  FULFILLMENTS_CREATE


  FULFILLMENTS_UPDATE


  ATTRIBUTED_SESSIONS_FIRST


  ATTRIBUTED_SESSIONS_LAST


  ORDER_TRANSACTIONS_CREATE


  ORDERS_CANCELLED


  ORDERS_CREATE


  ORDERS_DELETE


  ORDERS_EDITED


  ORDERS_FULFILLED


  ORDERS_PAID


  ORDERS_PARTIALLY_FULFILLED


  ORDERS_UPDATED


  FULFILLMENT_ORDERS_MOVED


  FULFILLMENT_ORDERS_HOLD_RELEASED


  FULFILLMENT_ORDERS_SCHEDULED_FULFILLMENT_ORDER_READY


  FULFILLMENT_ORDERS_ORDER_ROUTING_COMPLETE


  FULFILLMENT_ORDERS_CANCELLED


  FULFILLMENT_ORDERS_FULFILLMENT_SERVICE_FAILED_TO_COMPLETE


  FULFILLMENT_ORDERS_FULFILLMENT_REQUEST_REJECTED


  FULFILLMENT_ORDERS_CANCELLATION_REQUEST_SUBMITTED


  FULFILLMENT_ORDERS_CANCELLATION_REQUEST_ACCEPTED


  FULFILLMENT_ORDERS_CANCELLATION_REQUEST_REJECTED


  FULFILLMENT_ORDERS_FULFILLMENT_REQUEST_SUBMITTED


  FULFILLMENT_ORDERS_FULFILLMENT_REQUEST_ACCEPTED


  FULFILLMENT_ORDERS_LINE_ITEMS_PREPARED_FOR_LOCAL_DELIVERY


  FULFILLMENT_ORDERS_PLACED_ON_HOLD


  FULFILLMENT_ORDERS_MERGED


  FULFILLMENT_ORDERS_SPLIT


  PRODUCT_LISTINGS_ADD


  PRODUCT_LISTINGS_REMOVE


  PRODUCT_LISTINGS_UPDATE


  SCHEDULED_PRODUCT_LISTINGS_ADD


  SCHEDULED_PRODUCT_LISTINGS_UPDATE


  SCHEDULED_PRODUCT_LISTINGS_REMOVE


  PRODUCT_PUBLICATIONS_CREATE


  PRODUCT_PUBLICATIONS_DELETE


  PRODUCT_PUBLICATIONS_UPDATE


  PRODUCTS_CREATE


  PRODUCTS_DELETE


  PRODUCTS_UPDATE


  REFUNDS_CREATE


  SEGMENTS_CREATE


  SEGMENTS_DELETE


  SEGMENTS_UPDATE


  SHIPPING_ADDRESSES_CREATE


  SHIPPING_ADDRESSES_UPDATE


  SHOP_UPDATE


  TAX_PARTNERS_UPDATE


  TAX_SERVICES_CREATE


  TAX_SERVICES_UPDATE


  THEMES_CREATE


  THEMES_DELETE


  THEMES_PUBLISH


  THEMES_UPDATE


  VARIANTS_IN_STOCK


  VARIANTS_OUT_OF_STOCK


  INVENTORY_LEVELS_CONNECT


  INVENTORY_LEVELS_UPDATE


  INVENTORY_LEVELS_DISCONNECT


  INVENTORY_ITEMS_CREATE


  INVENTORY_ITEMS_UPDATE


  INVENTORY_ITEMS_DELETE


  LOCATIONS_ACTIVATE


  LOCATIONS_DEACTIVATE


  LOCATIONS_CREATE


  LOCATIONS_UPDATE


  LOCATIONS_DELETE


  TENDER_TRANSACTIONS_CREATE


  APP_PURCHASES_ONE_TIME_UPDATE


  APP_SUBSCRIPTIONS_APPROACHING_CAPPED_AMOUNT


  APP_SUBSCRIPTIONS_UPDATE


  LOCALES_CREATE


  LOCALES_UPDATE


  DOMAINS_CREATE


  DOMAINS_UPDATE


  DOMAINS_DESTROY


  SUBSCRIPTION_CONTRACTS_CREATE


  SUBSCRIPTION_CONTRACTS_UPDATE


  SUBSCRIPTION_BILLING_CYCLE_EDITS_CREATE


  SUBSCRIPTION_BILLING_CYCLE_EDITS_UPDATE


  SUBSCRIPTION_BILLING_CYCLE_EDITS_DELETE


  PROFILES_CREATE


  PROFILES_UPDATE


  PROFILES_DELETE


  SUBSCRIPTION_BILLING_ATTEMPTS_SUCCESS


  SUBSCRIPTION_BILLING_ATTEMPTS_FAILURE


  SUBSCRIPTION_BILLING_ATTEMPTS_CHALLENGED


  RETURNS_CANCEL


  RETURNS_CLOSE


  RETURNS_REOPEN


  RETURNS_REQUEST


  RETURNS_APPROVE


  RETURNS_DECLINE


  REVERSE_DELIVERIES_ATTACH_DELIVERABLE


  REVERSE_FULFILLMENT_ORDERS_DISPOSE


  PAYMENT_TERMS_CREATE


  PAYMENT_TERMS_DELETE


  PAYMENT_TERMS_UPDATE


  PAYMENT_SCHEDULES_DUE


  SELLING_PLAN_GROUPS_CREATE


  SELLING_PLAN_GROUPS_UPDATE


  SELLING_PLAN_GROUPS_DELETE


  BULK_OPERATIONS_FINISH


  PRODUCT_FEEDS_CREATE


  PRODUCT_FEEDS_UPDATE


  PRODUCT_FEEDS_INCREMENTAL_SYNC


  PRODUCT_FEEDS_FULL_SYNC


  MARKETS_CREATE


  MARKETS_UPDATE


  MARKETS_DELETE


  ORDERS_SHOPIFY_PROTECT_ELIGIBILITY_CHANGED


  FULFILLMENT_ORDERS_RESCHEDULED


  PUBLICATIONS_DELETE


  AUDIT_EVENTS_ADMIN_API_ACTIVITY


  FULFILLMENT_ORDERS_LINE_ITEMS_PREPARED_FOR_PICKUP


  COMPANIES_CREATE


  COMPANIES_UPDATE


  COMPANIES_DELETE


  COMPANY_LOCATIONS_CREATE


  COMPANY_LOCATIONS_UPDATE


  COMPANY_LOCATIONS_DELETE


  COMPANY_CONTACTS_CREATE


  COMPANY_CONTACTS_UPDATE


  COMPANY_CONTACTS_DELETE


  CUSTOMERS_MERGE


  COMPANY_CONTACT_ROLES_ASSIGN


  COMPANY_CONTACT_ROLES_REVOKE


  SUBSCRIPTION_CONTRACTS_ACTIVATE


  SUBSCRIPTION_CONTRACTS_PAUSE


  SUBSCRIPTION_CONTRACTS_CANCEL


  SUBSCRIPTION_CONTRACTS_FAIL


  SUBSCRIPTION_CONTRACTS_EXPIRE


  SUBSCRIPTION_BILLING_CYCLES_SKIP


  SUBSCRIPTION_BILLING_CYCLES_UNSKIP


  METAOBJECTS_CREATE


  METAOBJECTS_UPDATE


  METAOBJECTS_DELETE


  DISCOUNTS_CREATE


  DISCOUNTS_UPDATE


  DISCOUNTS_DELETE


  DISCOUNTS_REDEEMCODE_ADDED


  DISCOUNTS_REDEEMCODE_REMOVED
}


type WebhookSubscriptionUpdatePayload {

  userErrors: [UserError!]!


  webhookSubscription: WebhookSubscription
}


type WebPixel implements Node {

  id: ID!


  settings: JSON!
}


type WebPixelCreatePayload {

  userErrors: [ErrorsWebPixelUserError!]!


  webPixel: WebPixel
}


type WebPixelDeletePayload {

  deletedWebPixelId: ID


  userErrors: [ErrorsWebPixelUserError!]!
}


input WebPixelInput {

  settings: JSON!
}


type WebPixelUpdatePayload {

  userErrors: [ErrorsWebPixelUserError!]!


  webPixel: WebPixel
}


type Weight {

  unit: WeightUnit!


  value: Float!
}


input WeightInput {

  value: Float!


  unit: WeightUnit!
}


enum WeightUnit {

  KILOGRAMS


  GRAMS


  POUNDS


  OUNCES
}

